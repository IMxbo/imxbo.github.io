<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>xbo&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="xbo&#39;s Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="xbo&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="xbo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="xbo's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xbo&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-设计模式-总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.784Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><h2 id="1-软件设计模式的概念"><a href="#1-软件设计模式的概念" class="headerlink" title="1. 软件设计模式的概念"></a>1. 软件设计模式的概念</h2><p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p>
<h2 id="2-学习设计模式的意义"><a href="#2-学习设计模式的意义" class="headerlink" title="2. 学习设计模式的意义"></a>2. 学习设计模式的意义</h2><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。</p>
<h1 id="GoF-的-23-种设计模式的分类和功能"><a href="#GoF-的-23-种设计模式的分类和功能" class="headerlink" title="GoF 的 23 种设计模式的分类和功能"></a>GoF 的 23 种设计模式的分类和功能</h1><p>设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分。</p>
<h2 id="1-根据目的来分"><a href="#1-根据目的来分" class="headerlink" title="1. 根据目的来分"></a>1. 根据目的来分</h2><p>根据模式是用来完成什么工作来划分，这种方式可分为创建型模式结构型模行为型模式</p>
<ol>
<li>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li>
<li>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li>
<li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</li>
</ol>
<h2 id="2-根据作用范围来分"><a href="#2-根据作用范围来分" class="headerlink" title="2. 根据作用范围来分"></a>2. 根据作用范围来分</h2><p>根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式对象模式</p>
<ol>
<li><p>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</p>
</li>
<li><p>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。</p>
</li>
</ol>
<p>表 1 介绍了这 23 种设计模式的分类。</p>
<img src="设计模式-总结.assets/image-20200325153100709.png" alt="image-20200325153100709" style="zoom:33%;" />

<h4 id="3-GoF的23种设计模式的功能"><a href="#3-GoF的23种设计模式的功能" class="headerlink" title="3. GoF的23种设计模式的功能"></a>3. GoF的23种设计模式的功能</h4><p>前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。</p>
<ol>
<li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
<li>模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E7%BB%93/" data-id="ckmn1lhzp000en8a8b78tg1kx" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ovs使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/ovs%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.770Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ovs使用"><a href="#ovs使用" class="headerlink" title="ovs使用"></a>ovs使用</h1><p>python中执行shell命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system() <span class="comment">#返回值表示命令的返回值，0表示执行成功。</span></span><br><span class="line">os.popen() <span class="comment">#可以获取命令的执行结果</span></span><br><span class="line">os.popen().read()</span><br></pre></td></tr></table></figure>

<p>ovs流表操作</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangjq19920210/p/11776824.html">https://www.cnblogs.com/wangjq19920210/p/11776824.html</a></p>
<p>RYU提供了web ui，启动web ui</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要修改./bin/ryu第一行的python解释器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不能同时运行ryu-manager</span></span><br><span class="line">PYTHONPATH=. ./bin/ryu run --observe-links ryu/app/gui_topology/gui_topology.py</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">ovs-ofctl: OpenFlow switch management utility</span><br><span class="line">usage: ovs-ofctl [OPTIONS] COMMAND [ARG...]</span><br><span class="line"></span><br><span class="line">For OpenFlow switches:</span><br><span class="line">  show SWITCH                 show OpenFlow information</span><br><span class="line">  dump-desc SWITCH            print switch description</span><br><span class="line">  dump-tables SWITCH          print table stats</span><br><span class="line">  dump-table-features SWITCH  print table features</span><br><span class="line">  dump-table-desc SWITCH      print table description (OF1.4+)</span><br><span class="line">  mod-port SWITCH IFACE ACT   modify port behavior</span><br><span class="line">  mod-table SWITCH MOD        modify flow table behavior</span><br><span class="line">      OF1.1/1.2 MOD: controller, continue, drop</span><br><span class="line">      OF1.4+ MOD: evict, noevict, vacancy:low,high, novacancy</span><br><span class="line">  get-frags SWITCH            print fragment handling behavior</span><br><span class="line">  set-frags SWITCH FRAG_MODE  set fragment handling behavior</span><br><span class="line">      FRAG_MODE: normal, drop, reassemble, nx-match</span><br><span class="line">  dump-ports SWITCH [PORT]    print port statistics</span><br><span class="line">  dump-ports-desc SWITCH [PORT]  print port descriptions</span><br><span class="line">  dump-flows SWITCH           print all flow entries</span><br><span class="line">  dump-flows SWITCH FLOW      print matching FLOWs</span><br><span class="line">  dump-aggregate SWITCH       print aggregate flow statistics</span><br><span class="line">  dump-aggregate SWITCH FLOW  print aggregate stats for FLOWs</span><br><span class="line">  queue-stats SWITCH [PORT [QUEUE]]  dump queue stats</span><br><span class="line">  add-flow SWITCH FLOW        add flow described by FLOW</span><br><span class="line">  add-flows SWITCH FILE       add flows from FILE</span><br><span class="line">  mod-flows SWITCH FLOW       modify actions of matching FLOWs</span><br><span class="line">  del-flows SWITCH [FLOW]     delete matching FLOWs</span><br><span class="line">  replace-flows SWITCH FILE   replace flows with those in FILE</span><br><span class="line">  diff-flows SOURCE1 SOURCE2  compare flows from two sources</span><br><span class="line">  packet-out SWITCH IN_PORT ACTIONS PACKET...</span><br><span class="line">                              execute ACTIONS on PACKET</span><br><span class="line">  monitor SWITCH [MISSLEN] [invalid_ttl] [watch:[...]]</span><br><span class="line">                              print packets received from SWITCH</span><br><span class="line">  snoop SWITCH                snoop on SWITCH and its controller</span><br><span class="line">  add-group SWITCH GROUP      add group described by GROUP</span><br><span class="line">  add-groups SWITCH FILE      add group from FILE</span><br><span class="line">  mod-group SWITCH GROUP      modify specific group</span><br><span class="line">  del-groups SWITCH [GROUP]   delete matching GROUPs</span><br><span class="line">  insert-buckets SWITCH [GROUP] add buckets to GROUP</span><br><span class="line">  remove-buckets SWITCH [GROUP] remove buckets from GROUP</span><br><span class="line">  dump-group-features SWITCH  print group features</span><br><span class="line">  dump-groups SWITCH [GROUP]  print group description</span><br><span class="line">  dump-group-stats SWITCH [GROUP]  print group statistics</span><br><span class="line">  queue-get-config SWITCH PORT  print queue information for port</span><br><span class="line">  add-meter SWITCH METER      add meter described by METER</span><br><span class="line">  mod-meter SWITCH METER      modify specific METER</span><br><span class="line">  del-meter SWITCH METER      delete METER</span><br><span class="line">  del-meters SWITCH           delete all meters</span><br><span class="line">  dump-meter SWITCH METER     print METER configuration</span><br><span class="line">  dump-meters SWITCH          print all meter configuration</span><br><span class="line">  meter-stats SWITCH [METER]  print meter statistics</span><br><span class="line">  meter-features SWITCH       print meter features</span><br><span class="line">  add-tlv-map SWITCH MAP      add TLV option MAPpings</span><br><span class="line">  del-tlv-map SWITCH [MAP] delete TLV option MAPpings</span><br><span class="line">  dump-tlv-map SWITCH      print TLV option mappings</span><br><span class="line"></span><br><span class="line">For OpenFlow switches and controllers:</span><br><span class="line">  probe TARGET                probe whether TARGET is up</span><br><span class="line">  ping TARGET [N]             latency of N-byte echos</span><br><span class="line">  benchmark TARGET N COUNT    bandwidth of COUNT N-byte echos</span><br><span class="line">SWITCH or TARGET is an active OpenFlow connection method.</span><br><span class="line"></span><br><span class="line">Other commands:</span><br><span class="line">  ofp-parse FILE              print messages read from FILE</span><br><span class="line">  ofp-parse-pcap PCAP         print OpenFlow read from PCAP</span><br><span class="line"></span><br><span class="line">Active OpenFlow connection methods:</span><br><span class="line">  tcp:IP[:PORT]           PORT (default: 6653) at remote IP</span><br><span class="line">  ssl:IP[:PORT]           SSL PORT (default: 6653) at remote IP</span><br><span class="line">  unix:FILE               Unix domain socket named FILE</span><br><span class="line">PKI configuration (required to use SSL):</span><br><span class="line">  -p, --private-key=FILE  file with private key</span><br><span class="line">  -c, --certificate=FILE  file with certificate for private key</span><br><span class="line">  -C, --ca-cert=FILE      file with peer CA certificate</span><br><span class="line"></span><br><span class="line">Daemon options:</span><br><span class="line">  --detach                run in background as daemon</span><br><span class="line">  --no-chdir              do not chdir to &#x27;/&#x27;</span><br><span class="line">  --pidfile[=FILE]        create pidfile (default: /var/run/openvswitch/ovs-ofctl.pid)</span><br><span class="line">  --overwrite-pidfile     with --pidfile, start even if already running</span><br><span class="line"></span><br><span class="line">OpenFlow version options:</span><br><span class="line">  -V, --version           display version information</span><br><span class="line">  -O, --protocols         set allowed OpenFlow versions</span><br><span class="line">                          (default: OpenFlow10, OpenFlow11, OpenFlow12, OpenFlow13)</span><br><span class="line"></span><br><span class="line">Logging options:</span><br><span class="line">  -vSPEC, --verbose=SPEC   set logging levels</span><br><span class="line">  -v, --verbose            set maximum verbosity level</span><br><span class="line">  --log-file[=FILE]        enable logging to specified FILE</span><br><span class="line">                           (default: /var/log/openvswitch/ovs-ofctl.log)</span><br><span class="line">  --syslog-method=(libc|unix:file|udp:ip:port)</span><br><span class="line">                           specify how to send messages to syslog daemon</span><br><span class="line">  --syslog-target=HOST:PORT  also send syslog msgs to HOST:PORT via UDP</span><br><span class="line"></span><br><span class="line">Other options:</span><br><span class="line">  --strict                    use strict match for flow commands</span><br><span class="line">  --readd                     replace flows that haven&#x27;t changed</span><br><span class="line">  -F, --flow-format=FORMAT    force particular flow format</span><br><span class="line">  -P, --packet-in-format=FRMT force particular packet in format</span><br><span class="line">  -m, --more                  be more verbose printing OpenFlow</span><br><span class="line">  --timestamp                 (monitor, snoop) print timestamps</span><br><span class="line">  -t, --timeout=SECS          give up after SECS seconds</span><br><span class="line">  --sort[=field]              sort in ascending order</span><br><span class="line">  --rsort[=field]             sort in descending order</span><br><span class="line">  --unixctl=SOCKET            set control socket name</span><br><span class="line">  -h, --help                  display this help message</span><br><span class="line">  -V, --version               display version information</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="流表组成"><a href="#流表组成" class="headerlink" title="流表组成"></a>流表组成</h1><p>每条流表规则由一些列字段组成，可以分为**<code>基础字段</code><strong>、</strong><code>匹配字段</code><strong>和</strong><code>动作字段</code>**三部分。 在打印流表时，在流表中还存在一些显示字段，如<code>duration</code>,<code>idle_age</code>等，此处把这些字段也暂时归之于基础字段之中.</p>
<h3 id="流表组成部分字段说明"><a href="#流表组成部分字段说明" class="headerlink" title="流表组成部分字段说明"></a>流表组成部分字段说明</h3><h4 id="基础字段："><a href="#基础字段：" class="headerlink" title="基础字段："></a>基础字段：</h4><ul>
<li><code>cookie=value</code> 流表标识字段，cookie字段有两种书写方式：<code>cookie=value</code>和<code>cookie=value/mask</code>。<code>mask</code>中对应位为1时cookie中值相应的位须严格匹配，为0时cookie中值对应的位通配，当<code>mask</code>为-1时，必须严格匹配cookie值。</li>
<li><code>duration=value</code> 流表生效时间，标识流表从下发到现在所持续的时间</li>
<li><code>table=tableid</code> 流表所属表项，标识流表所属的表，默认为0</li>
<li><code>priority=priority</code> 标识流表的优先级，范围为0-65535，值越大，优先级越高</li>
<li><code>n_packets</code> 标识流表匹配包数</li>
<li><code>n_bytes</code> 标识流表匹配字节数</li>
<li><code>idle_timeout=sec</code> 流表空闲超时时间，流表会在空闲时间达到给定的时间时被删除。设置为0（默认值）时，流表不会因空闲时间被删除。</li>
<li><code>hard_timeout=sec</code> 流表可存在的时间。设置此值后，流表会在到达给定时间后被删除。</li>
<li><code>idle_age=sec</code> 流表空闲时间</li>
<li><code>hard_age=sec</code> 流表存在时间。此字段与<code>duration</code>字段的区别在当流表被修改后，会重新设置<code>hard_timer</code>但是不会重置<code>duration</code></li>
<li><code>ip_frag=frag_type</code> 当<code>dl_type</code>指定为IP或者IPv6，<code>frag_type</code>指定匹配的IP分片包或者非分片包的匹配 <code>frag_type</code>支持的值为： <code>no</code>: 仅匹配非分片报文 <code>yes</code>：匹配所有分片报文 <code>first</code>：仅匹配<code>offset</code>为0的分片报文 <code>later</code>： 仅匹配<code>offset</code>非0的分片报文 <code>not_later</code>：匹配非分片报文和offset为0的分片报文</li>
</ul>
<h4 id="匹配字段"><a href="#匹配字段" class="headerlink" title="匹配字段"></a>匹配字段</h4><ul>
<li><code>in_port=port</code> 标识匹配接收数据包的端口号</li>
<li><code>dl_type=ethertype</code> 匹配数据包的二层协议类型，IP数据包为<code>0x0800</code>，IPv6数据包为<code>0x86dd</code>，ARP数据包为<code>0x0806</code></li>
<li><code>dl_src=xx:xx:xx:xx:xx:xx</code></li>
<li><code>dl_dst=xx:xx:xx:xx:xx:xx</code> 匹配指定的链路层源或者目的MAC地址</li>
<li><code>dl_src=xx:xx:xx:xx:xx:xx/xx:xx:xx:xx:xx:xx</code></li>
<li><code>dl_dst=xx:xx:xx:xx:xx:xx/xx:xx:xx:xx:xx:xx</code> 匹配指定的链路层MAC地址，MAC地址格式为<code>ADDR/MASK</code>，当<code>MASK</code>值为<code>01:00:00:00:00:00</code>时，仅匹配多播位。当<code>dl_dst=01:00:00:00:00:00/01:00:00:00:00:00</code>时，匹配所有的组播报文和广播报文。<code>dl_dst=00:00:00:00:00:00/01:00:00:00:00:00</code>匹配所有的单播报文。</li>
<li><code>nw_src=ip[/mask]</code></li>
<li><code>nw_dst=ip[/mask]</code> 当<code>dl_type=0x0800</code>或指定<code>ip</code>时，匹配数据包的源、目的IP地址 当<code>dl_type=0x0806</code>或指定<code>arp</code>时，匹配ARP数据包的<code>ar_spa</code>或者<code>ar_tpa</code>字段</li>
<li><code>dl_vlan=vlan</code> 匹配802.1Q类型（即vlan）数据包</li>
<li><code>nw_proto=proto</code> 匹配数据包协议类型。当<code>dl_type=0x0800</code>时，匹配IP协议族的协议，例如<code>tcp</code>，<code>udp</code>，<code>icmp</code>等</li>
<li><code>nw_tos=tos</code> 匹配<code>IP Tos/DSCP</code>或者IPv6的<code>tos</code>字段，值为<code>0-255</code></li>
<li><code>nw_ecn=ecn</code> 匹配IP或者IPv6的<code>ecn</code>字段，值为<code>0~3</code></li>
<li><code>nw_ttl=ttl</code> 匹配TTL值</li>
<li><code>tp_src=port</code></li>
<li><code>tp_dst=port</code> 若指定了<code>udp</code>或者<code>tcp</code>协议，则匹配udp/tcp的端口号</li>
<li><code>icmp_type=type</code></li>
<li><code>icmp_code=code</code> 若指定了<code>icmp</code>或者<code>icmpv6</code>协议，则匹配对应的icmp 类型或者code字段</li>
<li><code>arp_sha=xx:xx:xx:xx:xx:xx</code></li>
<li><code>arp_tha=xx:xx:xx:xx:xx:xx</code> 当设置<code>dl_type</code>为<code>ARP</code>或者<code>RARP</code>，则<code>arp_sha</code>和<code>arp_tha</code>匹配数据包的源、目的MAC地址</li>
</ul>
<h4 id="动作字段"><a href="#动作字段" class="headerlink" title="动作字段"></a>动作字段</h4><ul>
<li><code>output:port</code> 将数据包从<code>port</code>接口发送</li>
<li><code>enqueue:port:queue</code> 将数据包入队到指定端口的指定队列里</li>
<li><code>normal</code> 将数据包按照设备上的正常L2/L3层处理方式进行处理</li>
<li><code>flood</code> 将数据包发送到交换机上除接收接口和禁止flood的接口外的所有接口</li>
<li><code>all</code> 将数据包发送到除接收接口外的所有接口</li>
<li><code>controller(key=value…)</code> 将数据包作为<code>PACKET IN</code>消息发送到OpenFlow控制器。 支持的键值对： <code>max_len=nbytes</code>：限制发送到控制器的数据包长度字节数，默认情况是发送整个数据包；<code>reason=reason</code>：在<code>PACKET IN</code>消息中指明发送消息的原因，支持的<code>reason</code>为<code>action</code>(default)，<code>no_match</code>和<code>invalid_ttl</code>; <code>id=controller-id</code>：指明控制器ID</li>
<li><code>in_port</code> 将数据包从接收的接口发送出去</li>
<li><code>drop</code> 丢弃数据包</li>
<li><code>mod_vlan_vid:vlan_vid</code> 修改数据包的vlan id</li>
<li><code>mod_vlan_pcp:vlan_pcp</code> 修改数据包的vlan priority</li>
<li><code>strip_vlan</code> 如果数据包中存在vlan tag，则剥离vlan tag</li>
<li><code>push_vlan:ethertype</code> 为数据包添加新的vlan tag</li>
<li><code>mod_dl_src:mac</code> 设置数据包的源MAC地址</li>
<li><code>mod_dl_dst:mac</code> 设置数据包的目的MAC地址</li>
<li><code>mod_nw_src:ip</code> 设置数据包的源IP地址</li>
<li><code>mod_nw_dsp:ip</code> 设置数据包的目的IP地址</li>
<li><code>mod_tp_src:port</code> 设置TCP或者UDP的源端口</li>
<li><code>mod_tp_dst:port</code> 设置TCP或UDP的目的端口</li>
</ul>
<h2 id="下发流表"><a href="#下发流表" class="headerlink" title="下发流表"></a>下发流表</h2><h3 id="查询对应的网口序号"><a href="#查询对应的网口序号" class="headerlink" title="查询对应的网口序号"></a>查询对应的网口序号</h3><h4 id="对应网口名称已知"><a href="#对应网口名称已知" class="headerlink" title="对应网口名称已知"></a>对应网口名称已知</h4><p>如果明确的知道对应网口的名称，如<code>vnet1</code>，可以通过如下方式查询其对应的<code>OpenFlow</code>接口序号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ ovs-vsctl get interface vnet1 ofport</span><br></pre></td></tr></table></figure>

<h4 id="对应网口名称未知"><a href="#对应网口名称未知" class="headerlink" title="对应网口名称未知"></a>对应网口名称未知</h4><p>如果不知道对应网口的名称，但是知道其对应的MAC地址，则可以通过如下命令查找对应的网口序号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ ovs-ofctl show ovsBusiness </span><br><span class="line">OFPT_FEATURES_REPLY (xid=0x2): dpid:000090e2ba0115e4</span><br><span class="line">n_tables:254, n_buffers:256</span><br><span class="line">capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS ARP_MATCH_IP</span><br><span class="line">actions: output enqueue set_vlan_vid set_vlan_pcp strip_vlan mod_dl_src mod_dl_dst mod_nw_src mod_nw_dst mod_nw_tos mod_tp_src mod_tp_dst</span><br><span class="line"> 1(vnet1): addr:fe:ea:4a:e6:01:db</span><br><span class="line">     config:     0</span><br><span class="line">     state:      0</span><br><span class="line">     current:    10MB-FD COPPER</span><br><span class="line">     speed: 10 Mbps now, 0 Mbps max</span><br><span class="line"> 2(vnet2): addr:fe:ea:4a:e6:01:dc</span><br><span class="line">     config:     0</span><br><span class="line">     state:      0</span><br><span class="line">     current:    10MB-FD COPPER</span><br><span class="line">     speed: 10 Mbps now, 0 Mbps max</span><br><span class="line"> 3(vnet3): addr:fe:ea:4a:e6:01:5b</span><br><span class="line">     config:     0</span><br><span class="line">     state:      0</span><br><span class="line">     current:    10MB-FD COPPER</span><br><span class="line">     speed: 10 Mbps now, 0 Mbps max</span><br><span class="line"> 4(vnet4): addr:fe:ea:4a:e6:01:5c</span><br><span class="line">     config:     0</span><br><span class="line">     state:      0</span><br><span class="line">     current:    10MB-FD COPPER</span><br><span class="line">     speed: 10 Mbps now, 0 Mbps max</span><br><span class="line"> LOCAL(ovsBusiness): addr:90:e2:ba:01:15:e4</span><br><span class="line">     config:     0</span><br><span class="line">     state:      0</span><br><span class="line">     speed: 0 Mbps now, 0 Mbps max</span><br><span class="line">OFPT_GET_CONFIG_REPLY (xid=0x4): frags=normal miss_send_len=0</span><br></pre></td></tr></table></figure>

<p>可以看到接口对应的MAC地址及接口对应的OpenFlow接口序号。</p>
<h3 id="下发流表示例"><a href="#下发流表示例" class="headerlink" title="下发流表示例"></a>下发流表示例</h3><p>如上面<code>ovs-ofctl show ovsBusiness</code>命令所显示的接口信息，<code>vnet1</code>和<code>vnet2</code>对应OVS的入口和出口，分别连接着客户端和服务端，<code>vnet3</code>和<code>vnet4</code>对应虚拟机的入口和出口，下面就以以上四个网口来下发流表：</p>
<h4 id="根据接收端口"><a href="#根据接收端口" class="headerlink" title="根据接收端口"></a>根据接收端口</h4><h5 id="从一个接口接收从其他接口发送"><a href="#从一个接口接收从其他接口发送" class="headerlink" title="从一个接口接收从其他接口发送"></a>从一个接口接收从其他接口发送</h5><p>从<code>vnet1</code>接收的数据包经过虚拟机后从<code>vnet2</code>发送出去</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端访问服务端</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,in_port=1 actions=output:3&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,in_port=4 actions=output:2&quot;</span></span><br><span class="line"><span class="comment"># 服务端应答客户端请求</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,in_port=2 actions=output:4&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,in_port=3 actions=output:1&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="将数据包从接收端口发送"><a href="#将数据包从接收端口发送" class="headerlink" title="将数据包从接收端口发送"></a>将数据包从接收端口发送</h5><p>将从<code>vnet1</code>接收到的数据包从<code>vnet1</code>发送出去</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,in_port=1 actions=in_port&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="根据接收端口及IP信息"><a href="#根据接收端口及IP信息" class="headerlink" title="根据接收端口及IP信息"></a>根据接收端口及IP信息</h4><p>客户端IP地址为：1.1.1.12， 服务端IP地址为1.1.1.13</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端访问服务端</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,ip,in_port=1,nw_src=1.1.1.12,nw_dst=1.1.1.13 actions=output:3&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,ip,in_port=4,nw_src=1.1.1.12,nw_dst=1.1.1.13 actions=output:2&quot;</span></span><br><span class="line"><span class="comment"># 服务端相应客户端请求</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,ip,in_port=2,nw_src=1.1.1.13,nw_dst=1.1.1.12 actions=output:4&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,ip,in_port=3,nw_src=1.1.1.13,nw_dst=1.1.1.12 actions=output:1&quot;</span></span><br><span class="line"><span class="comment"># 放通arp数据包</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,arp,in_port=1 actions=output:3&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,arp,in_port=4 actions=output:2&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,arp,in_port=2 actions=output:4&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,arp,in_port=3 actions=output:1&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="根据接收端口、VLAN及IP信息"><a href="#根据接收端口、VLAN及IP信息" class="headerlink" title="根据接收端口、VLAN及IP信息"></a>根据接收端口、VLAN及IP信息</h4><p>在将数据包发给虚拟机之前去vlan tag，然后数据包发送出OVS时添加vlan tag</p>
<p>客户端IP地址为：1.1.1.12， 服务端IP地址为1.1.1.13，vlan为10</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端访问服务端</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,ip,in_port=1,dl_vlan=10,nw_src=1.1.1.12,nw_dst=1.1.1.13 actions=strip_vlan,output:3&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,ip,in_port=4,nw_src=1.1.1.12,nw_dst=1.1.1.13 actions=mod_vlan_vid:10,output:2&quot;</span></span><br><span class="line"><span class="comment"># 服务端相应客户端请求</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,ip,in_port=2,dl_vlan=10,nw_src=1.1.1.13,nw_dst=1.1.1.12 actions=strip_vlan,output:4&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,ip,in_port=3,nw_src=1.1.1.13,nw_dst=1.1.1.12 actions=mod_vlan_vid:10,output:1&quot;</span></span><br><span class="line"><span class="comment"># 放通arp数据包</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,arp,in_port=1 actions=output:3&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,arp,in_port=4 actions=output:2&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,arp,in_port=2 actions=output:4&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,arp,in_port=3 actions=output:1&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="根据接收端口及MAC地址信息"><a href="#根据接收端口及MAC地址信息" class="headerlink" title="根据接收端口及MAC地址信息"></a>根据接收端口及MAC地址信息</h4><p>客户端IP地址为：1.1.1.12， 服务端IP地址为1.1.1.13 客户端MAC地址为：01:01:01:01:01:02，服务端MAC地址为：01:01:01:01:01:01</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端访问服务端</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,ip,in_port=1,dl_dst=01:01:01:01:01:01 actions=strip_vlan,output:3&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,ip,in_port=4,dl_dst=01:01:01:01:01:01 actions=mod_vlan_vid:10,output:2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端相应客户端请求</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,ip,in_port=2,dl_dst=01:01:01:01:01:02 actions=output:4&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,ip,in_port=3,dl_dst=01:01:01:01:01:02 actions=output:1&quot;</span></span><br><span class="line"><span class="comment"># 放通arp数据包</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,arp,in_port=1 actions=output:3&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,arp,in_port=4 actions=output:2&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,arp,in_port=2 actions=output:4&quot;</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;cookie=0,priority=40001,arp,in_port=3 actions=output:1&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="设置NORMAL转发"><a href="#设置NORMAL转发" class="headerlink" title="设置NORMAL转发"></a>设置NORMAL转发</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovs-ofctl add-flows <span class="string">&quot;priority=0 actions=NORMAL&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="其他形式的流表"><a href="#其他形式的流表" class="headerlink" title="其他形式的流表"></a>其他形式的流表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 丢弃所有port 1上接收的数据包</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;in_port=2 actions=drop&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 丢弃所有port 1上接收的广播报文(此处网上给出的是dl_src，我怎么感觉是dl_dst?)</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;priority=40001,dl_dst=01:00:00:00:00:00/01:00:00:00:00:00 actions=drop&quot;</span></span><br><span class="line"><span class="comment"># 丢弃所有STP协议的广播数据包</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;priority=40001,dl_dst=01:80:c2:00:00:00/ff:ff:ff:ff:ff:f0 actions=drop&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改从port 1上接收的数据包的源IP地址为&quot;192.168.13.1&quot;，并从port 2口发送</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;priority=40001,in_port=1 actions=mod_nw_src:192.168.13.1,output:2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有port 1接收的ICMP报文发送到port 2上去</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;priority=40001,dl_type=0x0800,in_port=1,nw_proto=1 actions=output:2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有port 1接收的TCP目的端口为80的报文发送到port 2口</span></span><br><span class="line">ovs-ofctl add-flow ovsBusiness <span class="string">&quot;priority=4001,dl_type=0x0800,in_port=1,nw_proto=6,tp_dst=80 actions=output:2&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="删除流表"><a href="#删除流表" class="headerlink" title="删除流表"></a>删除流表</h2><h3 id="删除全部流表"><a href="#删除全部流表" class="headerlink" title="删除全部流表"></a>删除全部流表</h3><p>删除全部流表的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovs-ofctl del-flows ovsBusiness</span><br></pre></td></tr></table></figure>

<h3 id="按匹配条件删除流表"><a href="#按匹配条件删除流表" class="headerlink" title="按匹配条件删除流表"></a>按匹配条件删除流表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除&quot;in_port=1&quot;的流表</span></span><br><span class="line">ovs-ofctl del-flows ovsBusiness <span class="string">&quot;in_port=1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除匹配条件为&quot;priority=40001&quot;的流表</span></span><br><span class="line">ovs-ofctl del-flows ovsBusiness <span class="string">&quot;priority=40001&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除匹配条件为&quot;priority=4001,ip,in_port=1,nw_src=1.1.1.12&quot;的流表</span></span><br><span class="line">ovs-ofctl del-flows ovsBusiness <span class="string">&quot;priority=4001,ip,in_port=1,nw_src=1.1.1.12&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除匹配条件为&quot;priority=4001,ip,in_port=1,nw_src=1.1.1.12 action=output:2&quot;的流表</span></span><br><span class="line">ovs-ofctl del-flows ovsBusiness <span class="string">&quot;priority=4001,ip,in_port=1,nw_src=1.1.1.12 action=output:2&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="查看流表"><a href="#查看流表" class="headerlink" title="查看流表"></a>查看流表</h2><h3 id="查看配置的所有流表信息"><a href="#查看配置的所有流表信息" class="headerlink" title="查看配置的所有流表信息"></a>查看配置的所有流表信息</h3><p>查看流表命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovs-ofctl dump-flows ovsBusiness</span><br></pre></td></tr></table></figure>

<p>上述命令可以查看现在OVS桥上配置的流表</p>
<h3 id="查看现在生效的流表信息"><a href="#查看现在生效的流表信息" class="headerlink" title="查看现在生效的流表信息"></a>查看现在生效的流表信息</h3><p>查看现在生效的流表命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看默认的datapath类型的OVS桥的生效流表</span></span><br><span class="line">ovs-appctl dpctl/dump-flows system@ovs-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看datapath类型为netdev的OVS桥的生效流表</span></span><br><span class="line">ovs-appctl dpctl/dump-flows netdev@ovs-netdev</span><br></pre></td></tr></table></figure>

<p>上述两条命令显示结果中的<code>in_port(port_num)</code>和<code>actions:port_num,port_num</code>值可能与使用<code>ovs-ofctl</code>命令查看到的不一致，这是因为使用<code>ovs-appctl</code>命令显示的端口号是所有<code>datapath</code>类型的桥下接口的编号，而<code>ovs-ofctl</code>命令下的端口号是此OVS桥下的端口号。 查看完整的<code>datapath</code>类型的接口编号命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前OVS中的datapath类型</span></span><br><span class="line">ovs-appctl dpctl/dump-dps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看默认datapath类型的接口编号</span></span><br><span class="line">ovs-appctl dpctl/show system@ovs-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看datapath=netdev类型的接口编号</span></span><br><span class="line">ovs-appctl dpctl/show netdev@ovs-netdev</span><br></pre></td></tr></table></figure>

<h3 id="查看当前网桥的所有流表"><a href="#查看当前网桥的所有流表" class="headerlink" title="查看当前网桥的所有流表"></a>查看当前网桥的所有流表</h3><p>每个网桥默认情况下会配置有默认流表，查看所有的流表信息的命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovs-appctl bridge/dump-flows ovsBusiness</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在配置流表时，如果需要对数据包进行修改，则对数据包的修改动作应该在<code>output</code>动作之前完成，否则会不生效（因为数据包已经发送出去）.</p>
<p>RYU文档</p>
<p><a target="_blank" rel="noopener" href="https://ryu.readthedocs.io/en/latest/index.html">https://ryu.readthedocs.io/en/latest/index.html</a></p>
<p>RYU REST API</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34415266/article/details/92795959">https://blog.csdn.net/qq_34415266/article/details/92795959</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/ovs%E4%BD%BF%E7%94%A8/" data-id="ckmn1li25000hn8a8dxfo00mf" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-小论文Idea" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/%E5%B0%8F%E8%AE%BA%E6%96%87Idea/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.748Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="小论文Idea"><a href="#小论文Idea" class="headerlink" title="小论文Idea"></a>小论文Idea</h1><p> 可以表示为一个有向图                                ，  表示所有交换机构成的节点集，  表示交换机之间的有向的通信链路构成的边集。</p>
<p>控制平面采用加权最短路径算法得到当前边缘节点至目标节点间不包含重叠路径的前K条路径，再根据前K路径的权值和的比例调整具有相同目的节点的不同流在链路上的分配情况，使这K条路径上数据包的发送速率大致与权值和比例一致。</p>
<p>当路径权值相等时，选择</p>
<p>可选路径的链路权值和的比例作为可选路径上具有相同目的leaf节点的不同流的分配比例，具体而言，每当网络中进入一条新流时，计算此时多条可选路径上的分配比例和链路利用率（假定交换机之间的链路带宽一致），选择其中一条路径，使链路利用率之比与分配比例的差值最小，从而使资源分配更加均衡。</p>
<p>通过【】节描述的方法，向网络中的所有交换机发起测量请求，采集全网的网络状态参数，并将收集到的数据作为【】节描述的DDPG模型的输入，用于计算当前网络条件下各条链路的权值，权值越大说明当前链路的剩余负载能力越大。根据链路权值，控制平面使用Dijkstra算法计算得到当前leaf节点至目的leaf节点之间的加权最短路径。为了避免多条路由路径共用一条物理路径造成链路瓶颈，控制平面将上一步得到的路径从全网路径中删除，在子图中继续执行Dijkstra算法得到另一条最短路径，直至满足设定的多路径条数或网络中不存在更多的路径。计算得到的不重叠多条路径的权值和，将权值和的比例作为多条路径上具有相同目的leaf节点的不同流的分配比例。</p>
<p>交换机使用数据包的五元组</p>
<p>区分不同的数据流，每当一条新流进入网络的边缘交换机时，控制平面采集一次全网的网络状态参数，并计算网络中各链路的权值。根据链路权值，控制平面采用加权最短路径算法得到当前边缘节点至目标节点间不包含重叠路径的前K条路径，再根据前K路径的权值和的比例调整具有相同目的节点的不同流在链路上的分配情况，使这K条路径上数据包的发送速率大致与权值和比例一致。最终的的输出是每条流在在网络中的某条链路上，依次经过的各个交换机的转发端口。</p>
<p>数据中心两个节点之间路径相对固定且少，同时东西向流量非常大，存在大象流和老鼠流并存的情况，如何在这种情况下确定路径？</p>
<p>首先，当一个新的流到达一个交换机时，交换机将流的第一个包转发给域控制器，并请求转发路径。然后，域控制器根据从控制器获得的最新信息更新当前网络状态，利用算法2中提出的强化学习，根据流的QoS要求选择可行路径，并沿选择的路径修改交换机的转发表。此外，如果域控制器意识到目标交换机不属于它的子网，则第一个包也将被发送到超级控制器。</p>
<p>分段路由（SR）域</p>
<p>SR域是参与SR协议的节点或网络设备的集合。在SR域内，节点可以执行入口，传输或出口过程。通常，在SR网络中，源节点和端点节点位于SR域之外，而它们之间的路径则穿越SR域。</p>
<p>分支节点段路由（SR）路径</p>
<p>该SR路径是一个SR入口节点连接到SR出口节点的网络段的有序列表。但是，网段不是特定于SR路径的，因此许多SR路径可以共享一个网段。虽然SR路径可以遵循从入口到出口的最低成本路径，但它也可以遵循另一条路径以用于流量工程和网络服务管理。SR路径可以由多个段类型组成，这些段类型由段标识符（我们称为SID）标识。SR段类型包括邻接，前缀，任播和绑定段。尽管路径可以由这些段类型中的一种或多种组成，但邻接段和前缀段是最常见的类型。</p>
<p>分段路由（SR）控制平面</p>
<p>SR控制平面提供了操作的“大脑”，创建和管理的SR路径，其由路径计算功能进行驻留在入口路由器上或由集中路径计算元件（PCE）。如果使用PCE，则它通常位于路径计算元素控制器上。入口路由器成为路径计算客户端（PCC），并且路径计算元素协议（PCEP）用于在它们之间进行通信。</p>
<p>SR路径可以遵循到达出口节点的成本最低的路径，或者约束条件可以迫使它们遵循由入口节点指定的另一条路径。PCE可以设计SR路径来满足任何数量的约束（例如，最小链路带宽，最大路径等待时间）。</p>
<p>它是如何工作的</p>
<p>当数据包到达SR入口节点时，入口节点将数据包置于策略之下。该策略包括匹配条件和操作。如果数据包满足匹配条件，则SR入口节点将数据包分配给SR路径。SR入口通过在数据包的SR标头（SRH）中对关联的段列表进行编码来实现此目的，或者在SR-MPLS的情况下，它会将段列表编码在MPLS标签栈中并将其放置在MPLS标签标头中。然后，它将数据包转发到下游。传输节点处理标头，将数据包从当前段转发到下一个段。这样，数据包将通过SR域并穿越SR路径到达出口节点。</p>
<p>SR的优点</p>
<p>因为SR入口节点在SR头中编码路径信息，所以不需要中转节点维护有关它们支持的每个路径的信息。仅需要它们来处理在数据包头中找到的数据段标识符，将数据包从当前数据段转发到下一个数据段。</p>
<p>这是SR的主要优点。因为不需要中转节点来维护路径信息，所以消除了与维护该信息相关的开销。结果，简化了路由协议，改善了缩放特性，并且网络操作的问题更少。</p>
<p>强化学习结合可编程数据平面做路由算法， 可编程数据平面利用int采集信息，表征链路特性，通过控制面制造训练集，利用图神经网络表征网络拓扑</p>
<p>刘辰屹徐明伟, 和Liu Chenyi Xu Mingwei. 《基于机器学习的智能路由算法综述》. 计算机研究与发展 57, 期 4 (2020年4月1日): 671. <a target="_blank" rel="noopener" href="https://doi.org/10.7544/issn1000-1239.2020.20190866">https://doi.org/10.7544/issn1000-1239.2020.20190866</a>.</p>
<p>李倩, 张凯, 魏浩然和张娇. 《基于P4和机器学习的路由选择方案探讨》. 邮电设计技术, 期 12 (2018年): 7–11.</p>
<p>解析器：解析器的功能是将数据包中的报头提取出来，其解析逻辑是可重配置的，网络管理员可以在P4程序中自定义报头结构和解析流程。</p>
<p>多级流水线：提取出来的报头经过以流水线形式组织起来的多级匹配动作表，表的个数、匹配域和动作可以由P4程序定义，从而实现自定义数据平面数据包处理逻辑的目的。此外，报头在多个表之间传递时可以携带包含交换机提供的内部元数据在内的额外信息，内部元数据包含数据包进入交换机的时间戳、队列深度、排队时延等交换机状态信息。</p>
<p>缓存区：缓存区是不可编程的，主要用于缓存载荷和已解析的头部，由多个队列和队列管理组成，</p>
<p>路由优化问题：保证QoS，最小化延迟和抖动，最大化带宽。</p>
<p>数据中心网络 胖树结构</p>
<p>使用int采集数据 队列拥塞 排队时长</p>
<p>使用强化学习ddpg得到链路权值</p>
<p>根据链路权值采用多路径传输算法计算路由 最小化网络中所有链路的最大负载</p>
<p>idea</p>
<p>基于深度强化学习的下一代SDN数据中心网络路由机制研究</p>
<p>数据中心网络的leaf-spine结构，</p>
<p>NG-SDN</p>
<p>VLB 负载均衡算法根据边容量大小进行按比例分配流量，没有考虑交换机的处理能力。</p>
<p>Valiant L G. A scheme for fast parallel communication[J]. SIAM journal on computing, 1982, 11(2): 350-361.</p>
<p>当前路由算法使用最短路径和最佳路径，备用链路使用率不足。</p>
<ol>
<li>NG-SDN环境下的网络参数获取办法：控制器向交换机注入一个自定义格式的探测包，交换机收到来自控制器的探测包后，向控制器上传此时的内部数据。</li>
<li>强化学习方法进行确定链路对于流的权值：利用int采集数据，然后使用强化学习DDPG获得链路权值，强化学习的奖励设置为 延迟、抖动、丢包率的加权和，相比于直接输出转发路径，输出链路权值更佳，再采用其他方法进行路由选择 </li>
<li>多路径路由，采用改进的ECMP和KSP、RMTP，每条路径的cost不同，每条路径的cost等于强化学习得到的链路权值的和。根据链路权值设置不重复的第一路径和第二路径，根据权值比例分配不同路径的流量比例。流量的大部分走第一路径，小部分走第二路径。</li>
</ol>
<p>ECMP是指，到达一个目的地有多条相同度量值的路由项（路由路径），这样就可以使用不超过3条这样的路径来转发流量。ECMP最大的特点是实现了等值情况下，多路径负载均衡和链路备份的目的，在静态路由和OSPF中基本上都支持ECMP功能。</p>
<p>但是实际情况是，各路径的带宽、时延和可靠性等不一样，把Cost认可成一样，不能很好地利用带宽，尤其在路径间差异大时，效果会非常不理想。例如，路由器两个出口，两路径，一个带宽是100M，一个是2M，如果部署是ECMP，则网络总带宽只能达到4M的利用率。（在RFC2991中讨论了一般的多路径路由。每一封包多路径路由的负载平衡通常不适用因为大辐变化的延迟、数据包重新排序，以及可以破坏许多互联网协定运作的最大传输单元（MTU）在网络流量的差异，最特别是传输控制协议（TCP）和path MTU discovery。）另外一种情况下等价多路径路由也不能提供真正的最佳路径路由的优点，例如，如果多个最佳的next-hop的路径到目的地重新汇聚到一个单一的低带宽的路径（一种常见的情形）下游，它只会增加到该目的地流量路径的复杂性，而无法提高带宽的能力。</p>
<p>有篇专利可供参考：<a target="_blank" rel="noopener" href="http://www.google.com/patents/CN103607358A?cl=zh">http://www.google.com/patents/CN103607358A?cl=zh</a></p>
<p>我们可以看到，“等价路径的计算”妨碍了这个算法的使用。</p>
<p>2）WCMP（Weight-Cost Multi-Path Routing，加权多路径路由）。</p>
<p>WCMP能够非常灵活地按照比例在链路上传递流量，ECMP是它的特例。IGRP、EIGRP和部分静态路由也支持WCMP，但因为IGRP和EIGRP为非标准私有协议（Cisco的私有协议），不适宜扩展，因此只能采用静态路由，在中小网络部署。</p>
<p>貌似也不需要考虑。</p>
<p>3）MPA、DSPA、CRA、MDVA、MPDA/QMPDA、MPTAH、MARA、ST、NPMA等算法稍后讲解</p>
<p>关于流量的动态分配，即所谓的负载均衡问题：</p>
<p>1）负载分担方式有3种。</p>
<p>基于流负载分担：路由器根据IP报文的五元组信息（是指源IP地址，源端口，目的IP地址，目的端口，和传输层协议这五个量组成的一个集合。 例如：192.168.1.1 10000 TCP 121.14.88.76 80 就构成了一个五元组）将数据分成不同的流。具有相同五元组信息的IP报文属于同一个流。转发数据时，路由器把不同的数据流根据算法从多个路径上依次发送出去。</p>
<p>基于包负载分担：转发数据时，路由器把数据包从多个路径上依次发送出去。</p>
<p>基于带宽的非平衡负载分担：报文按接口物理带宽进行负载分担(即基于报文的负载分担)。当用户为接口配置了指定的负载带宽后，设备将按用户指定的接口带宽进行负载分担，即根据各接口物理带宽比例关系进行分配。</p>
<p>基于包转发能够做到更精确的负载分担。但是由于路由器要对每一个包进行路由查表与转发操作，所以无法使用快速转发缓存来转发数据，转发效率降低了。另外，Internet应用都是基于流的，如果路由器采用基于包的负载分担，一条流中的数据包会经过不同路径到达目的地，可能会造成接收方的乱序接收，从而影响应用程序的正常运行。</p>
<p>目标：在保证延迟带宽丢包率的基础上具有最大的吞吐量。</p>
<p>文章结构：</p>
<p>引用</p>
<p>相关研究</p>
<p>实验</p>
<p>结语</p>
<p>不同学习率的决策性能</p>
<p>与ECMP、OSPF的性能比较</p>
<p>先写：</p>
<ol>
<li><p>了解强化学习相关概念和知识</p>
</li>
<li><p>阅读期刊《计算机工程与应用》，寻找一般套路。</p>
</li>
<li><p>思维导图确定文章结构，文章结构借鉴zotero中的阅读的论文。</p>
</li>
<li><p>大概填充文章结构。</p>
</li>
<li><p>向吴老师提写小论文的要求，用更多时间写小论文。</p>
</li>
<li><p>做实验。</p>
</li>
</ol>
<p>步骤：</p>
<p>计算机工程与应用投稿须知：</p>
<ul>
<li>论文字数不做严格限制，7500字以上为宜。</li>
<li>标题严格控制在20字以内。</li>
<li>第一作者为CCF会员，享受85折版面费优惠。</li>
<li>审稿周期2~3个月。</li>
</ul>
<p>保证QoS的</p>
<p>keyword QoS-aware traffic classification QoS感知</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/%E5%B0%8F%E8%AE%BA%E6%96%87Idea/" data-id="ckmn1lhzo000cn8a8bhby59ni" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-LLDP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/LLDP/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.732Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>控制器向其中一个交换机发送包含交换机id的packet-out消息，触发交换机泛洪LLDP包，把转发端口写入数据包，交换机接收到数据包后把自身id、LLDP包中包含的源id、源端口、接收端口写入packet-in消息发送至控制器</p>
<h2 id="LLDP工作原理"><a href="#LLDP工作原理" class="headerlink" title="LLDP工作原理"></a>LLDP工作原理</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="http://www.h3c.com/cn/d_200805/605853_30003_0.htm">http://www.h3c.com/cn/d_200805/605853_30003_0.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/goodluckwhh/article/details/10948065">https://blog.csdn.net/goodluckwhh/article/details/10948065</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/30e6435b9bee">https://www.jianshu.com/p/30e6435b9bee</a></p>
<p>802.1AB-2005.pdf</p>
<h3 id="LLDP格式"><a href="#LLDP格式" class="headerlink" title="LLDP格式"></a>LLDP格式</h3><p>Ethernet II格式封装的LLDP报文</p>
<img src="LLDP.assets/20090520_766414_image001_605853_30003_0.png" alt="img" style="zoom:150%;" />

<ul>
<li>Destination MAC address：目的MAC地址，为固定的组播MAC地址0x0180-C200-000E。</li>
<li>Source MAC address：源MAC地址，为端口MAC地址或设备桥MAC地址（如果有端口地址则使用端口MAC地址，否则使用设备桥MAC地址）。</li>
<li>Type：报文类型，为0x88CC。</li>
<li>Data：数据，为LLDPDU。</li>
<li>FCS：帧检验序列。</li>
</ul>
<h4 id="LLDPDU"><a href="#LLDPDU" class="headerlink" title="LLDPDU"></a>LLDPDU</h4><p>LLDPDU包中，字节数从1开始，按照放入LLDP帧的次序编号，每个字节中的位从0编号至7，0是最低位（最右侧）。当一个字节内的连续位编码成数字时，最大编号的位是数的最高位（Most significant bit），当连续的字节编码成数字时，较小编号的字节是数的最高位。</p>
<p>LLDPDU就是封装在LLDP报文数据部分的数据单元。在组成LLDPDU之前，设备先将本地信息封装成TLV格式，再由若干个TLV组合成一个LLDPDU封装在LLDP报文的数据部分进行传送。</p>
<p><img src="LLDP.assets/image-20200817172935816.png" alt="image-20200817172935816"></p>
<p>####TLV</p>
<p>TLV(Type Length Value)是组成LLDPDU的单元，每个TLV都代表一个信息。LLDP可以封装的TLV包括基本TLV、802.1组织定义TLV、802.3组织定义TLV和LLDP-MED（Media Endpoint Discovery，媒体终端发现） TLV。</p>
<p>TLV格式：</p>
<p><img src="LLDP.assets/image-20200817170841134.png" alt="image-20200817170841134"></p>
<p>TLV Type定义如下，前四种是每个LLDPDU必须包含的。</p>
<p><img src="LLDP.assets/image-20200817170949526.png" alt="image-20200817170949526"></p>
<p>TLV Length是Value的字节数。</p>
<ul>
<li>Chassis ID</li>
</ul>
<p>该TLV用于通告该LLDPDU发送者的chassis ID。由于有很多方式可用来标识一个chassis，因此在该类TLV中包含一个子类型域用于告诉接收者，发送者的chassis ID采用的是哪一种标识方式。其格式如图所示：</p>
<p><img src="LLDP.assets/image-20200817172109490.png" alt="image-20200817172109490" title="Chassis ID TLV format"></p>
<p>Chassis ID子类型所可能的取值：</p>
<p><img src="LLDP.assets/image-20200817172252242.png" alt="image-20200817172252242"></p>
<ul>
<li>Port ID</li>
</ul>
<p>该TLV用于标识发送该LLDPDU的设备的端口。类似于chassis ID，有很多方式可以标识一个Port，因此该TLV也包含一个子类型域。其格式如下图所示：</p>
<p><img src="LLDP.assets/image-20200817172514059.png" alt="image-20200817172514059"></p>
<p>Port ID子类型所可能的取值：</p>
<p><img src="LLDP.assets/image-20200817172539462.png" alt="image-20200817172539462"></p>
<ul>
<li>Time To Live</li>
</ul>
<p>该TLV用于告诉接收端，它接收到的这些信息的有效期有多长。其格式如图所示：</p>
<p><img src="LLDP.assets/image-20200817172649146.png" alt="image-20200817172649146"></p>
<p>TTL的时间单位是秒，由于只有2个字节长，因而最大有效时间是65536秒。如果在这个时间到期了还没有新的LLDPDU被收到，则该TLV所属的那个LLDPDU携带的信息会被从MIB中删除。如果收到了新的LLDPDU，则：</p>
<ul>
<li><p>如果TTL不为0，则会用新收到的LLDPDU的信息替换MIB库中的相应的信息（即与该LLDPDU的发送者相关的MIB信息，LLDP使用Chassis ID + Port ID来判断是否来自于同一个源，这也是要求这两者保持不变的原因）。</p>
</li>
<li><p>如果TTL为0，则删除相应的MIB库中的信息（即与该LLDPDU的发送者相关的MIB信息）。因此TTL为0的LLDPDU又被称为SHUTDOWN LLDPDU。</p>
</li>
<li><p>End Of LLDPDU</p>
</li>
</ul>
<p>该TLV用于表示LLDPDU的结束，不包含value域，其length为0。</p>
<p><img src="LLDP.assets/image-20200817171658939.png" alt="End Of LLDPDU TLV format" title="End Of LLDPDU TLV format"></p>
<h2 id="OpenFLow处理LLDP"><a href="#OpenFLow处理LLDP" class="headerlink" title="OpenFLow处理LLDP"></a>OpenFLow处理LLDP</h2><p>在OpenFlow中，主要通过OpenFlow控制器完成LLDP处理。OpenFlow交换机不对LLDP帧做任何处理，而是由OpenFlow控制器进行网络拓扑检测。 如下图所示,</p>
<ol>
<li>OpenFlow控制器向OpenFlow交换机2发送Packet-Out消息，以此来发送LLDP帧。</li>
<li>OpenFlow交换机2通过OpenFlow交换机1上连接的网络接口发送包含packet-Out消息中的LLDP帧。</li>
<li>OpenFlow交换机1接收来自openflow交换机2的LLDP帧后，将LLDP帧添加到Packet-In消息中，然后发送给OpenFlow控制器，OpenFlow控制器依据OpenFlow交换机1发来的Packet-In消息中所包含的信息，构建网络拓扑检测的数据库。</li>
</ol>
<img src="LLDP.assets/2458601-77e8ee71ec7f40ea.webp" alt="img"  />

<h2 id="Scapy自定义LLDP数据包"><a href="#Scapy自定义LLDP数据包" class="headerlink" title="Scapy自定义LLDP数据包"></a>Scapy自定义LLDP数据包</h2><p><a target="_blank" rel="noopener" href="https://montcs.bloomu.edu/VM-LAN/LAN04.asn.scapy.html">https://montcs.bloomu.edu/VM-LAN/LAN04.asn.scapy.html</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">chassis = <span class="built_in">bytearray</span>(<span class="number">7</span>)</span><br><span class="line">chassis[<span class="number">0</span>:<span class="number">3</span>] = (<span class="number">0x02</span>,<span class="number">0x06</span>,<span class="number">0x07</span>)</span><br><span class="line">chassis[<span class="number">3</span>:] = <span class="built_in">str</span>.encode(<span class="string">&#x27;fakey&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">sysname = <span class="built_in">bytearray</span>(<span class="number">7</span>)</span><br><span class="line">sysname[<span class="number">0</span>:<span class="number">2</span>] = (<span class="number">0x0a</span>,<span class="number">0x05</span>)</span><br><span class="line">sysname[<span class="number">2</span>:] = <span class="built_in">str</span>.encode(<span class="string">&#x27;Lies!&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">sysdesc = <span class="built_in">bytearray</span>(<span class="number">12</span>)</span><br><span class="line">sysdesc[<span class="number">0</span>:<span class="number">2</span>] = (<span class="number">0x0c</span>,<span class="number">0x0a</span>)</span><br><span class="line">sysdesc[<span class="number">2</span>:] = <span class="built_in">str</span>.encode(<span class="string">&#x27;MS-DOS 1.0&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">portID = <span class="built_in">bytearray</span>( (<span class="number">0x04</span>,<span class="number">0x07</span>,<span class="number">0x03</span>, <span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0xff</span>,<span class="number">0xfe</span>,<span class="number">0xfd</span>) ) <span class="comment"># fake MAC address</span></span><br><span class="line">TTL = <span class="built_in">bytearray</span>( (<span class="number">0x06</span>,<span class="number">0x02</span>, <span class="number">0x00</span>,<span class="number">0x78</span>) )</span><br><span class="line">end = <span class="built_in">bytearray</span>( (<span class="number">0x00</span>, <span class="number">0x00</span>) )</span><br><span class="line">payload = <span class="built_in">bytes</span>( chassis + portID + TTL + sysname + sysdesc + end )</span><br><span class="line">mac_lldp_multicast = <span class="string">&#x27;01:80:c2:00:00:0e&#x27;</span></span><br><span class="line">eth = Ether(src=<span class="string">&#x27;00:01:02:ff:fe:fd&#x27;</span>, dst=mac_lldp_multicast, <span class="built_in">type</span>=<span class="number">0x88cc</span>)</span><br><span class="line">frame = eth / Raw(load=<span class="built_in">bytes</span>(payload)) / Padding(<span class="string">b&#x27;\x00\x00\x00\x00&#x27;</span>)</span><br><span class="line">frame.<span class="built_in">len</span>() <span class="comment"># should be 60, minimum Ethernet frame length</span></span><br><span class="line">frame.show()</span><br><span class="line">sendp(frame)</span><br></pre></td></tr></table></figure>

<p>##数据平面packet-in/out功能</p>
<p>使用注释@controller_header(“packet_in”)和@controller_header(“packet_out”)标注含有额外信息的包头。</p>
<p>运行bmv2时需要指定cpu port：<code>-- --cput-port 255</code>，所有转发至该端口的数据包将会发送至控制平面。</p>
<h2 id="控制平面packet-in-out功能"><a href="#控制平面packet-in-out功能" class="headerlink" title="控制平面packet-in/out功能"></a>控制平面packet-in/out功能</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">def sendPacketToDataPlane():</span><br><span class="line">    pktInRaw &#x3D; send_pkt.getPacktInRaw()</span><br><span class="line">    req &#x3D; p4runtime_pb2.StreamMessageRequest()</span><br><span class="line"></span><br><span class="line">    packet &#x3D; p4runtime_pb2.PacketOut()</span><br><span class="line">    packet.payload &#x3D; pktInRaw</span><br><span class="line">    </span><br><span class="line">    metadata &#x3D; p4runtime_pb2.PacketMetadata()</span><br><span class="line">    metadata.metadata_id&#x3D;1</span><br><span class="line">    metadata.value &#x3D; (1).to_bytes(2,&#39;big&#39;)</span><br><span class="line">    packet.metadata.append(metadata)</span><br><span class="line">    metadata.metadata_id&#x3D;2</span><br><span class="line">    metadata.value &#x3D; (0).to_bytes(2,&#39;big&#39;)</span><br><span class="line">    packet.metadata.append(metadata)</span><br><span class="line"></span><br><span class="line">    req.packet.CopyFrom(packet)</span><br><span class="line"></span><br><span class="line">    # another way to set packet field</span><br><span class="line">    # packet &#x3D; req.packet </span><br><span class="line">    # packet.payload &#x3D; pktInRaw</span><br><span class="line"></span><br><span class="line">    # another way to add metada fields, </span><br><span class="line">    # ref:https:&#x2F;&#x2F;developers.google.com&#x2F;protocol-buffers&#x2F;docs&#x2F;reference&#x2F;python-generated#repeated-fields</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    # metadata &#x3D; req.packet.metadata.add()</span><br><span class="line">    # metadata.metadata_id &#x3D; 1</span><br><span class="line">    # metadata.value &#x3D; (1).to_bytes(2,&#39;big&#39;)</span><br><span class="line">    # metadata &#x3D; req.packet.metadata.add()</span><br><span class="line">    # metadata.metadata_id &#x3D; 2</span><br><span class="line">    # metadata.value &#x3D; (0).to_bytes(2,&#39;big&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sh.client.stream_out_q.put(req)</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>[x] 控制器通过packet-out发送一个lldp包至交换机，在packet-out包头中指定egress-port为端口1，在端口1处抓包。</p>
<h2 id="数据平面解析处理LLDP协议数据包"><a href="#数据平面解析处理LLDP协议数据包" class="headerlink" title="数据平面解析处理LLDP协议数据包"></a>数据平面解析处理LLDP协议数据包</h2><p>解析：</p>
<p>if 数据包来自CPU：</p>
<p>​    解析 packet-out</p>
<p>解析 Ethernet</p>
<p>if 数据包类型是LLDP:</p>
<p>​    解析chassisid、portid、ttl、end</p>
<p>解析结束</p>
<p>Ingress：</p>
<p>if 数据包来自CPU 并且 是LLDP包：</p>
<p>​    向全部端口广播</p>
<p>if 数据包不来自CPU 并且 是LLDP包：</p>
<p>​    使能packet-in</p>
<p>​    在packet-in中设置该LLDP包的入端口</p>
<p>​    发往CPU</p>
<p>if 数据包是ipv4包：</p>
<p>​    ipv4查表转发</p>
<p>Ingress结束</p>
<p>Egress：</p>
<p>if 数据包的入端口和出端口相同：</p>
<p>​    丢弃该数据包 // 全端口广播 -&gt; 泛洪</p>
<p>if 数据包的LLDP port有效 并且 不发往CPU：</p>
<p>​    在lldpdu port中设置出端口</p>
<h2 id="控制平面解析处理LLDP协议数据包"><a href="#控制平面解析处理LLDP协议数据包" class="headerlink" title="控制平面解析处理LLDP协议数据包"></a>控制平面解析处理LLDP协议数据包</h2><p>[x] 广播</p>
<p> :question:p4runtime-shell目前不支持同时连接多个交换机，需要修改。原因：目前，client为全局变量，所有操作直接使用client变量进行，需要修改为向所有操作传递一个连接变量，仅对该连接进行操作。</p>
<p>[x] 可与多个交换机同时建立连接</p>
<p>[ ] 控制器向多个交换机发送packet-out包，并统一处理交换机发过来的packet-in包</p>
<p>思路：两个线程，一个线程负责轮询所有交换机的packet-in队列，将各个队列中的包放进另一个队列q，另一个线程处理队列q。</p>
<p>控制平面保存网络拓朴的数据结构</p>
<p>控制平面对网络拓扑的操作逻辑，比如添加、删除、修改等。</p>
<p>git 查看分支情况 <code>git log --graph --all --decorate</code></p>
<p>检测特定端口的通断。</p>
<p>控制器定时或受触发的向交换机发送LLDP包，并在包的TLV中指定出去的端口。若超时没有从其他交换机接收到该LLDP包，则判断该端口对应的链路DOWN掉。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/LLDP/" data-id="ckmn1lhzh0001n8a85x57crwr" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-p4程序编译" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/p4%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.725Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>本处使用的P4文件为/root/test/test.p4<br>进入文件夹/root/test/</p>
<h2 id="barefoot-runtime"><a href="#barefoot-runtime" class="headerlink" title="barefoot-runtime"></a>barefoot-runtime</h2><p>编译命令为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p4c -a v1model -g -o $PWD -I $PWD  --bf-rt-schema $PWD/bf-rt.json ./test.p4</span><br></pre></td></tr></table></figure>

<p>-a: 代码中使用的架构，此处为v1model。</p>
<p>-g: 产生调试信息。</p>
<p>-I SEARCH_PATH: 添加SEARCH_PATH作为include的搜寻路径</p>
<p>–bf-rt-schema BF_RT_SCHEMA: 得到名为BF_RT_SCHEMA的barefoot runtime文件。</p>
<p>-o: 编译输出的文件夹，需要输出到$SDE_INSTALL/share/tofinopd/中，不然运行run_switchd.sh会报错。</p>
<p>最后为需要编译的P4文件。</p>
<h2 id="p4runtime"><a href="#p4runtime" class="headerlink" title="p4runtime"></a>p4runtime</h2><p>编译命令为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p4c -a v1model -g -o $PWD  -I $PWD  --p4runtime-files $PWD/p4info.json ./test.p4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">usage: p4c [-h] [-V] [-v] [-###] [-Xpreprocessor &lt;arg&gt;] [-Xp4c &lt;arg&gt;]</span><br><span class="line">           [-Xassembler &lt;arg&gt;] [-Xlinker &lt;arg&gt;] [-b TARGET] [-a ARCH] [-c]</span><br><span class="line">           [-D PREPROCESSOR_DEFINES] [-E] [-e] [-g] [-I SEARCH_PATH] [-o PATH]</span><br><span class="line">           [--p4runtime-file P4RUNTIME_FILE]</span><br><span class="line">           [--p4runtime-files P4RUNTIME_FILES]</span><br><span class="line">           [--p4runtime-format &#123;binary,json,text&#125;] [--help-pragmas]</span><br><span class="line">           [--help-targets] [-S] [--std &#123;p4-14,p4_14,p4-16,p4_16&#125;]</span><br><span class="line">           [--create-graphs] [--display-power-budget] [--no-link] [-s]</span><br><span class="line">           [--archive [ARCHIVE]] [--archive-source]</span><br><span class="line">           [--bf-rt-schema BF_RT_SCHEMA] [--backward-compatible]</span><br><span class="line">           [--skip-compilation SKIP_COMPILATION]</span><br><span class="line">           [--disable-egress-latency-padding] [--parser-timing-reports]</span><br><span class="line">           [--parser-bandwidth-opt] [--egress-intrinsic-metadata-opt]</span><br><span class="line">           [--ir-to-json IR_TO_JSON] [--verbose &#123;0,1,2,3&#125;]</span><br><span class="line">           [--Wdisable WDISABLE] [--Werror WERROR]</span><br><span class="line">           [--p4runtime-force-std-externs]</span><br><span class="line">           [source_file]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  source_file           Files to compile</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -V, --version         show version and exit</span><br><span class="line">  -v, --debug           verbose</span><br><span class="line">  -###, --test-only     print (but do not run) the commands</span><br><span class="line">  -Xpreprocessor &lt;arg&gt;  Pass &lt;arg&gt; to the preprocessor</span><br><span class="line">  -Xp4c &lt;arg&gt;           Pass &lt;arg&gt; to the compiler</span><br><span class="line">  -Xassembler &lt;arg&gt;     Pass &lt;arg&gt; to the assembler</span><br><span class="line">  -Xlinker &lt;arg&gt;        Pass &lt;arg&gt; to the linker</span><br><span class="line">  -b TARGET, --target TARGET</span><br><span class="line">                        specify target device</span><br><span class="line">  -a ARCH, --arch ARCH  specify target architecture</span><br><span class="line">  -c                    Only run preprocess, compile, and assemble steps</span><br><span class="line">  -D PREPROCESSOR_DEFINES</span><br><span class="line">                        define a macro to be used by the preprocessor</span><br><span class="line">  -E                    Only run the preprocessor</span><br><span class="line">  -e                    Skip the preprocessor</span><br><span class="line">  -g                    Generate debug information</span><br><span class="line">  -I SEARCH_PATH        Add directory to include search path</span><br><span class="line">  -o PATH, --output PATH</span><br><span class="line">                        Write output to the provided path</span><br><span class="line">  --p4runtime-file P4RUNTIME_FILE</span><br><span class="line">                        Write a P4Runtime control plane API description to the</span><br><span class="line">                        specified file. [Deprecated; use &#39;--p4runtime-files&#39;</span><br><span class="line">                        instead]</span><br><span class="line">  --p4runtime-files P4RUNTIME_FILES</span><br><span class="line">                        Write the P4Runtime control plane API description</span><br><span class="line">                        (P4Info) to the specified files (comma-separated</span><br><span class="line">                        list); format is detected based on file suffix. Legal</span><br><span class="line">                        suffixes are .txt, .json, .bin.</span><br><span class="line">  --p4runtime-format &#123;binary,json,text&#125;</span><br><span class="line">                        Choose output format for the P4Runtime API description</span><br><span class="line">                        (default is binary). [Deprecated; use &#39;--p4runtime-</span><br><span class="line">                        files&#39; instead]</span><br><span class="line">  --help-pragmas, --pragma-help, --pragmas-help, --help-annotations, --annotation-help, --annotations-help</span><br><span class="line">                        Print the documentation about supported</span><br><span class="line">                        annotations&#x2F;pragmas and exit.</span><br><span class="line">  --help-targets, --target-help, --targets-help</span><br><span class="line">                        Display target specific command line options.</span><br><span class="line">  -S                    Only run the preprocess and compilation steps</span><br><span class="line">  --std &#123;p4-14,p4_14,p4-16,p4_16&#125;, -x &#123;p4-14,p4_14,p4-16,p4_16&#125;</span><br><span class="line">                        Treat subsequent input files as having type language.</span><br><span class="line"></span><br><span class="line">Barefoot Networks specific options:</span><br><span class="line">  --create-graphs       Create parse and table flow graphs</span><br><span class="line">  --display-power-budget</span><br><span class="line">                        Display MAU power summary after compilation.</span><br><span class="line">  --no-link             Run up to linker</span><br><span class="line">  -s                    Only run assembler</span><br><span class="line">  --archive [ARCHIVE]   Archive all outputs into a single tar.bz2 file. Note:</span><br><span class="line">                        it can not be the argument before source file without</span><br><span class="line">                        specifying the archive name!</span><br><span class="line">  --archive-source      Add source outputs to the archive.</span><br><span class="line">  --bf-rt-schema BF_RT_SCHEMA</span><br><span class="line">                        Generate and write BF-RT JSON schema to the specified</span><br><span class="line">                        file</span><br><span class="line">  --backward-compatible</span><br><span class="line">                        Set compiler to be backward compatible with p4c-tofino</span><br><span class="line">  --skip-compilation SKIP_COMPILATION</span><br><span class="line">                        Skip compiling pipes whose name contains one of</span><br><span class="line">                        the&#39;pipeX&#39; substring</span><br><span class="line">  --disable-egress-latency-padding</span><br><span class="line">                        Disables adding match dependent stages to the egress</span><br><span class="line">                        pipeline to achieve minimum required latency</span><br><span class="line">  --parser-timing-reports</span><br><span class="line">                        Generate parser timing reports</span><br><span class="line">  --parser-bandwidth-opt</span><br><span class="line">                        Perform parser bandwidth optimization</span><br><span class="line">  --egress-intrinsic-metadata-opt</span><br><span class="line">                        Optimize unused egress intrinsic metadata</span><br><span class="line">  --ir-to-json IR_TO_JSON</span><br><span class="line">                        Dump the IR after midend to JSON in the specified</span><br><span class="line">                        file.</span><br><span class="line">  --verbose &#123;0,1,2,3&#125;   Set compiler logging verbosity level: 0&#x3D;OFF,</span><br><span class="line">                        1&#x3D;SUMMARY, 2&#x3D;INFO, 3&#x3D;DEBUG</span><br><span class="line">  --Wdisable WDISABLE   Disable a compiler diagnostic, or disable all warnings</span><br><span class="line">                        if no diagnostic is specified.</span><br><span class="line">  --Werror WERROR       Report an error for a compiler diagnostic, or treat</span><br><span class="line">                        all warnings as errors if no diagnostic is specified.</span><br><span class="line">  --p4runtime-force-std-externs</span><br><span class="line">                        Generate P4Info file using standard extern messages</span><br><span class="line">                        instead of Tofino-specific ones, for a P4 program</span><br><span class="line">                        written for a Tofino-specific arch</span><br></pre></td></tr></table></figure>

<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>加载</p>
<p>编译完成后，使用run_switchd.sh将编译好的P4程序加载进Tofino交换机：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">SDE/run_switchd.sh -c ./test.conf</span></span><br></pre></td></tr></table></figure>

<h2 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h2><p>运行之后直接回车键进入bfshell，或者运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">SDE/run_bfshell.sh</span></span><br></pre></td></tr></table></figure>
<p>进入bfshell后，使用TAB键可以得到支持的命令。</p>
<p>在bfshell中输入ucli后进入bf-sde，再输入pm进入bf-sde.pm。</p>
<p>在bf-sde.pm中使用port-add添加端口，使用show查看端口。使用exit退回bfshell。</p>
<p>在bfshell中输入bfrt_python进入bfrt_root（BF Runtime Python Shell），使用?命令得到help信息。</p>
<p>在bfrt_root中使用bfrt得到运行的程序名test，并进入bfrt。</p>
<p>在bfrt中输入上步中得到的程序名进入test，之后可对P4程序中的Table进行操作。（待完成，详见文档BF Runtime Python Shell User Guide.pdf）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=$SDE_INSTALL/lib/:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/p4%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91/" data-id="ckmn1lhzl0007n8a8ck7y1sk9" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ONOS开发环境搭建" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/ONOS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.696Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ONOS开发环境搭建"><a href="#ONOS开发环境搭建" class="headerlink" title="ONOS开发环境搭建"></a>ONOS开发环境搭建</h1><p>使用源码构建ONOS时会因网络原因出现各种意想不到的问题，建议直接下载预构建的ONOS，或使用Docker。以下步骤使用<a target="_blank" rel="noopener" href="https://github.com/opennetworkinglab/ngsdn-tutorial">ngsdn-tutorial</a>中的相关脚本，利用Docker搭建实验环境。</p>
<h2 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h2><p>由于GFW的原因，在构建实验环境前建议先设置相关代理。</p>
<h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>右键ShadowsocksR任务栏图标，选项设置，本地代理，设置端口，勾选允许来自局域网的代理</p>
<h3 id="系统代理"><a href="#系统代理" class="headerlink" title="系统代理"></a>系统代理</h3><p>系统-&gt;网络-&gt;网络代理，方法选择手动。填写HTTP/HTTPS代理地址和端口。</p>
<h3 id="curl-wget-pip代理"><a href="#curl-wget-pip代理" class="headerlink" title="curl/wget/pip代理"></a>curl/wget/pip代理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo nano ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加</span></span><br><span class="line">export http_proxy=&#x27;http://proxy.xxx.com:8080&#x27;</span><br><span class="line">export https_proxy=&#x27;https://proxy.xxx.com:8080&#x27;</span><br><span class="line">export ftp_proxy=&#x27;hhttp://proxy.xxx.com:8080&#x27;</span><br><span class="line">export no_proxy=&#x27;localhost,127.0.0.1&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新</span></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="apt代理"><a href="#apt代理" class="headerlink" title="apt代理"></a>apt代理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/apt/apt.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加</span></span><br><span class="line">Acquire::http::Proxy &quot;http://proxy.xxx.com:8080&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="git代理"><a href="#git代理" class="headerlink" title="git代理"></a>git代理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置代理</span></span><br><span class="line">git config --global http.proxy &#x27;socks5://192.168.2.5:1080&#x27; </span><br><span class="line">git config --global https.proxy &#x27;socks5://192.168.2.5:1080&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消代理</span></span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

<h3 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h3><p>在配置文件 <code>/etc/docker/daemon.json</code> 中加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&#x2F;&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新启动 dockerd：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="docker代理"><a href="#docker代理" class="headerlink" title="docker代理"></a>docker代理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">touch etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line">chmod 775 http-proxy.conf   </span><br><span class="line">nano http-proxy.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 写入</span></span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://proxy.xxx.com:8080&quot; &quot;NO_PROXY=localhost,127.0.0.1,daocloud.io&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 刷新配置，重启服务</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看配置</span></span><br><span class="line">systemctl show --property=Environment docker</span><br></pre></td></tr></table></figure>

<h2 id="获取ngsdn-tutorial"><a href="#获取ngsdn-tutorial" class="headerlink" title="获取ngsdn-tutorial"></a>获取ngsdn-tutorial</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/opennetworkinglab/ngsdn-tutorial.git</span><br><span class="line">cd ngsdn-tutorial</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 获取所有依赖docker镜像，大约1.5GB</span></span></span><br><span class="line">make pull-deps</span><br></pre></td></tr></table></figure>



<h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><h3 id="安装IDEA"><a href="#安装IDEA" class="headerlink" title="安装IDEA"></a>安装IDEA</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.jetbrains.com/idea/ideaIU-2020.1.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="更改MAVEN仓库"><a href="#更改MAVEN仓库" class="headerlink" title="更改MAVEN仓库"></a>更改MAVEN仓库</h3><p>在IDEA中进入settings -&gt; build, Execution, Deployment -&gt; Build Tools -&gt; Maven</p>
<p>勾选User setting file右侧的Override复选框，并在$HOME\.m2\settings.xml中写入以下内容并保存，应用设置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 中央仓库1 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 中央仓库2 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="导入project"><a href="#导入project" class="headerlink" title="导入project"></a>导入project</h3><p>打开ngsdn-tutorial/app，并完成相应设置。</p>
<h3 id="打包app"><a href="#打包app" class="headerlink" title="打包app"></a>打包app</h3><p>在Maven project工具窗里选择package打包应用。</p>
<h2 id="ONOS"><a href="#ONOS" class="headerlink" title="ONOS"></a>ONOS</h2><h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><p>下载docker-compose</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.25.5&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure>

<p>更改使用权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure>
<p>如果安装后docker-compose命令不可用，可能时由于/usr/local/bin/未加入PATH环境变量，可将该路径加入PATH，或在/usr/bin/中创建软连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose &#x2F;usr&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure>

<p>查看docker-compose版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.25.5, build 1110ad01</span><br></pre></td></tr></table></figure>

<h3 id="使用本地仓库"><a href="#使用本地仓库" class="headerlink" title="使用本地仓库"></a>使用本地仓库</h3><p>由于Makefile中使用Maven容器构建app，Maven容器使用的默认仓库的访问速度非常慢，需设置Maven容器使用本地仓库，前提是使用IDEA编译过一次，已下载好所有依赖包。</p>
<p>在Makefile中的_create_mvn_container中的docker create命令后加入参数<code>-v &quot;$HOME/.m2&quot;:/root/.m2</code></p>
<h3 id="启动ONOS"><a href="#启动ONOS" class="headerlink" title="启动ONOS"></a>启动ONOS</h3><p>参照ngsdn-tutorial中的Makefile文件，执行相应的命令启动所有容器。</p>
<table>
<thead>
<tr>
<th>Make command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>make pull-deps</code></td>
<td>Pull all required dependencies</td>
</tr>
<tr>
<td><code>make p4-build</code></td>
<td>Build P4 program</td>
</tr>
<tr>
<td><code>make p4-test</code></td>
<td>Run PTF tests</td>
</tr>
<tr>
<td><code>make start</code></td>
<td>Start Mininet and ONOS containers</td>
</tr>
<tr>
<td><code>make stop</code></td>
<td>Stop all containers</td>
</tr>
<tr>
<td><code>make reset</code></td>
<td>Stop containers and remove any state associated</td>
</tr>
<tr>
<td><code>make onos-cli</code></td>
<td>Access the ONOS CLI (password: <code>rocks</code>, Ctrl-D to exit)</td>
</tr>
<tr>
<td><code>make onos-log</code></td>
<td>Show the ONOS log</td>
</tr>
<tr>
<td><code>make mn-cli</code></td>
<td>Access the Mininet CLI (Ctrl-D to exit)</td>
</tr>
<tr>
<td><code>make mn-log</code></td>
<td>Show the Mininet log (i.e., the CLI output)</td>
</tr>
<tr>
<td><code>make app-build</code></td>
<td>Build custom ONOS app</td>
</tr>
<tr>
<td><code>make app-reload</code></td>
<td>Install and activate the ONOS app</td>
</tr>
<tr>
<td><code>make netcfg</code></td>
<td>Push netcfg.json file (network config) to ONOS</td>
</tr>
</tbody></table>
<p>ONOS默认用户名为onos，默认密码为rocks。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/ONOS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" data-id="ckmn1lhzi0002n8a894si46uk" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.678Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="设计模式学习笔记"><a href="#设计模式学习笔记" class="headerlink" title="设计模式学习笔记"></a>设计模式学习笔记</h1><h2 id="设计模式概览"><a href="#设计模式概览" class="headerlink" title="设计模式概览"></a>设计模式概览</h2><p>GoF 《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）</p>
<p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p>
<p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。</p>
<ul>
<li>可以提高程序员的思维能力、编程能力和设计能力。</li>
<li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li>
<li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li>
</ul>
<p>根据模式是用来完成什么工作（目的）进行划分，23种设计模式可以分为创建型模式、结构性模式和行为模式。</p>
<ul>
<li>创建型模式：用来描述怎样创建对象，主要特点是将对象的创建与使用分离，使用者不需要关注对象的创建细节，降低系统的耦合度。</li>
<li>结构型模式：用来描述如何将类或对象按某种布局组成更大的结构，分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象。</li>
<li>行为型模式：用来描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。</li>
</ul>
<p>根据模式是主要用于类上还是对象上（作用范围）进行划分，设计模式可分为类模式和对象模式两种。</p>
<ul>
<li>类模式：用于处理类与类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来。</li>
<li>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是动态的。</li>
</ul>
<table>
<thead>
<tr>
<th>范围\目的</th>
<th>创建型模式</th>
<th>结构性模式</th>
<th>行为型模式</th>
</tr>
</thead>
<tbody><tr>
<td>类模式</td>
<td>工厂方法</td>
<td>类适配器</td>
<td>模板方法<br>解释器</td>
</tr>
<tr>
<td>对象模式</td>
<td>单例<br>原型<br>抽象工厂<br>建造者</td>
<td>代理<br>对象适配器<br>桥接<br/>装饰<br/>外观<br/>享元<br/>组合</td>
<td>策略<br/>命令<br/>职责链<br/>状态<br/>观察者<br/>中介者<br/>迭代者<br/>访问者<br/>备忘录</td>
</tr>
</tbody></table>
<p>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p>
<p>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p>
<p>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</p>
<p>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</p>
<p>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p>
<p>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</p>
<p>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<p>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</p>
<p>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</p>
<p>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</p>
<p>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1320.html" title="学习完一个模式后再写这个总结">==TODO==</a></p>
<h2 id="UML中的类图"><a href="#UML中的类图" class="headerlink" title="UML中的类图"></a>UML中的类图</h2><p>统一建模语言Unified Modeling Language，UML是用来设计软件的可视化建模语言，从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图。</p>
<ol>
<li>类class</li>
</ol>
<p>类是指具有相同属性、方法和关系的对象的抽象，封装了数据和行为，具有封装性、继承性和多态性。在UML中，类使用包含类名、属性和操作且带有分隔符的矩形来表示。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1121K933555.gif" alt="Student 类"></p>
<ul>
<li><p>类名Name是一个字符串。</p>
</li>
<li><p>属性Attribute是指类的成员变量，按以下格式表示：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[可见性]属性名:类型[&#x3D;默认值]</span><br></pre></td></tr></table></figure>

<p>例如-name:String，可见性包括公有public、私有private、受保护protected和朋友friendly四种，分别用+、-、#、~表示。</p>
<ul>
<li>操作operations是类的成员方法，按以下格式表示：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[可见性]名称(参数列表)[:返回类型]</span><br></pre></td></tr></table></figure>

<p>例如+display():void</p>
<ol start="2">
<li>接口interface</li>
</ol>
<p>接口是一种特殊得类，具有类的结构但不可以被实例化，只可以被子类实现。接口包含抽象操作，但不包含属性。接口描述了类或组件对外可见得动作。在UML中，接口使用带有名称得小圆圈来表示。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1121K9493J.gif" alt="img"></p>
<ol start="3">
<li>类图class diagram</li>
</ol>
<p>类图是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型，主要用于描述软件系统的结构化设计，是系统分析与设计阶段的重要产物，也是系统编码与测试的重要以具。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1121P6195T.gif" alt="“计算长方形和圆形的周长与面积”的类图"></p>
<ol start="4">
<li>类之间的关系</li>
</ol>
<ul>
<li>依赖关系Dependence</li>
</ul>
<p>依赖关系是一种使用关系，是对象之间耦合度最弱的一种关联方式。在代码中，某个类的方法同工厂局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p>
<p>UML类图中使用带箭头的虚线表示依赖关系，箭头从使用类指向被依赖的类。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1121PA2Y5.gif" alt="依赖关系的实例"></p>
<ul>
<li>关联关系Association</li>
</ul>
<p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系。关联关系是类与类之间最常用的一种关系，分为一般关联、聚合和组合。关联关系可以是双向或单向的，在UML类图中，双向关联用带两个箭头或没有箭头的实现表示，单向关联使用带一个箭头的实现来表示，箭头从使用类指向被关联的类，也可以在关联线的两端标注角色名。在代码中，通常将一个类的对象作为另一个类的成员变量来实现关联关系。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1121Q5115Q.gif" alt="关联关系的实例"></p>
<ul>
<li>聚合关系Aggregation</li>
</ul>
<p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是has-a的关系。聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而单独存在。在UML类图中，聚合关系使用带空心菱形的实线来表示，菱形指向整体。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1121Q541410.gif" alt="聚合关系的实例"></p>
<ul>
<li>组合关系Composition</li>
</ul>
<p>组合关系是关联关系的一种。也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是contains-a的关系。组合关系中的整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。在UML类图中，组合关系使用带实心菱形来表示，菱形指向整体。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1121QFD27.gif" alt="组合关系的实例"></p>
<ul>
<li>泛化关系Generalization</li>
</ul>
<p>泛化关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是is-a的关系。在UML类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1121Q62C57.gif" alt="泛化关系的实例"></p>
<ul>
<li>实现关系Realization</li>
</ul>
<p>实现关系时接口与实现类之间的关系，类实现了接口，类中的操作实现了接口中所声明的所有抽象操作。在UML类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1121QI4317.gif" alt="实现关系的实例"></p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则Open Closed Principle,OCP：软件实体应当对拓展开放open for extension，对修改关闭closed for modification，其中软件实体包括1. 项目中划分出的模块，2. 类与接口， 3. 方法。其含义是：当应用需求改变时，在不修改软件实体的源代码或二进制代码的前提下，通过拓展模块的功能，使其满足新的要求。</p>
<p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性，其作用如下：</p>
<ol>
<li>软件遵守开闭原则的话，软件测试只需要对拓展的代码进行测试，原有的测试代码仍然能够正常运行。</li>
<li>粒度越小，软件被复用的可能性就越大，在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</li>
<li>遵守开闭原则的软件，具有较高的稳定性和延续性，易于拓展和维护。</li>
</ol>
<p>实现方法：通过“抽象约束，封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。因为抽象灵活性好，适应性广，只要抽象得合理，可以基本保持软件架构得稳定，而软件中易变得细节可以从抽象派生来得实现类来拓展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>里氏替换原则Liskov Substitution Principle，LSP：继承必须确保父类所拥有的性质在子类中任然成立，即子类能够直接替换父类，而程序行为没有变化。</p>
<p>里氏替换原则主要阐述有关继承的一些原则，也就是什么时候应该使用继承，什么时候不该使用。该原则时继承复用的基础，反映了基类与子类的关系，其主要作用如下：</p>
<ol>
<li>里氏替换原则是实现开闭原则的重要方式之一。</li>
<li>里氏替换原则克服了继承中重写父类造成的可复用性变差的缺点。</li>
<li>里氏替换原则是动作正确性的保证，即类的拓展不会给已有的系统引入新的错误，降低了代码出错的可能。</li>
</ol>
<p>实现方法：里氏替换原则通俗来讲就是：子类可以拓展父类的功能，但不能改变父类原有的功能，也就是说子类继承父类时，除添加新的方法完成新增功能以外，尽量不要重写父类的方法。重写父类的方法来完成新的功能可能使整个继承体系的复用性变差，尤其是频繁运用多态时。如果违背里氏替换原则，则继承类的对象在基类出现的地方可能会出现运行错误，需要取消原来的继承关系，重新设计它们之间的关系。</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖倒置原则Dependence Inversion Principle，DIP：高层模块不应该依赖底层模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节必须依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。</p>
<p>依赖倒置原则是实现开闭原则的重要途经，它降低了客户与实现模块之间的耦合。由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。</p>
<p>使用接口或抽象类的目的是制定好规范和契约，而不去设计任何具体的操作，把展现细节的任务交给它们的实现类去完成。其主要作用如下：</p>
<ol>
<li>降低类间耦合性。</li>
<li>提高系统的稳定性。</li>
<li>减少并发开发引起的风险。</li>
<li>提高代码的可读性和可维护性。</li>
</ol>
<p>实现方法：依赖倒置原则的目的是通过面向接口编程来降低类间的耦合性，因此在程序设计时需要遵循以下几点：</p>
<ol>
<li>每个类都尽量提供接口或抽象类，或者两者都具备。</li>
<li>变量的声明类型尽量是接口或者抽象类。</li>
<li>任何类都不应该从具体类派生。</li>
<li>使用继承时尽量遵循里氏替换原则。</li>
</ol>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则Single Responsibility Principle，SRP：一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。</p>
<p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多职责，就等于把这些职责耦合在一起，则至少存在以下缺点：</p>
<ol>
<li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力，导致脆弱的设计。</li>
<li>当客户端仅需要该对象的一个职责时，不得不将其他不需要的职责全包含进来，从而造成了代码冗余或浪费。</li>
</ol>
<p>单一职责原则的核心就是控制类的粒度大小，将对象解耦，提高其内聚性，其主要作用如下：</p>
<ol>
<li>降低类的复杂度。</li>
<li>提高类的可读性。</li>
<li>提高系统的可维护性。</li>
<li>降低变更引起的风险。</li>
</ol>
<p>实现方法：在进行程序设计时需要发现类的不同职责并将其分离，再封装到不同的类或模块中。发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p>
<p>单一职责原则同样适应于方法，一个方法应该尽可能做好一件事情，如果一个方法处理的事情太多，则颗粒度会变得很粗，不利于重用。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则Interface Segregation Principle，ISP：客户端不应该被迫依赖于它不适用的方法，一个类对另一个类的依赖应该建立在最小接口上。即：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p>
<p>接口隔离原则和单一职责原则都是为了提高类的内聚性、降低类之间的耦合性，体现了封装的思想，但不同点在于：</p>
<ol>
<li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li>
<li>单一职责原则主要是约束类，它针对的是程序中的实现和细节，接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</li>
</ol>
<p>接口隔离原则是为了约束接口、降低类对接口的依赖，其主要作用如下：</p>
<ol>
<li>将臃肿庞大的接口分解为多个细粒度的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li>
<li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li>
<li>使用多个专门的接口能体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li>
<li>减少项目工程中的代码冗余。</li>
<li>粒度粗细定义合理的接口能够保证系统的稳定性。</li>
</ol>
<p>实现方法：在具体应用接口隔离原则时，应该根据以下几个规则来衡量：</p>
<ol>
<li>接口尽量小，但是要有限度，一个接口只服务于一个子模块或业务逻辑。</li>
<li>为依赖接口的类定制服务，只提供调用者需要的方法，屏蔽不需要的方法。</li>
<li>每个项目或产品都有特定的环境因素，环境不同，接口拆分的标准就不同，因此需要深入了解业务逻辑。</li>
<li>提高内聚，减少对外交互，使接口用最小的方法去完成最多的事情。</li>
</ol>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则Law of Demeter，LoD，或称最小知识原则Least Knowledge Principle，LKP：只与你的直接朋友交谈，不跟陌生人说话，其含义是：如果两个软件实体无须直接通信，那么就不应该发生直接的相互调用，可以通过第三方转发该调用，其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<p>迪米特法则中的朋友是指当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>
<p>迪米特法则要求限制软件实体之间通信的宽度和深度，其主要作用有：</p>
<ol>
<li>降低了类之间的耦合度，提高了模块的相对独立性。</li>
<li>由于耦合度降低，从而提高了类的可复用率和系统的拓展性。</li>
</ol>
<p>过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低，因此在采用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p>
<p>实现方法：迪米特法则强调以下两点：</p>
<ol>
<li>从依赖者角度而言，只依赖应该依赖的对象。</li>
<li>从被依赖者角度而言，只暴露应该暴露的方法。</li>
</ol>
<p>所以在运用迪米特法则时要注意：</p>
<ol>
<li>在类的划分上，应该创建弱耦合的类。</li>
<li>在类的结构设计上，尽量降低类成员的访问权限。</li>
<li>在类的设计上，优先考虑将一个类设置成不变类。</li>
<li>在对其他类的引用上，将引用其他对象的次数降到最低。</li>
<li>不暴露类的属性成员，而应该提供相应的访问器（getter和setter）。</li>
<li>谨慎使用序列化serializable功能。</li>
</ol>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则Composite Reuse Principle，CRP，或组合/聚合复用原则Composition/Aggregate Reuse Principle，CARP：在软件复用时要尽量使用组合或者聚合关系来实现，其次才考虑使用继承关系，如果要使用继承关系，则必须遵循里氏替换原则。</p>
<p>通常类的复用分为继承复用和合成服用，继承复用虽然简单易实现，但存在缺点：</p>
<ol>
<li>继承复用破坏了类的封装性。继承会将父类的实现细节暴露给子类，父类对子类是透明的，这种复用称为白箱复用。</li>
<li>子类与父类的耦合度高，父类的实现的任何改变都会导致子类的实现发生变化，不利于类的扩展和维护。</li>
<li>限制了复用的灵活性，从父类继承而来的实现是静态的，在编译时定义，在运行时不可改变。</li>
</ol>
<p>采用组合或聚合时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，具有优点：</p>
<ol>
<li>维持了类的封装性，因为成分对象的内部细节对新对象是不可见的，这种复用称为黑箱复用。</li>
<li>新旧类之间的耦合度低，这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li>
<li>复用的灵活性高，这种复用在运行时可以动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li>
</ol>
<p>实现方法：合成复用原则是通过已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p>
<p>例如，汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。图 1 所示是用继淨：关系实现的汽车分类的类图。</p>
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q113160133151.gif" alt="用继承关系实现的汽车分类的类图" style="zoom: 67%;" />

<p>从图 1 可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如图 2 所示。</p>
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q11316034X57.gif" alt="用组合关系实现的汽车分类的类图" style="zoom: 67%;" />

<h2 id="设计模式遵循的原则总结"><a href="#设计模式遵循的原则总结" class="headerlink" title="设计模式遵循的原则总结"></a>设计模式遵循的原则总结</h2><p>上述七种原则是软件设计模式必须尽量遵循的原则，各种原则的侧重点不同。其中，开闭原则是总纲，要求我们对拓展开放，对修改关闭；里氏替换原则要求我们不要破坏继承体系；依赖倒置原则要求我们面向接口编程；单一职责原则要求我们类药职责单一；接口隔离原则要求我们在设计接口时要精简单一；迪米特法则要求我们降低耦合度；合成复用法则要求我们优先使用组合或聚合关系复用，少用继承关系复用。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式singleton：一个类只有一个实例对象，且该类能自行创建这个单例，并对外提供一个访问该单例的全局访问点。</p>
<p>实现方式：将类的构造函数设为私有，外部类无法调用该构造函数，也就无法生成多个实例。类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p>
<p>单例模式主要有两个角色：</p>
<ul>
<li>单例类：包含一个静态实例且能够自行创建这个实例的类。</li>
<li>访问类：使用单例的类。</li>
</ul>
<p>单例模式的结构图：</p>
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1131K441K2.gif" alt="单例模式的结构图" style="zoom:67%;" />

<p>单例模式有两种实现方式：</p>
<ul>
<li><p>懒汉式单例：该实现方式的特点是类加载时没有生产单例，只有当第一次获取单例时才会去创建这个单例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="keyword">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance=<span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程程序中使用懒汉模式存在线程安全问题，需要使用关键词<code>volatile</code>和<code>synchronized</code>来进行线程同步，这会影响性能，且消耗更多资源。</p>
</li>
<li><p>饿汉式单例：该实现方式的特点是在类加载时就创建一个单例，保证在第一次获取单例时单例就已经存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance=<span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>单例模式的应用场景：</p>
<ul>
<li>在应用场景中，某类只要求生产一个对象的时候。</li>
<li>在对象需要被共享的场合，由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度，例如web中的配置对象、数据的连接池等。</li>
<li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li>
</ul>
<p>单例模式可以拓展为有限的多例模式，这种模式中可以生成有限个实例并保存在list中，客户按需获取。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式Prototype：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象，在这里原型实例指定了要创建的对象的种类。</p>
<p>使用原型模式创建对象非常高效，无须知道对象创建的细节。</p>
<p>实现方法：java语言提供了对象的clone()方法。</p>
<p>原型模式包含以下几个角色：</p>
<ul>
<li>抽象原型类：规定了具体原型对象必须实现的接口。</li>
<li>具体原型类：实现抽象原型类的clone()方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的clone()方法复制得到的新对象。</li>
</ul>
<p>原型模式的结构图：</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q114101Fa22.gif" alt="原型模式的结构图"></p>
<p>实现：原型模式的克隆分为浅克隆和深克隆，Java中的Object类提供了浅克隆的clone()方法，具体原型类只要实现Cloneable接口就可以实现对象的浅克隆，这里的Cloneable接口就是抽象原型类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Realizetype()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型模式的测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Realizetype obj1=<span class="keyword">new</span> Realizetype();</span><br><span class="line">        Realizetype obj2=(Realizetype)obj1.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1==obj2?&quot;</span>+(obj1==obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<ul>
<li>对象之间相同或者相似，只有个别的属性不相同。</li>
<li>对象的创建过程比较麻烦，但复制比较简单。</li>
</ul>
<p>拓展：</p>
<p>原型模式可以拓展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器PrototypeManager类，该类使用HashMap保存多个复制的原型，之后client类通过管理器的get方法从中获取复制得到的原型。</p>
<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q114102049214.gif" alt="带原型管理器的原型模式的结构图"  />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> <span class="keyword">extends</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Circle w=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            w=(Circle)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(CloneNotSupportedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;拷贝圆失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Square b=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            b=(Square)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(CloneNotSupportedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;拷贝正方形失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProtoTypeManager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Shape&gt;ht=<span class="keyword">new</span> HashMap&lt;String,Shape&gt;(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtoTypeManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ht.put(<span class="string">&quot;Circle&quot;</span>,<span class="keyword">new</span> Circle());</span><br><span class="line">           ht.put(<span class="string">&quot;Square&quot;</span>,<span class="keyword">new</span> Square());</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addshape</span><span class="params">(String key,Shape obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ht.put(key,obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Shape temp=ht.get(key);</span><br><span class="line">        <span class="keyword">return</span> (Shape) temp.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoTypeShape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ProtoTypeManager pm=<span class="keyword">new</span> ProtoTypeManager();    </span><br><span class="line">        Shape obj1=(Circle)pm.getShape(<span class="string">&quot;Circle&quot;</span>);</span><br><span class="line">        obj1.countArea();          </span><br><span class="line">        Shape obj2=(Shape)pm.getShape(<span class="string">&quot;Square&quot;</span>);</span><br><span class="line">        obj2.countArea();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式FactoryMethod：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类中，满足创建模式中“创建与使用相分离”的特点。</p>
<p>被创建的对象成为产品，创建产品的对象成为工厂，如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫做简单工厂。该模式下，工厂类中包含必要的逻辑判断，根据客户端的选择条件动态实例化相关的类。如果需要增加新产品，则需要修改工厂类，违背了开闭原则。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q114135306120.gif" alt="简单工厂模式的结构图"></p>
<p>工厂方法模式的主要优点有：</p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到想要的产品，无需知道产品的具体创建过程。</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则。</li>
</ul>
<p>其缺点是：没增加一个产品就要增加一个具体产品类和一个对应的具体工厂类这增加了系统的复杂度。</p>
<p>工厂方法模式主要角色：</p>
<ul>
<li><p>抽象工厂abstract factory：提供了创建产品的结构，调用者通过它访问具体工厂的方法newProduct()来创建产品。</p>
</li>
<li><p>具体工厂concrete factory：实现抽象工厂中的抽象方法，完成具体产品的创建。</p>
</li>
<li><p>抽象产品product：定义了产品的规范，描述了产品的主要特性和功能。</p>
</li>
<li><p>具体产品concrete product：实现了抽象产品所定义的接口，由具体工厂来创建，同具体工厂一一对应。</p>
</li>
</ul>
<p>结构图：</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q114135A2M3.gif" alt="工厂方法模式的结构图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            AbstractFactory af=(AbstractFactory) <span class="keyword">new</span> ConcreteFactory1;</span><br><span class="line">            Product product=af.newProduct();</span><br><span class="line">            product.show();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品1：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品2：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂：提供了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂1：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂2：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂2生成--&gt;具体产品2...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<ul>
<li>客户只知道创建产品的工厂名，而不知道具体的产品名。</li>
<li>创建对象的任务由多个具体子工厂中的某一个完场，而抽象工厂只提供创建产品的接口。</li>
<li>客户不关系创建产品的细节，只关心产品的品牌。</li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式AbstractFactory：为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无需指定所要的具体类。</p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级产品，将一个具体工厂生产的一组产品成为一个产品族。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1141559151S.gif" alt="电器工厂的产品等级与产品族"></p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>
</ul>
<p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p>
<ul>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
<li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</li>
</ul>
<p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<p>抽象工厂模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li>
</ol>
<p>结构：</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q11416002NW.gif" alt="抽象工厂模式的结构图"></p>
<p>实现方式与工厂方法模式类似，不过增加了产品的种类，所以抽象工厂和具体工厂中创建产品的方法也不止一个。</p>
<p>适应场景：</p>
<ul>
<li><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时。</p>
</li>
<li><p>系统中有多个产品族，但每次只使用其中的某一族产品。</p>
</li>
<li><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p>
</li>
</ul>
<p>例如使用不同的数据库，每个数据库构成一个产品族，对数据表的一种操作构成一个产品等级。又如同一个软件在不同平台上的实现，每个平台上的实现构成一个产品族，软件的的一个部分构成一个产品等级。</p>
<p>拓展：</p>
<p>抽象工厂模式的扩展有一定的“开闭原则”倾斜性：</p>
<ul>
<li><p>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</p>
</li>
<li><p>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。</p>
</li>
</ul>
<p>可以使用简单工厂模式拓展抽象工厂模式，如下结构图所示，在工厂类中确定需要实例化的产品族productFamily，创建产品的方法根据productFamily值创建相应的产品族中的产品，例如concreteProduct21和concreteProduct11属于产品族1，concreteProduct22和concreteProduct12属于产品族2，当productFamily为1时，方法newProduct1()将返回产品concreteProduct11。在这种场景中更改产品族不需要修改客户端代码，只需要更改工厂类的productFamily值。进一步，可以使用配置文件和反射来创建创建产品，在这种情况下，可以不用修改任何代码，只需要修改配置文件的值。详情参考大会设计模式第15.7节。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200523164213731.png" alt="image-20200523164213731"></p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式Builder：将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。例如计算机是由 OPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等多个部件组装而成的，每个部件可以有多种表现形式，但是这些组成部分是不变的，构建成计算机的过程也大同小异。</p>
<p>该模式的主要优点如下：</p>
<ul>
<li><p>各个具体的建造者相互独立，有利于系统的扩展。</p>
</li>
<li><p>客户端不必知道产品内部组成的细节，便于控制细节风险。</p>
</li>
</ul>
<p>其缺点如下：</p>
<ul>
<li><p>产品的组成部分必须相同，这限制了其使用范围。</p>
</li>
<li><p>如果产品的内部变化复杂，该模式会增加很多的建造者类。</p>
</li>
</ul>
<p>建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</p>
<p>主要角色：</p>
<ul>
<li><p>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。</p>
</li>
<li><p>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</p>
</li>
<li><p>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</p>
</li>
<li><p>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</p>
</li>
</ul>
<p>结构图：</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1141H441X4.gif" alt="建造者模式的结构图"></p>
<p>实现：</p>
<ul>
<li>产品角色：包含多个组成部件的复杂对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartA</span><span class="params">(String partA)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA=partA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartB</span><span class="params">(String partB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partB=partB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartC</span><span class="params">(String partC)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partC=partC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象建造者：包含创建产品各个子部件的抽象方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> Product product=<span class="keyword">new</span> Product();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具体建造者：实现了抽象建造者接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>指挥者：调用建造者中的方法完成复杂对象的创建。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder=builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户类：确定具体的构建者，调用指挥者创建产品。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Builder builder=<span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director=<span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product=director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p>
<ul>
<li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li>
<li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li>
</ul>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>代理模式的主要优点有：</p>
<ul>
<li><p>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</p>
</li>
<li><p>代理对象可以扩展目标对象的功能；</p>
</li>
<li><p>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</p>
</li>
</ul>
<p>其主要缺点是：</p>
<ul>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
</ul>
<p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。</p>
<p>模式的结构</p>
<p>代理模式的主要角色如下。</p>
<ol>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ol>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q115093011523.gif" alt="代理模式的结构图"></p>
<p>应用场景</p>
<ul>
<li>远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li>
<li>虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li>
<li>安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。</li>
<li>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li>
<li>延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate中就存在属性的延迟加载和关联表的延时加载。</li>
</ul>
<p>拓展：</p>
<ol>
<li><p>真实主题与代理主题一一对应，增加真实主题也要增加代理。</p>
</li>
<li><p>设计代理以前真实主题必须事先存在，不太灵活。</p>
</li>
</ol>
<p>采用动态代理模式可以解决以上问题，如 Spring。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q115093255227.gif" alt="动态代理模式的结构图"></p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>该模式的主要优点如下。</p>
<ul>
<li><p>客户端通过适配器可以透明地调用目标接口。</p>
</li>
<li><p>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</p>
</li>
<li><p>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</p>
</li>
</ul>
<p>其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。</p>
<p>模式结构：</p>
<ol>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ol>
<p>类适配器结构：</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1151045351c.gif" alt="类适配器模式的结构图"></p>
<p>对象适配器结构：</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1151046105A.gif" alt="对象适配器模式的结构图"></p>
<p>应用场景</p>
<ul>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>
<li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>
</ul>
<p>拓展：双向适配器</p>
<p>适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q115104Q1604.gif" alt="双向适配器模式的结构图"></p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>桥接（Bridge）模式的优点是：</p>
<ul>
<li>由于抽象与实现分离，所以扩展能力强；</li>
<li>其实现细节对客户透明。</li>
</ul>
<p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</p>
<p>模式结构：</p>
<p>桥接（Bridge）模式包含以下主要角色。</p>
<ol>
<li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined  Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li>
</ol>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q115125253H1.gif" alt="桥接模式的结构图"></p>
<p>应用场景</p>
<ol>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</li>
</ol>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>装饰（Decorator）模式的主要优点有：</p>
<ul>
<li>采用装饰模式扩展对象的功能比采用继承方式更加灵活。</li>
<li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li>
</ul>
<p>其主要缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>
<p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。</p>
<p>模式结构</p>
<p>装饰模式主要包含以下角色。</p>
<ol>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（Concrete  Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ol>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q115142115M2.gif" alt="装饰模式的结构图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component p=<span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        Component d=<span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建具体构件角色&quot;</span>);       </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用具体构件角色的方法operation()&quot;</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component=component;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<ul>
<li>当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。</li>
<li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。</li>
<li>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</li>
</ul>
<p>装饰模式在 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 语言中的最著名的应用莫过于 Java I/O 标准库的设计了。例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。</p>
<p>下面代码是为 FileReader 增加缓冲区而采用的装饰类 BufferedReader 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;filename.txtn));</span></span><br><span class="line"><span class="string">String s=in.readLine();</span></span><br></pre></td></tr></table></figure>

<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。</p>
<ol>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ol>
<p>外观（Facade）模式的主要缺点如下。</p>
<ol>
<li>不能很好地限制客户使用子系统类。</li>
<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ol>
<p>模式结构：</p>
<ol>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
<li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。</li>
</ol>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q115152143509.gif" alt="外观模式的结构图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> facade;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Facade f=<span class="keyword">new</span> Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外观角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystem01 obj1=<span class="keyword">new</span> SubSystem01();</span><br><span class="line">    <span class="keyword">private</span> SubSystem02 obj2=<span class="keyword">new</span> SubSystem02();</span><br><span class="line">    <span class="keyword">private</span> SubSystem03 obj3=<span class="keyword">new</span> SubSystem03();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统01的method1()被调用！&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统02的method2()被调用！&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统03的method3()被调用！&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<ol>
<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li>
<li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li>
</ol>
<p>拓展</p>
<p>在外观模式中，当增加或移除子系统时需要修改外观类，这违背了“开闭原则”。如果引入抽象外观类，则在一定程度上解决了该问题。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1151524262a.gif" alt="引入抽象外观类的外观模式的结构图"></p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元（Flyweight）模式的定义：运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
<p>享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p>
<p>其主要缺点是：</p>
<ol>
<li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li>
<li>读取享元模式的外部状态会使得运行时间稍微变长。</li>
</ol>
<p>模式结构</p>
<p>享元模式中存在以下两种状态：</p>
<ol>
<li>内部状态，即不会随着环境的改变而改变的可共享部分；</li>
<li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。下面来分析其基本结构和实现方法。</li>
</ol>
<p>享元模式的主要角色有如下。</p>
<ol>
<li>抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</li>
<li>具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。</li>
<li>非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。</li>
<li>享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ol>
<p>图中的 UnsharedConcreteFlyweight 是非享元角色，里面包含了非共享的外部状态信息 info；而 Flyweight 是抽象享元角色，里面包含了享元方法 operation(UnsharedConcreteFlyweight state)，非享元的外部状态以参数的形式通过该方法传入；ConcreteFlyweight 是具体享元角色，包含了关键字 key，它实现了抽象享元接口；FlyweightFactory 是享元工厂角色，它通过关键字 key 来管理具体享元；客户角色通过享元工厂获取具体享元，并访问具体享元的相关方法。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q115161342242.gif" alt="享元模式的结构图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> flyweight;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FlyweightFactory factory=<span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">        Flyweight f01=factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f02=factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f03=factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f11=factory.getFlyweight(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Flyweight f12=factory.getFlyweight(<span class="string">&quot;b&quot;</span>);       </span><br><span class="line">        f01.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第1次调用a。&quot;</span>));       </span><br><span class="line">        f02.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第2次调用a。&quot;</span>));       </span><br><span class="line">        f03.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第3次调用a。&quot;</span>));       </span><br><span class="line">        f11.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第1次调用b。&quot;</span>));       </span><br><span class="line">        f12.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第2次调用b。&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line">    UnsharedConcreteFlyweight(String info)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.info=info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info=info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    ConcreteFlyweight(String key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.key=key;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体享元&quot;</span>+key+<span class="string">&quot;被创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight outState)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;具体享元&quot;</span>+key+<span class="string">&quot;被调用，&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;非享元信息是:&quot;</span>+outState.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//享元工厂角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Flyweight&gt; flyweights=<span class="keyword">new</span> HashMap&lt;String, Flyweight&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Flyweight flyweight=(Flyweight)flyweights.get(key);</span><br><span class="line">        <span class="keyword">if</span>(flyweight!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体享元&quot;</span>+key+<span class="string">&quot;已经存在，被成功获取！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flyweight=<span class="keyword">new</span> ConcreteFlyweight(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用场景</p>
<p>享元模式是通过减少内存中对象的数量来节省内存空间的，所以以下几种情形适合采用享元模式。</p>
<ol>
<li>系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。</li>
<li>大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。</li>
<li>由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。</li>
</ol>
<p>拓展</p>
<p>单纯享元模式，这种享元模式中的所有的具体享元类都是可以共享的，不存在非共享的具体享元类。</p>
<p>复合享元模式，这种享元模式中的有些享元对象是由一些单纯享元对象组合而成的，它们就是复合享元对象。虽然复合享元对象本身不能共享，但它们可以分解成单纯享元对象再被共享。</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p>
<p>组合模式的主要优点有：</p>
<ol>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li>
</ol>
<p>其主要缺点是：</p>
<ol>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li>不容易用继承的方法来增加构件的新功能；</li>
</ol>
<p>模式结构</p>
<ol>
<li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</li>
<li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li>
<li>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li>
</ol>
<p>组合模式分为透明式的组合模式和安全式的组合模式。</p>
<p>(1) 透明方式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。其结构图如图 1 所示。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1151G62L17.gif" alt="透明式的组合模式的结构图"></p>
<p>(2) 安全方式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。其结构图如图 2 所示。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1151GF5221.gif" alt="安全式的组合模式的结构图"></p>
<p>实现</p>
<p>假如要访问集合 c0={leaf1,{leaf2,leaf3}} 中的元素，其对应的树状图如图 3 所示。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1151GUH32.gif" alt="集合c0的树状图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> composite;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component c0=<span class="keyword">new</span> Composite(); </span><br><span class="line">        Component c1=<span class="keyword">new</span> Composite(); </span><br><span class="line">        Component leaf1=<span class="keyword">new</span> Leaf(<span class="string">&quot;1&quot;</span>); </span><br><span class="line">        Component leaf2=<span class="keyword">new</span> Leaf(<span class="string">&quot;2&quot;</span>); </span><br><span class="line">        Component leaf3=<span class="keyword">new</span> Leaf(<span class="string">&quot;3&quot;</span>);          </span><br><span class="line">        c0.add(leaf1); </span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2); </span><br><span class="line">        c1.add(leaf3);          </span><br><span class="line">        c0.operation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>&#123; &#125;           </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>&#123; &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;树叶&quot;</span>+name+<span class="string">&quot;：被访问！&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children=<span class="keyword">new</span> ArrayList&lt;Component&gt;();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj:children)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<ol>
<li>在需要表示一个对象整体与部分的层次结构的场合。</li>
<li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。</li>
</ol>
<p>扩展：复杂组合模式</p>
<p>树叶节点和树枝节点还有子节点，这时组合模式就扩展成复杂的组合模式了，如 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> AWT/<a target="_blank" rel="noopener" href="http://c.biancheng.net/swing/">Swing</a> 中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。复杂的组合模式的结构图如图 5 所示。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q1151H632613.gif" alt="复杂的组合模式的结构图"></p>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
<p>该模式的主要优点如下。</p>
<ol>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
</ol>
<p>该模式的主要缺点如下。</p>
<ol>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ol>
<p>模式结构</p>
<p>模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术。</p>
<p>模板方法模式包含以下主要角色。</p>
<p>(1) 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。</p>
<p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>
<p>基本方法：是整个算法中的一个步骤，包含以下几种类型。</p>
<ul>
<li>抽象方法：在抽象类中申明，由具体子类实现。</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>
</ul>
<p>(2) 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q116095405308.gif" alt="模板方法模式的结构图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> templateMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AbstractClass tm=<span class="keyword">new</span> ConcreteClass();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> <span class="comment">//模板方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SpecificMethod();</span><br><span class="line">        abstractMethod1();          </span><br><span class="line">         abstractMethod2();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificMethod</span><span class="params">()</span> <span class="comment">//具体方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类中的具体方法被调用...&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span>; <span class="comment">//抽象方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span>; <span class="comment">//抽象方法2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法1的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法2的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<ol>
<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li>
<li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li>
</ol>
<p>拓展</p>
<p>在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。如下面例子中，可以通过在具体子类中重写钩子方法 HookMethod1() 和 HookMethod2() 来改变抽象父类中的运行结果，其结构图如图 3 所示。</p>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/3-1Q116095550123.gif" alt="含钩子方法的模板方法模式的结构图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> templateMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookTemplateMethod</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HookAbstractClass tm=<span class="keyword">new</span> HookConcreteClass();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//含钩子方法的抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HookAbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> <span class="comment">//模板方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        abstractMethod1();</span><br><span class="line">        HookMethod1();</span><br><span class="line">        <span class="keyword">if</span>(HookMethod2())</span><br><span class="line">        &#123;</span><br><span class="line">            SpecificMethod();   </span><br><span class="line">        &#125;</span><br><span class="line">         abstractMethod2();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificMethod</span><span class="params">()</span> <span class="comment">//具体方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类中的具体方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HookMethod1</span><span class="params">()</span></span>&#123;&#125;  <span class="comment">//钩子方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HookMethod2</span><span class="params">()</span> <span class="comment">//钩子方法2</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span>; <span class="comment">//抽象方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span>; <span class="comment">//抽象方法2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//含钩子方法的具体子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HookConcreteClass</span> <span class="keyword">extends</span> <span class="title">HookAbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法1的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法2的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HookMethod1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;钩子方法1被重写...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HookMethod2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckmn1li2d000rn8a8f62f03t0" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据库系统概念学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.668Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据库系统概念——中文第六版学习笔记"><a href="#数据库系统概念——中文第六版学习笔记" class="headerlink" title="数据库系统概念——中文第六版学习笔记"></a>数据库系统概念——中文第六版学习笔记</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p> 数据库管理系统由一个互相关联的数据的集合和一组用以访问这些数据的程序组成。</p>
<p>文件处理系统中存储组织信息的主要弊端包括：</p>
<ol>
<li>数据的冗余和不一致（data redundancy and inconsistency）</li>
<li>数据访问困难（data access）</li>
<li>数据孤立（data isolation）</li>
<li>完整性问题（integrity），存储的数据值必须满足某些特定的一致性约束（consistency constraint）。</li>
<li>原子性问题（atomicity）</li>
<li>并发访问异常</li>
<li>安全性问题 </li>
</ol>
<p>数据库系统进行了以下几个层次上的抽象：</p>
<ol>
<li>物理层：描述数据的结构和存储方式。</li>
<li>逻辑层：描述数据库中的数据及数据间的关系。</li>
<li>视图层：描述数据库的某个部分。</li>
</ol>
<p>一个数据库系统具有一个物理层，一个逻辑层，若干个视图层。</p>
<p>特定时刻存储在数据库中的信息的集合称作为数据库的一个实例（instance），数据库的总体设计称作数据库模式（schema）。</p>
<p>数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合体，可以分为四类：</p>
<ol>
<li>关系模型。关系模型用表的集合来表示数据和数据间的联系，是基于记录的模型的一种。数据库是由若干种固定格式的记录来构成，每个表包含某种特定类型的记录，每个记录类型定义了固定数目的字段（属性），表的列对应于记录类型的属性。</li>
<li>实体-联系模型（Entity-Relationship model，E-R）。</li>
<li>基于对象的数据模型</li>
<li>半结构化数据模型</li>
</ol>
<p>数据库定义语言DDL来定义数据库模式，数据操纵语言DML来表达数据库的查询和更新。</p>
<p>存储在数据库中的数据值必须满足某些一致性约束：</p>
<ol>
<li>域约束（domain constraint)。每个属性都必须对应于一个所有可能的取值构成的域，例如整数、字符型、日期/时间型。</li>
<li>参照完整性(referential integrity)。一个关系中给定属性集上的取值需要在另一关系的某一属性集的取值中出现。</li>
<li>断言(assertion)。断言是指数据库需要时刻满足的某一条件，域约束和参照完整性约束是断言的一种。</li>
<li>授权(authorization)。确定不同用户在数据库中的不同数据值上允许的不同访问类型，包括读、插入、更新、删除。</li>
</ol>
<h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p>关系数据库由表(Table)的集合构成，表中的一行代表了一组值之间的一种联系。数学术语中元组(tuple)是一组值的序列，n元组是具有n个值得元组，对应于表中得一行。</p>
<p>在关系模型中，关系(relation)用来指代表，元组指代表中的行，属性(attribute)指代表中的列。</p>
<p>关系的每个属性都存在一个允许取值的集合，称为该属性的域(domain)。如果域中的元素被看作是不可再分的单元，则域是原子的(atomic)。</p>
<p>一个关系中没有两个元组在所有属性上地取值都相同。</p>
<p>超码(superkey)是一个或多个属性的集合，这些属性的集合可以在一个关系中唯一地标识一个元组。一个超码地任意超集也是超码，包含最小数量属性的超码称为候选码(candidate key)，即候选码的任意真子集都不能成为超码。</p>
<p>主码(primary key)表示被数据库设计者选中的，用来在一个关系中区分不同元组的候选码。</p>
<p>一个关系模式r<del>1</del>可能在它的属性中包括另一个关系模式r<del>2</del>的主码，这个属性在r<del>1</del>上被称作参照r<del>2</del>的外码(foreign key)，关系r<del>1</del>被成为外码以来的参照关系，r<del>2</del>称作外码的被参照关系。</p>
<p>关系代数：</p>
<ol>
<li>选择：返回输出关系中满足条件的行。</li>
<li>投影：对输入关系的所有行输出指定的属性，并去除重复元组。</li>
<li>自然连接：从两个输入关系中输出在具有相同名字的所有属性（共同属性）上取值相同的元组对。</li>
<li>笛卡尔积：从两个输入关系中输出所有元组对，无论它们在共同属性上的取值是否相同。</li>
<li>并：输出两个输入关系中元组的并。</li>
</ol>
<h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><p>SQL包括以下几个部分：</p>
<ol>
<li>数据定义语言：提供定义关系模式、删除关系、修改关系模式的命令</li>
<li>数据操纵语言：提供从数据库中查询、删除、插入、更新元组的命令。</li>
<li>完整性：DDL包括定义完整性约束的命令，插入或更新的数据不允许破坏完整性约束。</li>
<li>视图定义</li>
<li>事务控制</li>
<li>嵌入式SQL和动态SQL</li>
<li>授权</li>
</ol>
<p>SQL的DDL功能：</p>
<ol>
<li>定义一组关系</li>
<li>每个关系的模式</li>
<li>每个属性的取值类型</li>
<li>完整性约束</li>
<li>每个关系维护的索引集合</li>
<li>每个关系的安全性和权限信息</li>
<li>每个关系在磁盘上的物理存储结构</li>
</ol>
<p>SQL支持的固有数据类型：</p>
<ol>
<li>char(n)：长度为n的固定长度的字符串</li>
<li>varchar(n)：最大长度为n的可变长度的字符串。</li>
<li>int：整数类型</li>
<li>smallint：小整数类型。</li>
<li>numeric(p,d)：定点数，共有p位数字（加上符号位），其中d位在在小数点右边。</li>
<li>real,double precision：浮点数与双精度浮点数。</li>
<li>float：精度至少为 n位的浮点数。</li>
</ol>
<p>定义SQL关系：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> r</span><br><span class="line">	(A1 D1,</span><br><span class="line">   A2 D2,</span><br><span class="line">   ...,</span><br><span class="line">   <span class="operator">&lt;</span>完整性约束<span class="number">1</span><span class="operator">&gt;</span>，</span><br><span class="line">   <span class="operator">&lt;</span>完整性约束<span class="number">2</span><span class="operator">&gt;</span>);</span><br></pre></td></tr></table></figure>

<p>其中r为关系名，每个A是关系r模式中的一个属性名，D是属性A的域，即D指定了A的类型以及可选的约束。</p>
<p>完整性约束包括以下几个：</p>
<ol>
<li>primary key(A1, A2, …, An)：表示属性A1、A2、…、An构成关系的主码，主码属性必须非空且唯一。</li>
<li>foreign key(A1, A2, …, An) references S：表示关系中任意元组在属性A1、A2、…、An上的取值必须对应于关系S中某元组在主码属性上的取值。</li>
<li>not null：表示该属性上不允许空值。</li>
</ol>
<p>使用<code>drop table r</code>从数据库中删除一个关系r。</p>
<p>使用<code>delete from r</code>删除关系r中的所有元组。</p>
<p>使用<code>alter table r</code>更改已有关系的属性。</p>
<p>SQL单关系查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> A </span><br><span class="line"><span class="keyword">from</span> r</span><br><span class="line"><span class="keyword">where</span> c</span><br></pre></td></tr></table></figure>

<p><strong>select</strong>子句表示列出的查询结果中所需要的一个或多个属性。可以使用<strong>distinct</strong>删除重复元组（select distinct A），使用<strong>all</strong>保留重复元组（默认）。可以包含算术表达式。</p>
<p><strong>from</strong>表示需要访问的一个或多个关系列表。from子句定义了一个在该子句中所列出关系上的笛卡尔积。</p>
<p><strong>where</strong>子句表示查询的数据需要满足的条件，可以使用逻辑连词and、or和not，逻辑连词的运算对象可以包含比较运算符。该条件用于筛选from子句定义的笛卡尔积中的元组。</p>
<p>自然连接（**r<del>1</del> natural join r<del>2</del>**）：输出两个关系模式中所有共同属性取值相同的元素对。</p>
<p><strong>r<del>1</del> join r<del>2</del>  using （A<del>1</del>. A<del>2</del>)</strong> 输出两个关系模式中指定共同属性A<del>1</del>\A<del>2</del>上取值相同的元素对。</p>
<p><strong>r<del>1</del> join r<del>2</del> on CONDITION</strong> 输出两个关系中满足CONDITION的元素对，on CONDITION与where CONDITION一致。</p>
<p>左外连接（**r<del>1</del> left outer join r<del>2</del>**）：以第一个关系r<del>1</del>为主，即只保留r<del>1</del>中的元组，在第二个关系r2中找到满足条件（natural/on/ using）的元素，并把他们连接起来，如果r2没有对应的元素，则在r1相应位置上的值为null。</p>
<p>右外连接（**r<del>1</del> right outer join r<del>2</del>**）：以第二个关系为主，在第一个关系中找到满足条件的元素，并把他们连接起来，如果没有对应的元素，则在相应位置上的值为null。</p>
<p>全外连接（full outer join）是左外连接和右外连接的组合。</p>
<p>更名运算<strong>as</strong>可用在select和from子句中，用于为表或属性设置别名，例如select T.salary as s from Teacher as T。</p>
<p>不同数据库系统提供不同的字符串处理函数集。</p>
<p>like操作符用来实现模式匹配，%用于匹配任意子串，_用于匹配任意一个字符，模式大小写敏感。使用escape定义转义字符，转义字符用于将之后的特殊字符当成普通字符。</p>
<p>使用星号*表示所有属性。</p>
<p>order by子句用于将查询结果中的元组按排列顺寻显示，使用desc表示降序，asc表示升序，例如order by salary desc。</p>
<p>where子句中可以使用A between a and b表示一个值是否在[a,b]中，等价于A &gt;= a and A &lt;= b。</p>
<p>SQL可以使用记号(a1,a2,…,an)表示一个分量值为a1,a2,…,an的n维元组，并按顺序进行比较运算，例如(a1,a2) &lt;= (b1,b2)等价于 a1 &lt;= b1 and a2&lt;=b2。</p>
<p>使用<strong>union</strong>求两个集合的并运算，union all保留所有重复。</p>
<p>使用<strong>intersect</strong>求两个集合的交运算，使用all保留所有重复。</p>
<p>使用<strong>except</strong>从第一个集合中输出不出现在第二个集合中的元组，即差运算，使用all保留所有重复。</p>
<p>聚集函数是以值得一个集合为输入，返回单个值得函数，又avg\min\max\sum\count，分别表示求平均值、最小值、最大值、总和和计数。</p>
<p>使用distinct可以删除重复元组，例如<code>select count (distinct ID)</code>。</p>
<p><strong>group by</strong>子句用于构造分组，该子句中得所有属性上取值相同得元组将被分在一个组中。任何出现在group by子句中的属性如果出现在select子句中的话，它只能出现在聚集函数内部，否则是错误的，即select子句中没有被聚集的属性只能是group by子句中的属性。</p>
<p><strong>having</strong>子句中的条件用于筛选group by子句构成的分组，与select子句类似，having子句没有被聚集的属性只能是group by子句中的属性。</p>
<p>SQL提供嵌套子查询机制，子查询是嵌套在另一个查询的where子句中的select-from-where表达式，通常用于对集合的成员资格、集合的比较以及集合的基数进行检查。</p>
<p>连接词in用于测试元组是否是集合中的成员，集合是由select子句产生的一组值。not in则测试元组是否不是集合中的成员。</p>
<p>集合的比较可以在where子句中使用&gt; some(slect A from r) 表示至少比关系r的属性A中的某一个值要大，&gt; all表示比所有的都大，其中比较符可以使用 &lt;、&lt;=、&gt;=、=、&lt;&gt;，some等价于any。</p>
<p>exists用于测试一个子查询的结果中是否存在元组，非空时返回true。</p>
<p>SQL中来自外层查询的一个相关名称可以用在子句的子查询中，使用了来自外层查询相关名称的子查询被称作相关子查询。</p>
<p>相关名称的作用域规则类似于编程语言中的变量作用域规则，子查询只能使用本身定义的，或者包含此子查询的任何查询（父查询）中定义的相关名称，如果一个名称在子查询和父查询都有定义，则子查询中的定义有效。</p>
<p>not exists可以模拟集合包含（即超集）操作，可以将关系A包含关系B写成<code>not exists(B except A)</code>。</p>
<p>unique用于测试一个子查询的结果中是否存在重复元素，不存在重复元素时返回true。</p>
<p>from子句中可以使用子查询表达式，并使用as子句为子查询的结果（包括关系和属性）命名，形如<code>as r(a1,a2,…,a3)</code>.</p>
<p>with子句可以定义一个或多个临时关系，例如，<code>with r1(a11,a12,…,a1n) as (select a from r),r2(a21,a22,…,a2n) as (select a from r) </code>定义了r1和r2两个临时关系，分别具有属性a11,a12,…,a1n和a21,a22,…,a2n。</p>
<p>SQL的标量子查询允许返回单个属性的单个元组的子查询出现在返回单个值的表达式能够出现的任何地方。</p>
<p><code>delete from r where P</code>用于从r中删除满足关系P的元组，SQL只能删除整个元组，不能只删除元组某些属性的值。如果忽略where子句则删除r中的所有元组。</p>
<p><code>insert into r values(a1,a2,…,an)</code>用于插入values中指定数值的单个元组。values中属性值的排列顺序需要和关系模式中属性排列顺序一致，可以在关系r后面指定属性顺序，类似于python中的参数传递，<code>insert into r(A1,A2,…,An) values (a1,a2,…,an)</code>。其中，values部分可以使用select选出的元组集合。</p>
<p><code>update r set A = A_new where P</code>用于改变满足条件P的元组的部分属性的值，其中A_new可以使用case子句<code>case when p1 then a1 when p2 then a2 ... else a0 end</code>，还可以使用标量子查询。</p>
<h2 id="视图view"><a href="#视图view" class="headerlink" title="视图view"></a>视图view</h2><p>SQL允许通过查询定义“虚关系”，即视图，视图在概念上包含查询结果，但并不预先计算和存储，而是在使用时通过查询进行计算。在某些场景中对用户可见的数据可能是某个关系的一部分，若将这一部分通过查询重新保存为另一个关系，则另存为的关系与原关系不再保持一致，且需要占据额外的存储空间。</p>
<p><code>create view v as &lt;query expression&gt;</code>创建视图，v是视图名。数据库系统存储与视图相关联的查询表达式，而不是创建视图时的查询结果，只有在视图被访问时，其中的元组才通过计算查询关系而被创建出来。视图在使用时与关系等价，可以用于定义另一个视图，但使用视图进行 更新、插入或删除时存在问题。</p>
<p>特定数据库允许存储创建视图时的查询结果，并且当定义视图的实际关系改变时，视图也随之修改，这种视图为物化视图，保持物化视图一直处于最新状态的过程称为物化视图维护，或简称视图维护。视图维护可以在：构成视图定义的任何关系被更新时，视图被访问时，或周期性。物化视图可以使频繁使用视图的应用或需要快速响应基于大关系聚集计算的特定查询具有更快的查询响应速度，避免了读取大的底层关系，但增加了存储和更新开销。</p>
<h2 id="事务transaction"><a href="#事务transaction" class="headerlink" title="事务transaction"></a>事务transaction</h2><p>事务由查询和/或更新语句的序列组成，执行一条SQL语句时隐式地开始了一个事务，下列语句会结束一个事务：</p>
<ol>
<li>commit work：提交当前事务，将该事务所做地更新在数据库中持久保存，事务被提交后，一个新的事务自动开始。</li>
<li>rollback work：回滚当前事务，即撤销该事务中所有SQL语句对数据的更新，数据库恢复到执行该事务第一条语句之前地状态。</li>
</ol>
<p>数据库系统保证在发生诸如SQL语句错误、系统崩溃、断电等故障情况下，如果一个事务还没commit，其影响将被回滚。</p>
<p>事务具有原子性，即不可再分割，必须作为一个整体执行。</p>
<p>SQL允许将多条SQL语句包含在关键词begin atomic … end之间，构成一个单一事务。</p>
<h2 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h2><p>在create table和alter table中使用完整性约束</p>
<ol>
<li><p>not null：禁止在该属性上插入空值，在属性定义时声明varchar(20) not null。</p>
</li>
<li><p>unique：禁止两个元组在所列出地属性上取值相同，在表的定义中声明unique(A1,A2,…,An)。</p>
</li>
<li><p>check：指定属性值应该满足地条件，在表的定义中声明check (CONDITION)。</p>
</li>
<li><p>references：参照完整性约束/子集依赖，一个关系中给定属性集上的取值必须在另一个关系地特定属性集中出现。可以在表的定义中声明外码foreign key A reference r2，或者则属性定义使声明reference r2。</p>
<p>当违反参照完整性约束时，通常的处理是拒绝执行，但是在foreign key子句中可以指定如果被参照关系上的删除或更新违反了约束，系统需要执行的操作，而不是拒绝执行，指定方式为使用on子句：foreign key A reference r2 on delete cascade/set null/set default on update cascade/set null/set default，on delete/update表示在被参照关系中执行删除/更新操作时，cascade表示级联，在参照关系中执行相同操作，set null/default表示设置为空值或默认值。</p>
<p>约束声明中添加initially deferred子句可以使完整性约束在事务结束时检查，而不是中间步骤上。对于可延迟的约束，在事务中添加set constraints CONSTRAINT-LIST deferred语句，会使指定约束延迟到事务结束时检查。</p>
</li>
<li><p>assertion：断言assertion表示数据库需要始终满足的条件，create assertion NAME check CONDITION，CONDITION可以包含子查询。</p>
<p>关系定义中声明的约束前可以使用constraint NAME为约束命名。</p>
</li>
</ol>
<h2 id="SQL数据类型和模式"><a href="#SQL数据类型和模式" class="headerlink" title="SQL数据类型和模式"></a>SQL数据类型和模式</h2><ol>
<li><p>SQL支持如下日期/时间数据类型：</p>
<ul>
<li><p>date：日历日期，‘2001-04-25’。</p>
</li>
<li><p>time：时间，‘09:30:00.45’，变量time(p)表示秒的小数点后的数字位数，time with timezone 同时存储时区信息。</p>
</li>
<li><p>timestamp：date和time的组合，‘2001-04-25 10：29：01.45’</p>
</li>
</ul>
<p>使用cast e as t可以将字符串e转换为类型t，t为date、time、timestamp中的一种。</p>
<p>使用extract(field from d)可以从date或time值d中提取单独的域field，field可以使year month day hour minute second中的任意一种，时区信息还可以用timezone_hour timezone_minute。</p>
<p>SQL提供一些用户获取当前日期和时间的函数，current_date\current_time\localtime\localtimestamp\current_timestamp。</p>
<p>SQL可以在日期/时间类型上进行算术运算和比较，支持interval数据类型，用以表示计算得到的间隔。</p>
</li>
<li><p>SQL在属性定义时使用default定义默认值。</p>
</li>
<li><p>使用create index NAME on r(A)创建在关系r中属性A的索引，使用索引可以在查询时不读取所有元组，加快查询速度。</p>
</li>
<li><p>SQL支持字符数据的大对象数据行clob和二进制数据的大对象数据类型blob，在属性定义时声明cblob/blob (SIZE)。</p>
</li>
<li><p>SQL支持用户定义数据类型，称为独特类型distinct type。使用create type NAME as basic_type final定义新类型，新类型可以用作关系属性的类型。不同独特类型数据不能做运算，即使他们基本类型相同，需使用cast强制类型转换。可以使用drop type和alter type来删除和修改创建过的独特类型。</p>
<p>域domain可以在基本类型上施加完整性约束，create domain NAME as basic_type CONSTRAINT。域可以设置默认值，两个基本类型相容的域类型的值可以相互赋值。</p>
</li>
<li><p>create table r1 like r2可以创建一个与r2具有相同模式的新表r1。</p>
</li>
<li><p>create table r as (子查询) with data可以将子查询的结果存储为一个新表，省略with data则仅创建表，不载入数据。</p>
</li>
</ol>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>SQL包括select insert update delete权限。grant语句用来授予权限：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>权限列表<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>关系名或视图名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">to</span> <span class="operator">&lt;</span>用户<span class="operator">/</span>角色列表<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>select权限用于读取关系中的元组，update权限用于修改关系中的元组，update权限后面可以使用括号指定允许修改的属性列表，默认所有属性，insert权限用于插入元组，同理可以指定允许插入的属性列表，对于没有权限的属性，系统自动赋予默认值（如果属性定义了默认值）或null。delete权限用于删除元组。</p>
<p>用户名public指系统的所有当前和将来的用户。</p>
<p>使用revoke收回权限，revoke &lt;权限列表&gt; on &lt;关系名或视图名&gt; from &lt;用户/角色列表&gt;。</p>
<p>SQL为角色指定权限，并表示数据用户的角色，从而确定每个用户的角色。创建角色create role NAME，指定用户角色grant NAME to USER。用户的权限包括直接授予的或通过角色简介授予的。</p>
<p>SQL提供了references权限，用于允许用户创建关系时声明外码。</p>
<p>在授权时允许接受者把得到的权限在授予其他用户，需要在grant命令最后附加with grant option子句。</p>
<p>一个对象（关系/视图/角色）的创建者拥有该对象上的所有权限，包括给其他用户授权的权限。</p>
<p>权限收回时默认采用级联收回，即不仅收回该用户的权限，同时收回该用户授予其他用户的权限。可以使用在revoke子句中使用restrict子句防止级联回收，如果存在级联回收，系统返回错误，并不执行权限回收。</p>
<p>SQL允许权限由角色授予，SQL有一个与会话所关联的当前角色，默认为空，通过set role NAME来设置，NAME角色必须以及授予当前用户，否则执行失败。授予权限时如果当前角色不为空的话，可以在授权语句后面添加granted by current_role子句来将授权人设置为当前角色而不是用户。</p>
<h2 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h2><p>实体entity是现实世界中可区别于所有其他对象的一个事物和对象。实体集是相同类型即巨响相同性质或属性的实体的集合。实体通过一组属性来表示，属性是实体集中每个成员所拥有的描述性性质。</p>
<p>联系relationship是指多个实体间的相互联系，联系集是相同类型联系的集合。实体在联系中扮演的功能称为实体的角色，联系可以具有描述性属性。</p>
<p>每个属性都有一个可取值的集合，称为该属性的域domain或者值集。每个实体可以用一组属性/数据值对来表示，一个实体的属性的值必须能唯一标识该实体。简单/复合属性，单值/多值属性，派生属性。</p>
<p>映射基数表示一个实体通过一个联系集能够关联的实体个数。</p>
<p> E-R图中分成两部分的矩形代表实体集，上部分为名字，下部分为所有属性，主码属性标注下划线，菱形代表联系集，矩形表示联系集的属性，主码属性标注下划线，线段连接实体集和联系集，虚线连接联系集属性和联系集，双线表示实体在联系集中为全参与（如果实体集中的每个实体都参与到联系集中的至少一个联系中，则称实体集在联系集中为全参与，若只有部分实体参与，则为部分参与），双菱形表示连接到弱实体集的标志性联系集。</p>
<p>E-R图中二元联系集一侧标有箭头的为一，没有标记箭头的为多，从而有一对一、一对多，多对多。</p>
<p>E-R图中的实体集和二元联系集的边上可以以l..h的形式标注最小和最大的映射基数，l为最小，h为最大。最大值*代表没有限制。</p>
<p>没有足够的属性以形成主码的实体集称为弱实体集，弱实体集必须与另一个称作标识或属主实体集的实体集关联才有意义，称弱实体集存在依赖于标识实体集，标识实体集拥有它所标识的弱实体集，弱实体集与其标识实体集相连的联系称为标识性联系。弱实体集的分辨符与标识实体集的主码构成该弱实体集的主码，弱实体集的分辨符以虚下划线标注，弱实体集到标志性联系集为全参与。</p>
<p>可以将一个符合E-R数据库模式的数据库表示为一些关系模式的集合，关系模式名即为相应的实体集或联系集的名称。</p>
<p>强实体集的属性构成转换成的关系模式的属性，强实体集的主码就是生成的关系模式的主码，模式中的每个元组对应实体集中的一个实体。复杂属性需要拆分为多个简单属性。多值属性需要创建新的关系模式，新的关系模式包含实体集的主码和多值属性的子属性，并共同构成主码，同时需要建立外码约束，约束包含的实体集的主码参照实体集关系模式。</p>
<p>弱实体集的属性和所依赖的强实体集的主码构成弱实体集转换成的关系模式的属性，该关系模式的主码由弱实体集的分辨符和所依赖强实体集的主码构成，并建立外码约束，约束包含的强实体集的主码参考强实体集生成的关系模式。</p>
<p>所有参与联系集的实体集的主码与联系集的描述性属性构成转换成的关系模式的属性，所有相关实体集中主码可以共同构成主码，但存在冗余，故选用：多对多的二元联系中所有参与实体集的主码属性共同构成主码，一对一的二元联系中任一实体集的主码都选作主码，多对一或一对多的二元联系集中多的一方的实体集的主码选作主码。关系模式中还需要建立外码约束，关系中来自相关实体集关系主码属性的属性参照相关实体集关系的主码。</p>
<p>不应该用一个实体集的主码作为另一个实体集的属性，而应该用属性。</p>
<p>实体集可能包含一些子集，子集中的实体在某些方面区别于实体集中的其他实体，这种在实体集内进行分组的过程称为特化specialization。重叠特化是指一个实体集可以同时属于多个特化实体集，不相交特化是指一个实体集最多属于一个特化实体集。</p>
<p>特化代表自顶向下的设计过程，自底向上设计时用概化generalization表达，概化是指高层实体集与一个或多个底层实体集间的包含关系。高层与底层实体集也可以分别称作超类和子类。高层实体集的属性被底层实体集继承inherit。</p>
<p>数据库系统效率的主要度量方法：</p>
<ol>
<li>吞吐量：单位时间里能够处理的查询或更新（通常指事务）的平均数量。</li>
<li>响应时间：单个事务从开始到结束所需的平均时间或最长时间。</li>
</ol>
<h2 id="关系数据库设计"><a href="#关系数据库设计" class="headerlink" title="关系数据库设计"></a>关系数据库设计</h2><p>数据库设计时的规则称为函数依赖。</p>
<p>如果一个域的元素被认为是不可分的单元，则这个域是原子的。如果一个关系模式的所有属性的的域都是原子的，则称这个关系模式属于第一范式First Normal Form，1NF</p>
<p>给定关系模式r的一个实例，如果实例中所有元组对t1和t2，若t1[a]=t2[a],则t1[b]=t2[b]，其中t1 t2为r的属性集R的子集，则称这个实例满足函数依赖a$\rightarrow$b。如果r的每个合法实例都满足函数依赖a$\rightarrow$b，则称函数依赖a$\rightarrow$b在模式r上成立，一个关系实例可能满足某些函数依赖，但这些依赖并不一定在关系模式上成立。多个函数依赖构成函数依赖集。</p>
<p>在所有关系中都满足的函数依赖称为平凡的。一般的，如果$b \subseteq a$，则形如$a\rightarrow b$的函数依赖是平凡的。</p>
<p>从一个函数依赖集F推导出的所有函数依赖的集合称为该函数依赖集的闭包closure F^+^。</p>
<p>如果函数依赖闭包F^+^中所有形如$a\rightarrow b$的函数依赖满足，1. $a\rightarrow b$是平凡的函数依赖，2. a是模式R的一个超码，则称具有该函数依赖集F的关系模式R属于BCNF（Boyce-Codd）范式。构成一个数据库设计的关系模式集中的每个模式都属于BCNF，则该设计属于BCNF。</p>
<p>设模式R不属于BCNF，则存在至少一个非平凡的函数依赖$a\rightarrow b$，其中a不是R的超码，设计时可以用$a\cup b$和$R-(b-a)$两个模式取代R。</p>
<p>如果函数依赖闭包F^+^中所有形如$a\rightarrow b$的函数依赖满足1. $a\rightarrow b$是平凡的函数依赖，2. a是模式R的一个超码，3. $b-a$中的每个属性都包含于R的一个候选码中，则称具有该函数依赖集F的关系模式R属于第三范式3NF。</p>
<p>可以采用以下几个方法得到模式r(R)：</p>
<ol>
<li>由E-R图向关系模式集转换生成。</li>
<li>由一个包含所有由意义的属性的单个关系，并进行规范化将R分解成一些更小的模式。</li>
</ol>
<p>唯一角色假设：每个属性名在数据库中只有唯一的含义，不能使用同一个属性在不同的模式中表示不同的东西。</p>
<p>把一个规范化的模式编程非规范化的过程称为去规范化，去规范化用于调整系统的性能以支持响应时间苛刻的操作。可以使用物化视图额外存储，避免去规范化，保证数据一致性。</p>
<p>关系数据模型建立在严格的数学基础上。</p>
<h2 id="应用设计和开发"><a href="#应用设计和开发" class="headerlink" title="应用设计和开发"></a>应用设计和开发</h2><p>HTTP协议是无连接的，使用cookie保存会话信息，以跟踪用户会话。服务器与客户端建立会话时会在双方创建一个包含会话标识符的cookie，后续当服务器接收到一个新请求时，会向客户端请求cookie，如果客户端没有存储cookie或返回的值不是服务器记录的有效标识符时，服务器就认为该请求不是当前会话。</p>
<p>服务器在传送web页面之前会执行嵌入在HTML页面内容中的服务器端脚本，脚本会对页面做修改，页面不包含脚本源码。流行的脚本语言有jsp asp asp.net php等。</p>
<p>web页面中可以嵌入在客户端运行的代码，即客户端脚本，避免了每次与用户的交换都发送给服务器端处理，加快了交互速度，流行的脚本语言有JavaScript等，JavaScript广泛用于创建动态网页，使用统称为Ajax的几种技术，其编写的程序与服务器异步通信（即在后台，不阻断用户和web浏览器的交互），并能够获取数据并显示。</p>
<p>浏览器将HTML代码解析为内存中的一个树结构，称为文档对象模型Document Object Model，DOM。</p>
<p>大型应用通常分为若干层：</p>
<ol>
<li><p>展示层或用户界面层，用于处理用户交互。</p>
</li>
<li><p>业务逻辑层，提供对数据和数据操作的高级视图。</p>
</li>
<li><p>数据访问层，提供业务逻辑层和底层数据库之间的接口。</p>
<p>对象-关系映射是指建立从关系数据库中的数据到应用中的对象之间的映射及反向映射。Hibernate系统广泛用于将Java对象映射到关系。</p>
</li>
</ol>
<p>很多实现都基于模型-视图-控制器（Model-View-Controller，MVC）结构，模型对应于业务逻辑层，视图定义数据的显示，单个底层模式根据用于访问应用所指定的软件/设备可以具有不同的视图，控制器接收事件（用户操作），在模型上执行操作，并返回一个视图给用户。</p>
<p>代表性状态传输REpresentation State Transfer,REST：在应用服务器对URL的标准HTTP请求执行web服务函数调用，参数作为标准HTTP请求的参数发送，应用服务器执行该请求，生成结果并对其编码，然后将结果作为HTTP请求的结果返回。</p>
<p>多种Web应用开发框架都提供一些常用的特性：</p>
<ol>
<li>一个包含对象-关系映射的面向对象模式，用于在关系数据库中保存数据。</li>
<li>一个模板脚本系统。</li>
<li>一个控制器，将用户交互事件映射到处理该事件的适当函数上，管理身份验证和会话。</li>
<li>一种声明式的方式，说明一个表单在用户输入上的验证约束，系统据此生成HTML和Javascript/Ajax代码以实现表单。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </li>
</ol>
<p>报表生成器是从数据生成人们可读的概要报告的工具，它将生成格式化文本和概要图标（例如条形图和饼状图）与查询数据库集成在一起。</p>
<p>利用多种手段提高应用程序性能，确保对请求的服务有较短的响应时间：</p>
<ol>
<li>利用缓存减少开销，例如创建连接池、缓存查询结果或最终的web页面。</li>
<li>并行处理，使用多台应用服务器处理大量请求。</li>
</ol>
<p>应用程序必须对用户进行身份验证，确保用户只允许完成授权的任务，除此之外还有另外几种安全漏洞：</p>
<ol>
<li>SQL注入injection，恶意用户在应用程序构建的查询语句中先插入分号，再构建任意SQL语句，以绕过应用程序在数据库上执行任意操作。为了避免这种攻击，最好使用预设语句执行SQL查询，此时JDBC将自动添加转义字符，在在输入字符串上添加转义字符。</li>
<li>跨站点脚本攻击Cross-Site scripting，恶意用户不输入有效的文本，而输入诸如JavaScript或Flash的客户端脚本语言编写的脚本，当其他用户阅览输入的文本时，浏览器会执行该脚本，例如获取被攻击者的cookie，恶意用户获取被攻击者的cookie后，构成HTTP请求以执行攻击操作，此时Web服务器认为该请求来自原用户，从而执行攻击操作，这种漏洞又称为跨站点请求伪造。</li>
<li>密码泄露，将密码明文保存在JSP等脚本程序中，而该程序源码能被Web服务器访问，从而攻击用户能获取数据库账号的密码。为了避免这种攻击，可以对密码执行加密，或在数据库系统设置允许访问数据的网络地址集合。</li>
<li>应用程序认证，认证是指验证连接到应用程序的人/软件的身份，最简单的形式由一个密码构成，但密码容易通过试猜、嗅探网络数据包等手段泄露，因此需要采用双因素认证，即使用两个独立的不具有相同弱点的因素来识别一个用户，以及在传输过程中对密码进行加密。采用双因素认证仍可能受到中间人攻击，可以采用HTTPS协议对数据加密并防止中间人攻击。进行认证时可以采用使用LDAP等协议的中央认证服务器和单点登录系统，用于在多个网站和应用中使用同一个认证。安全断言标记语言（security assertion markup language，SAML）是一个在不同安全域间交换认证和授权信息的标准，以提供跨机构单点登录，OpenID是另一种跨机构单点登录的标准，应用程序可以使用认证提供方来认证用户，认证成功后被透明地重定向回应用程序，例如在许多网站中可以使用qq、google等账号登录。</li>
<li>应用级授权，由于数据库访问主要来自web应用服务器，最终用户在数据库本身上没有个人用户标识，因此SQL的授权规范无法使用，同时SQL缺乏单条记录级别的细粒度授权。因此需要在应用程序中执行授权，容易导致权限漏洞。</li>
<li>审计追踪是关于应用程序数据的所有更改的日志，以及一些操作信息，可以用于查找错误或欺骗性更新，探查安全漏洞。可以在关系更新操作上定义适当的触发器来创建一个数据库级审计追踪，或使用数据库系统的内置机制创建审计追踪。由于数据库级审计追踪只能记录元组级别，不能追踪业务逻辑级别，无法追踪应用程序的最终用户，因此在应用程序中通常创建一个较高级别的审计追踪，需要防止审计追踪本身被恶意用户修改或删除。</li>
<li>隐私。</li>
</ol>
<p>好的加密技术应具有如下性质：</p>
<ol>
<li>对于授权用户，加密数据和解密数据相对简单。</li>
<li>加密模式不依赖于算法的保密，而应依赖于加密密钥的算法参数，对称加密中使用同一个密钥加密/解密数据，非对称加密中使用公钥和私钥分解加密和解密数据。</li>
<li>入侵者即使获得加密数据，但难以破解加密密钥。</li>
</ol>
<p>拓展加密标准AES是一种对称加密算法，其加密密钥传输需要更高的安全机制。公钥加密模式是一种非对称加密，使用公开的公钥对数据进行加密，而只能由公钥拥有者的私钥解密（或者使用私钥加密利用公钥解密），保证了信息安全传输，但需要较高的计算代价。混合加密模式使用公钥加密模式加密对称加密密钥，然后使用该密钥对数据进行对称密钥加密。</p>
<p>字典攻击，当加密密钥公开时，对加密之前的数据的所有组合进行加密，找出与加密后的数据一致的组合，从而找出加密之前的数据。对加密密钥未公开时，可以利用数据分布的统计信息找出加密值表示的含义。可以在加密之前的数据的末尾添加额外随机位来防止字典攻击。</p>
<p>数据库系统的加密可以是对包含数据库数据的磁盘块加密，或者对关系中的属性值以加密形式存储。还可以是由应用程序在讲数据发送至数据库之前对其进行加密。</p>
<p>对称加密可以应用于数字签名，用来验证数据的真实性，私钥对数据进行签名，即加密，加密后的数据可以公开，所有人可以通过公钥解密数据来验证签名，但没有私钥的人无法生成签名的数据，则可以认证authenticate该数据。</p>
<p>数字证书，web站点的公钥由一个公钥公开的认证机构签名，使用公开的公钥来验证签署的证书，从而验证web站点的真实性。HTTPS协议使用数字证书技术加密数据。数字证书也可以用来认证用户。</p>
<p>询问-回答机制可以确保没有密码在网络上传输。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckmn1li2a000on8a8by8td2nv" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ClassLoader工作机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.654Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ClassLoader工作机制"><a href="#ClassLoader工作机制" class="headerlink" title="ClassLoader工作机制"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html">ClassLoader工作机制</a></h1><p><strong>阅读目录</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_label0">一、ClassLoader概念</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_label1">二、JVM平台提供三层classLoader</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_label2">三、JVM加载class文件到内存有两种方式</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_label3">四、ClassLoader加载类的过程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_label4"> 五、自定义类加载器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_label5">六、实现类的热部署</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_label6">七、参考资料</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_labelTop">回到顶部</a></p>
<h3 id="一、ClassLoader概念"><a href="#一、ClassLoader概念" class="headerlink" title="一、ClassLoader概念"></a>一、ClassLoader概念</h3><p>　　ClassLoader是用来动态的加载class文件到虚拟机中，并转换成java.lang.class类的一个实例，每个这样的实例用来表示一个java类，我们可以根据Class的实例得到该类的信息，并通过实例的newInstance()方法创建出该类的一个对象，除此之外，ClassLoader还负责加载Java应用所需的资源，如图像文件和配置文件等。</p>
<p>　　ClassLoader类是一个抽象类。如果给定类的二进制名称，那么类加载器会试图查找或生成构成类定义的数据。一般策略是将名称转换为某个文件名，然后从文件系统读取该名称的“类文件”。ClassLoader类使用委托模型来搜索类和资源。每个 ClassLoader实例都有一个相关的父类加载器。需要查找类或资源时，ClassLoader实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。  </p>
<p>　　注意：程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制来动态加载某个class文件到内存中。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_labelTop">回到顶部</a></p>
<h3 id="二、JVM平台提供三层classLoader"><a href="#二、JVM平台提供三层classLoader" class="headerlink" title="二、JVM平台提供三层classLoader"></a>二、JVM平台提供三层classLoader</h3><ol>
<li>Bootstrap classLoader：采用native code实现，是JVM的一部分，主要加载JVM自身工作需要的类，如java.lang.*、java.uti.*等； 这些类位于$JAVA_HOME/jre/lib/rt.jar。Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器。</li>
<li>ExtClassLoader：扩展的class loader，加载位于$JAVA_HOME/jre/lib/ext目录下的扩展jar。</li>
<li>AppClassLoader:系统class loader，父类是ExtClassLoader，加载$CLASSPATH下的目录和jar；它负责加载应用程序主函数类。</li>
</ol>
<p>　　其体系结构图如下：</p>
<p>　　<img src="https://images2015.cnblogs.com/blog/713721/201606/713721-20160602152821617-738821208.png" alt="img"></p>
<p>　　如果要实现自己的类加载器，不管是实现抽象列ClassLoader，还是继承URLClassLoader类，它的父加载器都是AppClassLoader，因为不管调用哪个父类加载器，创建的对象都必须最终调用getSystemClassLoader()作为父加载器，getSystemClassLoader()方法获取到的正是AppClassLoader。</p>
<p>　　注意：Bootstrap classLoader并不属于JVM的等级层次，它不遵守ClassLoader的加载规则，Bootstrap classLoader并没有子类。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_labelTop">回到顶部</a></p>
<h3 id="三、JVM加载class文件到内存有两种方式"><a href="#三、JVM加载class文件到内存有两种方式" class="headerlink" title="三、JVM加载class文件到内存有两种方式"></a>三、JVM加载class文件到内存有两种方式</h3><ol>
<li>隐式加载：不通过在代码里调用ClassLoader来加载需要的类，而是通过JVM来自动加载需要的类到内存，例如：当类中继承或者引用某个类时，JVM在解析当前这个类不在内存中时，就会自动将这些类加载到内存中。</li>
<li>显示加载：在代码中通过ClassLoader类来加载一个类，例如调用this.getClass.getClassLoader().loadClass()或者Class.forName()。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_labelTop">回到顶部</a></p>
<h3 id="四、ClassLoader加载类的过程"><a href="#四、ClassLoader加载类的过程" class="headerlink" title="四、ClassLoader加载类的过程"></a>四、ClassLoader加载类的过程</h3><ol>
<li>找到.class文件并把这个文件加载到内存中</li>
<li>字节码验证，Class类数据结构分析，内存分配和符号表的链接</li>
<li>类中静态属性和初始化赋值以及静态代码块的执行</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_labelTop">回到顶部</a></p>
<h3 id="五、自定义类加载器"><a href="#五、自定义类加载器" class="headerlink" title="五、自定义类加载器"></a>五、自定义类加载器</h3><h4 id="1、为何要自定义类加载器？"><a href="#1、为何要自定义类加载器？" class="headerlink" title="1、为何要自定义类加载器？"></a>1、为何要自定义类加载器？</h4><p>　　JVM提供的类加载器，只能加载指定目录的jar和class，如果我们想加载其他位置的类或jar时，例如加载网络上的一个class文件，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的类加载器。</p>
<h4 id="2、如何实现自定义的类加载器？"><a href="#2、如何实现自定义的类加载器？" class="headerlink" title="2、如何实现自定义的类加载器？"></a>2、如何实现自定义的类加载器？</h4><p>　　我们实现一个ClassLoader，并指定这个ClassLoader的加载路径。有两种方式：</p>
<p>　　<strong>方式一</strong>：继承ClassLoader，重写父类的findClass()方法，代码如下：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"> <span class="number">2</span> <span class="keyword">import</span> java.io.File;</span><br><span class="line"> <span class="number">3</span> <span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"> <span class="number">4</span> <span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> <span class="number">5</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span></span><br><span class="line"><span class="class"> 6 </span>&#123;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String drive = <span class="string">&quot;d:/&quot;</span>;</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String fileType = <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">11     </span>&#123;</span><br><span class="line"><span class="number">12</span>         PathClassLoader loader = <span class="keyword">new</span> PathClassLoader();</span><br><span class="line"><span class="number">13</span>         Class&lt;?&gt; objClass = loader.loadClass(<span class="string">&quot;HelloWorld&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="number">14</span>         Object obj = objClass.newInstance();</span><br><span class="line"><span class="number">15</span>         System.out.println(objClass.getName());</span><br><span class="line"><span class="number">16</span>         System.out.println(objClass.getClassLoader());</span><br><span class="line"><span class="number">17</span>         System.out.println(obj.getClass().toString());</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span> </span><br><span class="line"><span class="number">20</span>     <span class="keyword">public</span> Class&lt;?&gt; findClass(String name)</span><br><span class="line"><span class="number">21</span>     &#123;</span><br><span class="line"><span class="number">22</span>         <span class="keyword">byte</span>[] data = loadClassData(name);</span><br><span class="line"><span class="number">23</span>         <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);<span class="comment">// 将一个 byte 数组转换为 Class// 类的实例</span></span><br><span class="line"><span class="number">24</span>     &#125;</span><br><span class="line"><span class="number">25</span>     <span class="keyword">public</span> <span class="keyword">byte</span>[] loadClassData(String name)</span><br><span class="line"><span class="number">26</span>     &#123;</span><br><span class="line"><span class="number">27</span>         FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">28</span>         <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">29</span>         <span class="keyword">try</span></span><br><span class="line"><span class="number">30</span>         &#123;</span><br><span class="line"><span class="number">31</span>             fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(drive + name + fileType));</span><br><span class="line"><span class="number">32</span>             ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="number">33</span>             <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line"><span class="number">34</span>             <span class="keyword">while</span> ((ch = fis.read()) != -<span class="number">1</span>)</span><br><span class="line"><span class="number">35</span>             &#123;</span><br><span class="line"><span class="number">36</span>                 baos.write(ch);</span><br><span class="line"><span class="number">37</span>             &#125;</span><br><span class="line"><span class="number">38</span>             data = baos.toByteArray();</span><br><span class="line"><span class="number">39</span>         &#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line"><span class="number">40</span>         &#123;</span><br><span class="line"><span class="number">41</span>             e.printStackTrace();</span><br><span class="line"><span class="number">42</span>         &#125;</span><br><span class="line"><span class="number">43</span>         <span class="keyword">return</span> data;</span><br><span class="line"><span class="number">44</span>     &#125;</span><br><span class="line"><span class="number">45</span> &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　在第13行，我们调用了父类的loadClass()方法，该方法使用指定的二进制名称来加载类，下面是loadClass方法的源代码：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 第一步先检查这个类是否已经被加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//parent为父加载器</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//将搜索类或资源的任务委托给其父类加载器</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//检查该class是否被BootstrapClassLoader加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (ClassNotFoundException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果上述两步均没有找到加载的class，则调用findClass()方法</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">            &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　这个方法首先检查指定class是否已经被加载，如果已被加载过，则调用resolveClass()方法链接指定的类,如果还未加载，则先将搜索类或资源的任务委托给其父类加载器，检查该class是否被BootstrapClassLoader加载，如果上述两步均没有找到加载的class，则调用findClass()方法，在我们自定义的加载器中，我们重写了findClass方法，去我们指定的路径下加载class文件。</p>
<p>　　另外，我们自定义的类加载器没有指定父加载器，在JVM规范中不指定父类加载器的情况下，默认采用系统类加载器即AppClassLoader作为其父加载器，所以在使用该自定义类加载器时，需要加载的类不能在类路径中，否则的话根据双亲委派模型的原则，待加载的类会由系统类加载器加载。如果一定想要把自定义加载器需要加载的类放在类路径中, 就要把自定义类加载器的父加载器设置为null。 </p>
<p>　　<strong>方式二</strong>：继承URLClassLoader类，然后设置自定义路径的URL来加载URL下的类。</p>
<p>　　我们将指定的目录转换为URL路径，然后重写findClass方法。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_labelTop">回到顶部</a></p>
<h3 id="六、实现类的热部署"><a href="#六、实现类的热部署" class="headerlink" title="六、实现类的热部署"></a>六、实现类的热部署</h3><h4 id="1、什么是类的热部署？"><a href="#1、什么是类的热部署？" class="headerlink" title="1、什么是类的热部署？"></a>1、什么是类的热部署？</h4><p>　　所谓热部署，就是在应用正在运行的时候升级软件，不需要重新启用应用。</p>
<p>　　对于Java应用程序来说，热部署就是运行时更新Java类文件。在基于Java的应用服务器实现热部署的过程中，类装入器扮演着重要的角色。大多数基于Java的应用服务器，包括EJB服务器和Servlet容器，都支持热部署。</p>
<p>　　类装入器不能重新装入一个已经装入的类，但只要使用一个新的类装入器实例，就可以将类再次装入一个正在运行的应用程序。</p>
<h4 id="2、如何实现Java类的热部署"><a href="#2、如何实现Java类的热部署" class="headerlink" title="2、如何实现Java类的热部署"></a>2、如何实现Java类的热部署</h4><p>　　前面的分析，我们已经知道，JVM在加载类之前会检查请求的类是否已经被加载过来，也就是要调用findLoadedClass方法查看是否能够返回类实例。如果类已经加载过来，再调用loadClass会导致类冲突。</p>
<p>　　但是，JVM判断一个类是否是同一个类有两个条件：一是看这个类的完整类名是否一样(包括包名)，二是看加载这个类的ClassLoader加载器是否是同一个(既是是同一个ClassLoader类的两个实例，加载同一个类也会不一样)。</p>
<p>　　所以，要实现类的热部署可以创建不同的ClassLoader的实例对象，然后通过这个不同的实例对象来加载同名的类。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5551153.html#_labelTop">回到顶部</a></p>
<h3 id="七、参考资料"><a href="#七、参考资料" class="headerlink" title="七、参考资料"></a><strong>七、参考资料</strong></h3><p>　　1、<a target="_blank" rel="noopener" href="http://www.2cto.com/kf/201403/284030.html">http://www.2cto.com/kf/201403/284030.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/" data-id="ckmn1lhyx0000n8a81ve9g48k" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JAVA基础知识笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.644Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="java程序运行机制"><a href="#java程序运行机制" class="headerlink" title="java程序运行机制"></a>java程序运行机制</h3><p>高级语言的运行机制</p>
<p>编译型：使用专门的编译器，针对特定平台将某种高级语言源代码一次新编译成该平台执行的机器码（包括机器指令和操作数），可脱离开发环境独立运行，运行效率高，但可移植性差。例如C/C++等。</p>
<p>解释型：使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行，不会进行整体的编译和链接处理。不能脱离开发环境独立运行，运行效率低，可移植性较好，只需提供特定平台的解释器。例如Python等。</p>
<p>JAVA程序的运行机制和JVM</p>
<p>JAVA语言编译不生成特定平台的机器码，而是生成一种与平台无关的、不可执行的字节码（.class文件），需要用JAVA解释器来解释执行。</p>
<p>JVM（Java Virtual Machine）是可运行JAVA字节码的虚拟计算机，所有平台的JVM向编译器提供相同的编程接口，编译器只只需要生成JVM能理解的代码，由JVM解释执行。</p>
<p>Oracle公司指定的JVM规范具体定义了JVM的1. 指令集 2.寄存器 3.类文件的格式 4.栈 5.垃圾回收堆 6.存储区</p>
<p>JRE（Kava Runtime Environment）包含JVM、类加载器、字节码校验器、基础类库等。</p>
<p>javac命令将源文件.java编译成字节码.class</p>
<p>javac -d destdir srcFile</p>
<p>java命令解释执行平台无关的字节码程序.class</p>
<p>java Javal类名</p>
<p>一个Java源文件可以包含多个类定义，但最多只能包含一个public类定义。如果包含public类定义，则源文件的文件名必须与public类的类名相同。</p>
<p>public static void main(String[] args)</p>
<p>JAVA程序的内存分配和回收都是由JRE自动进行，JRE会提供一个后台进程来进行检测和控制不再使用的内存，一般都是在CPU空闲或内存不足时自动进行垃圾回收（Garbage Collection，GC）。</p>
<p>JAVA的堆内存是一个运行时数据区，用以保存类的实例（对象）。堆内存的回收一般由垃圾回收负责，所有的JVM都有一个由垃圾回收管理器的堆内存。垃圾回收是一种动态存储管理技术，它按照特定的垃圾回收算法自动释放不再被程序引用的对象（垃圾），清除内存碎片（碎片是分配给对象的内存块之间的空闲内存区，碎片整理将碎片所占用的堆内存移到堆的一端）。</p>
<p>JVM必须跟踪程序中的对象，因此会影响程序性能。同时垃圾回收算法的不完备性，不能保证100%收集到所有的废弃内存。</p>
<p>垃圾回收的特定：</p>
<ul>
<li>回收JVM堆内存中无用对象的内存空间，不能回收物理资源。</li>
<li>将对象的引用变量设置为null来暗示垃圾回收机制回收该对象。</li>
<li>程序通过调用Runtime对象的gc()或System.gc()等方法建议系统进行垃圾回收，不能精确控制垃圾回收机制的执行。</li>
<li>垃圾回收机制要能精确标记活着的对象，并精确定位对象之间的引用关系。</li>
</ul>
<p>结构化程序：按照功能分析系统需求，自顶向下、逐步求精、模块化。最小的程序单元是函数。</p>
<p>程序设计的三种基本结构：顺序结构、选择结构和循环结构。</p>
<p>面向对象程序设计：从现实世界中客观存在的食物出发来构造系统，将这些食物的本质特点抽象地表示为类，作为系统的基本构成单元。最小程序单元是类，类由成员变量和方法组成。</p>
<p>面向对象的基本特征</p>
<p>封装Encapsulation：将对象的实现细节隐藏起来，通过一些公用方法来暴露该对象的功能。</p>
<p>继承Inheritance：类之间共享属性的和操作的机制，继承具有传递性。</p>
<p>子类继承父类之后，可以直接获得父类的属性和方法，是实现软件复用的重要手段。</p>
<p>多态Polymorphism：子类对象可以直接赋值给父类变量，但运行时依然表现出子类的行为特征，意味着同一个类型的对象在执行同一个方法时，可能表现多种行为特征。</p>
<p>类是具有共同属性、共同方法的一类事物，类是对象的抽象，对象是类的实例。类的封装性提高了类的内聚性，降低了对象之间的耦合性。</p>
<p>抽象Abstract：忽略一个主题中与当前目标无关的方面，以更充分地注意与当前目标相关的方面。</p>
<p>面向对象分析OOA对目标系统进行分析，建立分析模型，并将之文档化。</p>
<p>面向对象设计OOD用面向对象的思想对OOA的结果进行细化，得出设计模式。</p>
<p>java使用class定义类</p>
<p>类之间的结构关系有1. 一般到特殊，继承关系，java使用extends表示继承关系，子类是一种特殊的父类，是is a关系。 2.整体到部分，组合关系，java通过在一个类里保存另一个对象的引用来实现组合关系，是has a关系。</p>
<p>java的参数传递是值传递的形式，而不是引用传递。传递引用对象的时候，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p>
<h3 id="java数据类型和运算符"><a href="#java数据类型和运算符" class="headerlink" title="java数据类型和运算符"></a>java数据类型和运算符</h3><p>java是强类型语言，所有变量必须先声明后使用，指定类型的变量只能接受类型与之匹配的值。意味着每个变量和表达式都有一个在编译时就确定的类型。</p>
<p>使用//开始单行注释，/*表示多行注释开始，*/b表示多行注释结束。</p>
<p>javadoc工具用于生产API文档，javadoc只处理类、接口、方法、成员变量、构造器和内部类之前的注释，忽视其他地方的注释，并且默认只处理public或protected修饰的部分。</p>
<p>文档注释以/**开始，以*/结束，中间部分会提取到API文档中。</p>
<p>javadoc常用的标记有：@author 指定作者，@version 指定版本，@deprecated 不推荐使用的方法，@param方法的参数说明，@return 方法的返回值说明，@see 参见，用于指定交叉参考的内容，@exception 抛出异常的类型，@throws 与@exception同义。</p>
<p>java中一个字符串、变量名不能跨行。</p>
<p>java的标识符支持unicode，区分大小写。</p>
<p>java的所有关键字都是小写。</p>
<p>goto和const两个关键字是保留字。</p>
<p>java 的数据类型分为两种基本类型和引用类型，基本类型包括boolean类型和数值类型，数值类型包括整数类型和浮点类型，整数类型包括byte\short\int\long\char，浮点类型包括float\double。引用类型是指对一个对象的引用，包括类、接口和数组，以及特殊的null类型，实质就是一个指·11针。</p>
<p>asasafdsadaddsa整型中，byte占8位，short占16位，int占32位，long占64位，都是带符号的，表示范围是-2^(N/2) ~ 2^(N/2)-1，N是位数。</p>
<p>java中将较小的整数直接赋值给byte或short时，系统自动把该整数当byte或long处理。</p>
<p>java不会把巨大的整数值当成long型处理，需要在整数值后增加后缀L。</p>
<p>二进制以0b开头，八进制以0开头，十六进制以0x开头。</p>
<p>计算机以补码保存所有整数，正数的补码是本身，负数的补码是其反码加1，反码是除最高位符号位不变外，其余位取反。</p>
<p>给整型变量直接赋值二进制整数时，如果二进制整数位数小于变量位数，则在高位补0.</p>
<p>java中字符型值必须使用单引号‘括起来，java使用16位的unicode字符集作为编码方式。有三种表现形式1.直接通过单个字符指定，例如‘A’，2. 通过转义字符表示特殊字符型值，例如‘\n’，3. 直接使用unicode值，例如‘\uXXXX’，XXXX是一个十六进制的整数。char类型的值可以直接作为整型值来使用，相当于16位的无符号整数。</p>
<p>Java使用String类来表示字符串，需要使用双引号括起来。字符串中的单引号、双引号和反斜线\需要使用转义字符表示。</p>
<p>java的浮点型数值采用二进制数据的科学计数法表示，float型数值第1位是符号位，接下来8位表示指数，再接下来的23位表示尾数，double型数值的第一位是符号位，接下来的11位表示指数，再接下来的52位表示位数。</p>
<p>浮点型数值不能精确表示一个浮点数，如果需要精确保存需要使用BigDecimal类。两个浮点型数值不能直接使用==判断是否相等。</p>
<p>java的浮点型默认是double类型，如果需要当成float处理，需要在浮点类型值后紧跟F。例如1.1字面量属于double类型，不能直接将1.1赋值给float变量，因为这是向下转型，java不能隐式执行向下转型，1.1f字面量才是float类型。</p>
<p>java中+=、-=、*=、/=、++会隐式执行类型转换，例如short s1=1; s1 = s1 + 1中，字面量1是int类型，比short精度要搞，不能隐式地将int类型下转型为short类型，但是可以使用+=、++运算符执行隐式转换。</p>
<p>浮点型数值除以0得到正无穷大或无穷大（Double或Float类的POSITIVE_INFINITY/NEGATIVE_INFINITY），此时java自动把整数0转换为浮点数0.0处理。整数除以0时会抛出异常。非数通过Double或Float类的NaN表示。</p>
<p>数值中可以使用下划线_自由分割。</p>
<p>java语言中boolean类型的数值只能是true或false，不能用0或非0来表示。boolean类型数值只要1位即可存储，但大小没有明确规定，JVM在编译阶段会将boolean型数据转换成int，用1来表示true，0表示false，JVM支持boolean数组，Oracle将boolean数组编译成byte数组，每位占用8位。</p>
<p>类型转换</p>
<p>把一个表数范围小的数值或变量直接赋给另一个表数范围大的变量时，系统可以进行自动类型转换，否则需要强制转换。</p>
<p>任何基本类型的值和字符串进行连接运算（+）时，基本类型的值将自动转换为字符串类型（调用了toString方法）。</p>
<p>java使用常量池缓存字符串直接量，常量池是指在编译器被确定，被保存在已编译的.class文件中的一些数据，包括类、方法、接口中的常量、字符串直接量。不同String型变量若被赋值同一个字符串，则它们用是相等的（使用==判断时返回true）。java会确保每个字符串常量只有一个，不会产生多个副本。</p>
<p>java除法运算符的两个操作数都是整数时，计算结果是向下取整的整数，例如19/4=4，如果有一个或两个浮点数，则结果就是浮点数，允许除数是0或0.0，此时结果是负无穷大或正无穷大。</p>
<p>java支持连续赋值，a=b=c=7。</p>
<p>java位运算有 &amp;与、|或、~非、^异或、&lt;&lt;左移、&gt;&gt;右移（左边空出来的位以原来的符号位填充），&gt;&gt;&gt;无符号右移（左边总是填充0）。一般只能操作整数类型的变量或值。</p>
<p>==的两个操作数如果都是数值类型，即使他们数据类型不相同，只要值相等，也会返回true，例如97==‘a’、5.0==5。如果都是引用类型，则只有当两个引用变量的类型具有父子关系时才可以比较，而且只有当两个引用指向同一个对象时才返回true。!=同理。</p>
<p>&amp;&amp;短路与，若左侧返回false，则不会计算右侧。&amp;不短路与，两侧都计算。同理||短路或，|不短路或。</p>
<p>！非，^异或，两侧不同时返回true。</p>
<p>三目运算符（expression）? if-true : if-false。支持嵌套。</p>
<p>switch语句的控制表达式的数据类型只能是byte、short、char、int、枚举、String。</p>
<p>swtich的case要使用break跳出，因为case代码块具有明显的开始与结束，可以不是用花括号。</p>
<p>当型循环while，直到型循环do while；。</p>
<p>return直接结束方法，return后不跟其他语句时可以结束返回值为void的方法。</p>
<p>每个方法执行时都会建立自己的内存栈，方法内定义的变量将放入栈内存中，并随着方法结束而销毁。创建对象时，对象被保存到运行时数据区，即堆内存中，不随方法结束而销毁，二十当没有任何引用变量指向它时，被垃圾回收器回收。</p>
<p>数组元素需要具有相同类型，可以替换成子类（里氏替换原则）。</p>
<p>数组对象存储在堆heap内存中，如果引用该数组对象的数组引用变量是一个局部变量，则该变量存储在栈stack内存中。如果堆内存中数组不再有任何引用变量指向自己，则这个数组成为垃圾，所占内存将会被垃圾回收机制回收。</p>
<p>Java 8中提供了工具类java.utils.Arrays，提供了多个静态方法：复制数组copyOf，判断是否相等equals，批量赋值fill，排序sort，转换成字符串toString。</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>static修饰的成员不能访问非static修饰的成员。</p>
<p>通过new关键字调用类的构造器，返回该类的实例。</p>
<p>修饰符：public\protected\private\static\final\abstract，</p>
<p>java语言中的属性（property）指的是一组setter和getter方法，例如setAge和getAge。</p>
<p>static修饰的成员表明该成员属于类本身，而不是该类的单个实例，通常称之为类变量、类方法或静态变量、静态方法，可以通过类或实例来调用。非static成员只能通过对象来调用。</p>
<p>构造器不能定义返回值类型，也不能使用void声明。如果为构造器定义了返回值类型（包括void），java会把它当成普通方法处理，而不是构造器。</p>
<p>this关键字总是指向调用该方法的对象，static修饰的方法不能使用this。</p>
<p>java的参数传递只有值传递一种。引用类型的参数也是值传递，此时传递的值是引用变量的值，形参与实参指向同一个对象。</p>
<p>java在最后一个形参的类型后增加三点...表明该形参可接受多个参数值，多个参数值当成数组传入，数组名即为该形参名。（可变长度参数）</p>
<p>方法重载是指同一个类中包含多个方法名相同但形参列表不同的方法。</p>
<p>成员变量是指定义在类里定义的变量，包含实例变量和类变量，存放在堆内存中中，局部变量是指定义在方法里的变量，包含形参、方法局部变量、代码块局部变量，存放在所在方法的栈内存中。</p>
<p>局部变量可以和成员变量同名，并且局部变量能覆盖成员变量，如果要使用被覆盖的成员变量，可以使用this作为调用者。</p>
<p>局部变量定义后不会默认初始化，即系统不会为定义的局部变量分配内存空间，而是等到程序为其赋值时才分配内存。</p>
<p>使用变量时，尽可能缩小变量的作用范围，用于减小内存开销，提高程序的内聚性。</p>
<h3 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h3><p>封装是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象的内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。</p>
<p>封装的目的 1. 隐藏类的实现细节 2. 控制对变量的访问 </p>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>
<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p>
<p>private：只能被当前类访问。</p>
<p>defalut：只能被当前包下的类访问。</p>
<p>protected：可以被同一个包或不同包中的子类访问，通常使用protected修饰希望其子类重写的方法。protect修饰的方法，如果子类不重写则不能直接调用。</p>
<p>public：可以被所有类访问。</p>
<p>模块设计追求高内聚（尽可能把模块的内部数据、功能实现细节隐藏在模块内部，不允许外部直接干预），低耦合（仅保留少量的方法给外部使用）。</p>
<p>类的绝大部分成员变量都应该使用private修饰，只有一些static修饰的、类似全局变量的成员变量才考虑使用public修饰。用于辅助实现其他方法的工具方法应该使用private修饰。</p>
<p>如果一个类的方法仅希望被其子类重写，而不希望被外界直接调用，则应用protected修饰。</p>
<p>java的包package机制提供了类的多层命名空间，用于解决类的命名冲突、类文件管理等问题。</p>
<p>指定包名后，编译时指定生成class文件的保存位置（添加-d选项），javac将自动建立对应的文件结构。否则不会。</p>
<p>指定包名后，java运行程序时需要在包所在目录（而不是类所在目录）指定完整名字（包名.类名）。同一个包中的类不必位于相同目录下，但建议源文件放在与包名一致的目录结构下，并与生成的class文件分开。</p>
<p>有了目录结构不等于有了包名，需要在源文件中通过package语句指定，该语句必须作为源文件的第一条非注释性语句，一个源文件只能指定一个包，可以定义多个类。同一个包下（不包括子包）的类可以自由访问，否则需要使用完整类名。</p>
<p>Oracle建议使用公司域名的倒写作为包名。</p>
<p>import语句可以向某个java文件中导入指定包层次下某个类或全部类（.*，*仅代表类，不代表子包），import static导入指定类的某个或全部静态变量、方法。</p>
<p>所有源文件默认导入java.lang下的所有包。</p>
<p>数值型变量的默认初始值是0，boolean型默认是false，引用类型默认是null。</p>
<p>:question:在一个构造器中直接使用另一个构造器的初始化代码，应使用this关键字来调用相应的构造器。该方法只能在构造器中使用，且必须作为构造器的第一条语句。</p>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>java使用extengs关键字实现继承，每个子类只有一个直接父类。</p>
<p>父类和子类是一般和特殊的关系（is a），子类是一种特殊的父类，父类包含的范围比子类的大。子类是对父类的拓展。</p>
<p>如果一个类没有显式指定直接父类，则默认父类是java.lang.Object类，即Object类是所有类的父类。</p>
<p>子类实现了一个与父类在方法声明上完全相同的一个方法的现象称为重写override，也称为方法覆盖，即子类重写/覆盖了父类的方法。</p>
<p>方法重写要：方法名相同，形参相同。</p>
<p>覆盖和被覆盖的方法必须都是类方法或都是实例方法。</p>
<p>父类中private的方法对子类是隐藏的，子类无法访问/覆盖该方法，如果子类中定义一个同名、同形参的方法，依然不是重写，而只是定义了一个新方法。</p>
<p>重载overload是指同一个类中，存在多个方法名称相同，但是参数类型、个数、顺序至少有一个不同（返回值不同，其它都相同不算是重载。）。重写override是子类和父类的同名方法。如果子类定义了一个与父类方法相同但参数不同的方法，则形成了父类方法和子类方法的重载。</p>
<p>为了满足里式替换原则，重写有以下三个限制：</p>
<ol>
<li><p>子类方法的访问权限必须大于等于父类方法；</p>
</li>
<li><p>子类方法的返回类型必须是父类方法返回类型或为其子类型。</p>
</li>
<li><p>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</p>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
</li>
</ol>
<p>使用super在子类方法中调用父类中定义但被隐藏（override）的，而不是在当前类中定义的实例变量或方法，即super用于限定该对象调用它从父类继承得到的实例变量或方法，即如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</p>
<p>访问没有显示指定调用者的变量，则系统查找顺序：1. 当前方法中的局部变量 2. 当前类的成员变量 3. 直接父类，上溯至所有父类，直到java.lang.Object，如果还未找到则报编译错误。</p>
<p>子类不能继承父类的构造器，但可以在子类构造器中通过super()方法调用父类构造器，从而委托父类完成一些初始化的工作。与this构造器一样，super方法也需要在子类构造器的第一行。</p>
<p>调用子类构造器时，总会先调用父类构造器（如果没有super显示调用父类构造器，则隐式调用父类无参构造器），再上溯直至Object类的构造器。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>java引用变量有两个类型：编译时类型，运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现多态。</p>
<p>相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，就是多态。因为子类是一种特殊的父类，因此可以把子类对象直接赋给一个父类引用变量，而子类可以重写父类方法。</p>
<p>引用变量在编译阶段只能调用其编译时类型所具有的方法，但运行时则执行它所运行时类型所具有的方法，因此java程序中，引用变量只能调用声明该变量时所有类里包含的方法。</p>
<p>如果需要让引用变量调用它运行时类型的方法，则必须把它强制类型转换成运行时类型，即将一个引用变量转换成其子类类型。</p>
<p>通过强制转换将父类对象复制给子类引用变量，可能在运行时产生异常，需要先使用instanceof做判断是否能转换成功。</p>
<p>instanceof的前一个操作数是引用类型变量，后一个操作数是类或接口，用于判断前面的对象是否是后面的类、子类或实现类。</p>
<h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><p>继承严重地破坏了父类的封装性，子类和父类存在严重耦合。</p>
<p>设计父类的规则：1. 尽量将父类的成员变量设置成private类型，不让子类直接访问。 2. 父类中的工具方法使用private修饰，父类中需要被外部调用，但又不希望子类重写的方法，使用public final修饰。父类的某个方法希望被子类重写，但又不希望被其他类自由访问，则使用protected修饰。 3. 尽量不在父类构造器中调用将要被子类重写的方法。</p>
<p>final修饰的类不能被继承。所有构造器都用private修饰的类不能被继承，也不能直接调用构造器创建对象，可在类中提供另一个用于创建该类实例的静态方法。</p>
<p>从父类派生子类的规则：1. 子类是一种特殊的父类， 2. 子类需要额外的属性，而不仅仅是属性值的改变， 3. 子类需要增加自己独有的行为方式，包括增加新的方法或重写父类的方法。</p>
<p>把一个类当成另一个类的组合成分，从而允许另一个类直接复用该类的public方法。</p>
<p>继承表达的是一种“是（is-a）”的关系，而组合表达的是“有（has-a)”的关系。</p>
<p>包装类是8种基本类型（byte\short\int\long\double\char\float\boolean）对应的引用类型，分别是Byte、Short、Integer、Long、Double、Character、Float、Boolean。</p>
<p>自动封箱：把一个基本类型变量直接赋给对应的包装类变量或Object变量。</p>
<p>自动拆箱：把一个包装类对象直接赋值给一个对应的基本类型变量。</p>
<p>把字符串类型的值转换为基本类型Xxx可以利用包装类提供的parseXxx(String s)静态方法，或者Xxx(String s)构造器。</p>
<p>String类的valueOf()方法可以将基本变量转换成字符串，或者直接将基本变量与空字符串“”进行连接运算。</p>
<p>Obeject类具有toString方法，默认输出“类名@hashcode”，所有对象与字符串进行连接运算时，系统自动调用对象的toString方法。</p>
<p>==判断两个基本数值型变量时，不要求类型严格相同，只要两个变量的值相等，将返回True，对于引用类型变量，只有当它们只想同一个对象时，才返回True。==不可比较没有父子关系的两个对象。</p>
<p>java程序直接使用形如“hello”的字符串直接量（包括可以在编译时就计算出来的字符串值）时，JVM将会使用常量池来管理这些字符串。当使用new String(“hello”)时，JVM会先使用常量池来管理“hello”直接量，再调用String类的构造器来创建一个新的String对象，该对象被保存在堆内存中。</p>
<p>常量池专门用于管理在编译时被确定并被保存在已编译的.class文件中的一些数据，包括类、方法、接口中的常量、字符串常量。JVM常量池保证相同的字符串直接量只有一个，不会产生多个副本。</p>
<p>####static</p>
<p>使用static修饰的成员是类成员，属于整个类，而不是单个对象，类所有的实例都共享静态成员。类成员应使用类来调用。类成员不能访问实例成员。</p>
<p>系统第一次使用一个类时，会在类加载时为该类的静态变量分配内存空间，直到该类被卸载，内存空间被垃圾回收。而实例变量是在创建实例时产生，它与该实例同生共死。</p>
<p>静态方法不依赖于任何实例，因此必须有实现，不能是抽象方法。静态方法只能访问所属类的静态字段和静态方法，方法中不能有this和super关键字。</p>
<p>静态语句块在类初始化时运行一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">	static &#123;</span><br><span class="line">		&#x2F;&#x2F; initilization;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非静态内部类依赖于外部类的实例，而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be</span></span><br><span class="line">		referenced from a <span class="keyword">static</span> context</span><br><span class="line">		OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">		InnerClass innerClass = outerClass.<span class="function">new <span class="title">InnerClass</span><span class="params">()</span></span>;</span><br><span class="line">		StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态导包，在使用静态变量和方法时不用再指明 ClassName。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>

<p>类的初始化顺序为：父类的静态变量和静态语句块、子类的静态变量和静态语句块、父类的实例变量和普通语句块（不使用static修饰）、父类的构造函数、子类的实例变量和普通语句块、子类的构造函数。其中父类一直上溯至Object类，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序</p>
<p>不可变类immutable是指创建该类的实例后，其实例变量是不可改变的。</p>
<p>如果采用new构造器创建Integer对象，每次都返回全新的integer对象，如果采用valueOf()方法创建Integer对象，则会缓存创建的对象，如果下次创建值相同的对象，则返回缓存的对象。编译器在自动装箱的过程中会调用valueOf方法，缓冲池的大小默认是-128~127，boolean的true和false值、所有byte值、-128~127以内的short和int值、\u0000~\u007F以内的char值都会使用缓冲池。Integer的缓冲池上界是可调的，在启动jvm的时候通过 -XX:AutoBoxCacheMax=&lt;size&gt; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象方法指只有方法签名，而没有方法实现的方法。抽象方法和抽象类必须使用abstract修饰符来定义。</p>
<p>抽象类不能被实例化，即使抽象类里没有抽象方法。抽象类可以包含各种成分（成员变量、普通方法或抽象方法、构造器、初始化块、内部类（接口、枚举）），构造器不能用于创建实例，主要用于被其子类调用。</p>
<p>含有抽象方法的类，包括直接定义了一个抽象方法，或继承了抽象父类但没有完全实现父类包含的抽象方法，或实现了一个接口但没有完全实现接口包含的抽象方法。只能定义成抽象类。抽象类只能被继承。</p>
<p>抽象方法使用abstract修饰，并去掉方法体（包括括号），增加分号。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口不能包含普通方法，接口里的所有方法都是抽象方法。Java 8允许在接口中定义默认方法（使用default修饰），默认方法可以提供实现。</p>
<p>接口是从多个相思类中抽象出来的规范，定义了某一批类所需要遵守的规范，体现了规范和实现分离的设计哲学，可以让软件系统的各组件之间面向接口耦合，是一种松耦合设计，降低了各模块之间的耦合，为系统提供了更好的可拓展性和可维护性。</p>
<p>接口使用interface关键字，可以继承父接口，不能继承类。接口不包含构造器和初始化块定义，只能包含静态常量，抽象实例方法、类方法或默认方法，内部类（包括内部接口、枚举）定义。接口内部的所有成员都是默认public访问权限，并且不允许定义为 private 或者 protected。</p>
<p>接口里的成员变量总是使用public static final修饰，只能在定义时指定默认值。</p>
<p>接口里的普通方法总是使用public abstract修饰，没有方法实现。默认方法和类方法都必须要方法实现，默认方法使用public default修饰。类方法、内部类都采用public static修饰。</p>
<p>接口支持多继承（extends后接多个接口，逗号分割），一个类可以实现一个或多个接口（implements关键字）。implements部分必须放在extends部分后面。一个类实现一个或多个接口后，必须完全实现这些接口里多定义的全部抽象方法，否则将保留从父接口继承得到的抽象方法，该类也必须定义成抽象类。</p>
<p>接口不能用于创建实例，但接口可以用于声明引用类型变量，该变量必须引用到其实现类的对象。</p>
<p>接口相当于整个系统的总纲，制定了系统各模块应该遵循的标准，不应该经常改变。抽象类作为系统中多个子类的共同父类，体现的是一种模板设计，是系统实现过程中已经实现部分功能但不完善的中间产品。从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</p>
<p>充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的可拓展性和可维护性。很多软件架构设计理论都倡导面向接口编程。</p>
<p>使用接口：需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；需要使用多重继承。</p>
<p>使用抽象类：需要在几个相关的类中共享代码。需要能控制继承来的成员的访问权限，而不是都为 public。需要继承非静态和非常量字段。</p>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>定义在其他类内部的类成为内部类或嵌套类，包含内部类的类成为外部类或宿主类。内部类可以提供更好的封装、直接访问外部类的私有数据。</p>
<p>非静态内部类对象必须寄生在外部类对象里，因此内部类可以直接访问外部类的静态成员，反之不行。如果外部类成员变量、内部类成员变量与部内类方法的局部变量同名，可以通过使用this和外部类类名.this作为调用者来区分。</p>
<p>非静态内部类里不能定义静态成员。</p>
<p>使用static修饰内部类，则该内部类属于外部类本身，而不属于外部类的某个对象，该内部类成为静态内部类。静态内部类可以包含静态成员。外部类不能直接访问静态内部类的成员，但可以使用静态内部类的类名作为调用者来访问静态内部类的类成员。</p>
<p>定义在方法里的类成为局部内部类。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类适合创建那些只需要使用一次的类。</p>
<p>定义匿名内部类的格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new 实现接口（） | 父类构造器（形参列表）</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;&#x2F; 匿名内部类的类体部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名类不能是抽象类，不能定义构造器，可以定义初始化块。</p>
<h3 id="Lambada表达式"><a href="#Lambada表达式" class="headerlink" title="Lambada表达式"></a>Lambada表达式</h3><p>Lambda表达式支持将代码块作为方法参数，用来创建只有一个抽象方法的接口的实例，这种接口被称为函数式接口。</p>
<p>Lambda表达式由形参列表（形参列表允许省略形参类型，如果只有一个参数，可以省略形参的括号）、箭头（-&gt;）、代码块（如果只有一条语句，可以省略花括号，也可以省略return，Lambda表达式会自动返回这条语句的值）。</p>
<p>函数式接口代表只包含一个抽象方法的接口，可以包含多个默认方法、类方法。Java 8为函数式接口提供了@FunctionalInterface注释，该注释通常放在接口定义前面，用于告诉编译器执行更严格检查，即检查该接口必须是函数式接口，否则报错）。</p>
<p>Lambda表达式的结果被当成是对象，因此可以使用Lambda表达式进行赋值，Lambda表达式代表的匿名方法实现了函数式接口中唯一的方法。</p>
<p>Lambda表达式的目标类型必须是明确的函数式接口，只能为只有一个抽象方法的接口（函数式接口）创建对象。可以将Lambda表达式赋值给函数式接口类型的变量，或作为函数式接口类型的参数传给某个方法，或使用函数式接口对Lambda表达式进行强制类型转换。</p>
<p>Lambda表达式的目标类型完全可能是变化的，只要求Lambda表达式实现的匿名方法与目标类型（函数式接口）中唯一的抽象方法有相同的形参列表。</p>
<p>java8在java.util.function包下预定义了大量函数式接口，主要有：1. XxxFunction，包含一个apply()抽象方法，用于对参数进行处理转换，然后返回一个新值，通常用于对制定数据进行转换处理。 2. XxxConsumer，包含一个accept()抽象方法，与XxxFunction类似，用于对参数进行处理，但不返回处理结果。 3. XxxPredicate，包含一个test()抽象方法，用于对参数进行判断，返回一个boolean值，通常用于判断参数是否满足特定条件，经常用于进行筛选数据。 4. XxxSupplier，包含一个getAxXxx()抽象方法，该方法不需要参数，通常会返回一个数据。</p>
<p>如果Lambda表达式的代码块只有一条代码，可以在代码块中使用方法引用和构造器引用。</p>
<ol>
<li><p>引用类方法</p>
<p>类名::类方法，函数式接口中被实现方法的全部参数传给该类方法作为参数，等价于 (a,b,…) -&gt; 类名.类方法(a,b,…)</p>
<p>例如有接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Converter &#123;</span><br><span class="line">	Integer convert(String from);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Lambda表达式创建一个Convert对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Converter converter &#x3D; from -&gt; Integer.valueOf(from)</span><br></pre></td></tr></table></figure>

<p>引用类方法创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Converter converter &#x3D; Integer::valueOf;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">converter.converter(from)</span><br></pre></td></tr></table></figure></li>
<li><p>引用特定对象的实例方法</p>
<p>特定对象::实例方法，函数式接口中被实现方法的全部参数传给该类方法作为参数，等价于 (a,b,…) -&gt; 特定对象.实例方法(a,b,…)</p>
<p>使用Lambda表达式创建对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Converter converter &#x3D; from -&gt; &quot;fkit.org&quot;.indexOf(from);</span><br></pre></td></tr></table></figure>

<p>使用引用特定对象的实例方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Converter converter &#x3D; &quot;fkit.org&quot;::indexOf</span><br></pre></td></tr></table></figure></li>
<li><p>使用某类对象的实例方法</p>
<p>类名::实例方法，函数式接口中被实现方法的第一个参数作为调用者，后面的参数全部传给该方法作为参数，等价于 (a,b,…) -&gt; a.实例方法(b,…)<br>例如有接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Test &#123;</span><br><span class="line">	String test(String a, int b, int c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Lambda表达式创建一个Convert对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test test &#x3D; (a,b,c) -&gt; a.substring(b,c);</span><br></pre></td></tr></table></figure>

<p>使用某类对象的实例方法创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test test &#x3D; String::substring;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.test(&quot;Java&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>引用构造器</p>
</li>
</ol>
<p>  类名::new，函数式接口中被实现方法的全部参数传给该构造器作为参数，等价于(a,b,…) -&gt;new 类名(a,b,…)<br>例如有接口定义：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Test &#123;</span><br><span class="line">	JFrame win(String a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   使用Lambda表达式创建一个Convert对象：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test test &#x3D; (String a) -&gt; new JFrame(a);</span><br></pre></td></tr></table></figure>

<p>   引用构造器方法创建</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test test &#x3D; JFrame::new;</span><br></pre></td></tr></table></figure>
<p>   调用<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.win(&quot;Java&quot;)</span><br></pre></td></tr></table></figure></p>
<p>Lambda表达式和匿名内部类都可以直接访问“effectively final”的局部变量，以及外部类的成员变量，两者创建的对象都可以直接调用从接口中继承的默认方法。</p>
<p>匿名内部类可以为包含多个抽象方法的接口创建实例，只要匿名内部类实现所有抽象方法即可，也可以为抽象类或普通类创建实例，但Lambda表达式只能为函数式接口创建实例。匿名内部类实现的抽象方法可以调用接口中定义的默认方法，但Lambda表达式不可以。</p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>使用静态常量（static final）来表示枚举存在以下几个问题：类型不安全，没有命名空间，输出意义不明确。</p>
<p>使用enum定义枚举类，枚举类默认继承java.lang.Enum，实现了java.lang.Serializable和java.lang.Comparable接口。</p>
<p>非抽象的枚举类默认使用final修饰，不能派生子类。枚举类的构造器只能使用private访问控制符。枚举类的所有枚举值必须在枚举类的第一行显示列出，各枚举值的索引为其位置，从0开始。多个枚举值使用逗号隔开，分号结束，系统会自动添加public static final修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> </span>&#123;</span><br><span class="line">	MALE,FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用EnumClass.variable访问枚举类实例，switch语句的控制表达式可以是枚举类型值，且case表达式中可以直接使用枚举值的名字，无需添加枚举类作为限定。</p>
<p>枚举类默认有一个values()方法，返回该枚举类的所有实例，</p>
<p>java.lang.Enum类中有方法：1. compareTo(E o)，用于与指定枚举对象比较顺序。 2. ordinal()，返回枚举值在枚举类中的索引值。 3. toString()，返回枚举常量的名称。 4. valueOf()，静态方法，返回指定枚举类中指定名称的枚举值，即根据名称获取枚举值，Gender g = Enum.valueOf(Gender.class, “FEMALE”);。</p>
<p>枚举类可以定义成员变量、方法和构造器。枚举类的实例只能是枚举值，不能随意通过new来创建枚举类对象。</p>
<p>建议枚举类的成员变量都是用private final修饰，在构造器中为这些成员变量指定初值，即为枚举类显示定义带参数的构造器，此时列出枚举值必须对应地传入参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> </span>&#123;</span><br><span class="line">  MALE(<span class="string">&quot;男&quot;</span>),FEMALE(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Gender</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类可以实现一个或多个接口，与普通类一致。不同的枚举值可以对接口中的方法有不同实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface GenderDesc &#123;</span><br><span class="line">	void info();</span><br><span class="line">&#125;</span><br><span class="line">public enum Gender implements GenderDesc &#123;</span><br><span class="line">	MALE(&quot;男&quot;) &#123;</span><br><span class="line">		public void info() &#123;</span><br><span class="line">			&#x2F;&#x2F; do some things;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FEMALE(&quot;女&quot;) &#123;</span><br><span class="line">		public void info() &#123;</span><br><span class="line">		 &#x2F;&#x2F; do other things;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在枚举类包含抽象方法，每个实例提供方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span>  </span>&#123;</span><br><span class="line">	MALE &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// do some things;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FEMALE &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		 <span class="comment">// do other things;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Gender.MALE.info();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象与垃圾回收"><a href="#对象与垃圾回收" class="headerlink" title="对象与垃圾回收"></a>对象与垃圾回收</h3><p>程序创建对象、数组等引用类型实体时，系统会在堆内存中为之分配一块内存区，根据它配引用变量所引用的状态，可以分为三种状态：1. 可达状态，有一个以上引用变量引用它。 2. 可恢复状态，不再有任何引用变量引用它，系统准备进行垃圾回收，在回收之前，系统会调用对象的finalize()方法进行资源清理，如果此时重新让一个引用变量引用该对象，则该对象再次成为可达状态，否则进入不可达状态。 3. 不可达状态，调用finalize()方法后，仍没有引用变量引用该对象，此时对象永久失去引用，变成不可达状态，系统真正回收该对象所占用的资源。</p>
<p>程序无法精确控制java垃圾回收的时机，但可以通知系统进行垃圾回收：1. 调用System类的gc静态方法，System.gc()。2. 调用Runtime对象的gc实例方法，Runtime.getRuntime().gc()。</p>
<p>垃圾回收机制在回收某个对象之前，通常要求程序调用适当的方法来清理资源，默认使用finalize()方法，在方法定义在Object类里。执行完finalize()方法后，对象消失，垃圾回收机制开始执行。</p>
<p>不要主动调用finalize()方法，finalize()方法何时调用、是否调用具有不确定性，JVM执行该方法时，可能使该对象或系统中其他对象重新变成可达状态。JVM执行该方法出现异常时，垃圾回收机制不会报告错误。</p>
<p>JAR Java Archive File，包含名为META-INF/MANIFEST.MF的清单文件。使用jar命令创建<code>jar cf test.jar test</code>。</p>
<p>使用jar命令的-e选项创建可执行的jar包<code>jar cvfe test.jar test.Test test</code>，该选项指定JAR包中作为程序入口的主类的类名（test.Test），如果主类带包名则必须指定完成类名。运行可执行jar包可使用<code>java -jar test.jar</code>或<code>javaw test.jar</code>。创建jar包时，所有的类都必须放在与包结构对应的目录结构中。</p>
<h3 id="java基础类库"><a href="#java基础类库" class="headerlink" title="java基础类库"></a>java基础类库</h3><p><code>public static void main(String[] args)</code></p>
<p>public：Java类由系统调用，为使JVM可以自由调用main()方法，使用public暴露该方法。</p>
<p>static：JVM调用main方法时，不会先创建该主类的对象，而是直接通过该类调用main方法，因此使用static修饰。</p>
<p>void：main方法被JVM调用，返回值将返回给JVM，这没有意义，因此main方法没有返回值。</p>
<p>String[] args：谁调用方法，谁负责为形参赋值，因此JVM负责为args赋值。JVM会把运行程序时，类名后的一个或多个由空格隔开的字符串以此赋值给args的数组元素，如果某个参数本身包含空格，则应该将该参数用双引号括起来。</p>
<p>Scanner类可以从文件、输入流、字符串中解析出基本类型值和字符串值，有两个方法扫描输入：</p>
<ol>
<li>hasNextXxx()，是否还有下一个输入项，其中Xxx是Int、Long等基本数据类型，如果是字符串，则直接使用hasNext()。</li>
<li>nextXxx()，获取下一个输入项。</li>
</ol>
<p>Scanner默认使用空白（空格、tab、回车）作为多个输入项之间的分隔符，可以使用useDelimiter()方法指定分隔符。</p>
<p>Scanner类提供多个构造器，不同构造器用于选择不同数据源，例如<code>new Scanner(new File(&quot;...&quot;))</code>将读取指定文件的内容。</p>
<p>System类代表当前java程序的运行平台。程序不能创建System类的对象，可以直接访问其类变量和类方法。System提供了代表标准输入、标准输出和错误输出的类变量，用于访问环境变量、系统属性的方法，加载文件和动态链接库的方法等。</p>
<p>对于一些特殊功能，例如访问操作系统底层硬件设备等，Java无法实现，需要借助C语言为Java方法提供实现，步骤如下：</p>
<ol>
<li>在java程序中声明native修饰的方法，并编译等到class文件。native修饰的方法与abstract方法类似，只有方法签名，没有实现。</li>
<li>使用javah编译1中生成的class文件，得到.h文件。</li>
<li>编写.cpp文件，包含2中得到的.h文件，实现native方法。</li>
<li>将3中的.cpp文件编译成动态链接库文件。</li>
<li>在java程序中使用System类的loadLibrary()方法或Runtime类的loadLibrary()方法加载4得到的动态链接库文件，然后java程序就可以调用该native方法。</li>
</ol>
<p>System类有两个获取系统当前时间的方法：currentTimeMillis()和nanoTime()，都返回long型整数，表示当前时间与UTC 1970.1.1的时间差，前者以毫秒为单位，后者一纳秒为单位。两者的时间粒度取决于底层操作系统，可能操作系统不支持以毫秒、纳秒为计时单位，因此返回值可能不精确。</p>
<p>System类提供identityHashCode(Object x)方法，返回指定对象的精确hashCode值，即根据该对象的地址计算得到的hashCode值。因为某个类的hashCode方法被重写后，该类实例的hashCode()方法不能唯一地标识该对象。</p>
<p>System类提供了通知系统进行垃圾回收的gc()方法，通知系统进行资源清理的runFinalization()方法。</p>
<p>Runtime类代表java程序的运行时环境，可以访问JVM的相关信息，如处理器数量、内存信息等。每个java程序都有一个与之对应的Runtime实例，应用程序不能创建自己的Runtime实例，但可以通过getRuntime()方法获取与之关联的Runtime对象。</p>
<p>Runtime类提供load(String filename)和loadLibrary(String libname)方法来加载文件和动态链接库。</p>
<p>Runtime类的exec(String cmd)方法可以单独启动一个进程来运行操作系统的命令。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>所有类、数组、枚举类的父类，任何类型的对象都可以赋值给Object类型的变量。定义一个类时没有使用extends显式指定父类，则默认继承Object父类。</p>
<p>任何Java对象都可以调用Object类的方法，几个常用方法：</p>
<ol>
<li><p>equals()，判断两个对象是否相等。</p>
</li>
<li><p>hashCode()，返回对象的hash值。</p>
</li>
<li><p>finalize()，垃圾回收器调用此方法来清理该对象的资源。</p>
</li>
<li><p>getClass()，返回该对象的运行时类。</p>
</li>
<li><p>toString()，返回该对象的字符串表示。</p>
</li>
<li><p>wait、notify、notifyAll方法，由于控制线程的暂停和运行。</p>
</li>
<li><p>clone()，用于实现对象的自我克隆，即得到当前对象的副本，且二者之间完全隔离，该方法使用protected修饰，只能被子类重写或调用，clone() 是 Object 的protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。实现步骤如下：</p>
<ol>
<li>自定义类实现Cloneable接口，这是一个标志性接口，没有定义任何方法。如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</li>
<li>自定义类实现自己的clone()方法。</li>
<li>实现clone()方法时通过super.clone()调用Object实现的clone()方法来得到该对象的副本，并返回。</li>
</ol>
<p>Object类提供的clone()方法属于浅克隆，它只克隆该对象的所有成员变量值，不会对引用类型的成员变量值所引用的对象进行克隆，拷贝对象和原始对象的引用类型引用同一个对象。使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
</li>
</ol>
<p>Object类的equals方法用于判断两个引用变量是否相等，默认和==一致（即比较对象地址是否相等），需要子类根据自定义的相等标准重写该方法，</p>
<p>正确地重写equals方法应满足 1. 自反性，x.equals(x)一定返回True，2. 对称性，y.equals(x)返回True，则x.euqals(y)也返回True， 3. 传递性，x.equals(y)和y.equals(z)返回True，则x.equals(z)也返回True。 4.若x不是null，则x.equals(null)一定返回false。5. 一致性，多次调用equals方法结果不变。</p>
<p>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</p>
<p>equals方法实现：</p>
<ol>
<li><p>检查是否为同一个对象的引用，如果是直接返回 true；</p>
</li>
<li><p>检查是否是同一个类型，如果不是，直接返回 false；</p>
</li>
<li><p>将 Object 对象进行转型；</p>
</li>
<li><p>判断每个关键域是否相等。</p>
</li>
</ol>
<p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p>
<p>java为工具类的命名习惯是添加一个字母s，例如操作数组的工具类是Arrays，操作集合的工具类是Collections，操作Object的工具类Objects。</p>
<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String类是不可变类，创建后的对象的字符序列是不可改变的，直至对象被销毁。StringBuffer是字符序列可变的字符串，创建后可以通过append()、insert()等方法改变字符序列，可以通过toString转换为String对象，内部使用synchronized进行同步，是线程安全的，。StringBuilder类与StringBuffer类似，但没有实现线程安全，因此性能略高。</p>
<p>String类声明为final，不可继承。java8中String内部使用char数组value存储数据，java9之后使用byte数组value存储，并使用一个变量表示使用的编码。String中的value数组用final修饰，且没有提供改变value数组的方法，保证String不可变。</p>
<p>String不可变的好处：</p>
<ol>
<li><p>如果String对象已被创建，则再次创建相同对象时会从String Pool中取得引用。</p>
<ol start="3">
<li>String经常用做参数，不可变性保证了参数不可变。</li>
<li>不可变性天生具有线程安全。</li>
</ol>
</li>
</ol>
<p>字符串常量池String Pool保存着所有字符串字面量literal strings（直接通过“”定义的字符串），这些字符串在编译时期就确定。java 7之前，String Pool被放在运行时常量池中，属于永久代，java7中String Pool被移到堆中，这是因为永久代的空间有限，在大量使用字符串的场景下会导致OutOfMemoryError。</p>
<p>String的intern方法在运行中将字符串添加到String Pool中，如果已存在（使用equals方法进行确定）则返回已存在字符串的引用，否则添加一个新的字符串并返回其引用。</p>
<p>使用new String(“abc”)会创建两个字符串（前提是String Pool中还没有“abc”对象）: “abc”属于字符串字面量，在编译时期会在String Pool中创建一个字符串对象，指向“abc”字符串字面量，使用new则再在堆中使用String Pool中的对象作为构造器的参数，创建一个新的字符串对象。将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<p>Math类不能创建对象，其构造器是private，其中的所有方法都是类方法，通过类名直接调用。提供了两个PI和E两个类变量。</p>
<p>Random类和ThreadLocalRandom类都是用来生成伪随机数，Random类的无参构造器使用当前时间做种子，或显式传入long型整数做种子。ThreadLocalRandom提供了current()静态方法来获取ThreadLocalRandom对象。之后两者都通过nextXxx方法获取伪随机数。</p>
<p>如果两个Randowm对象的种子相同，且方法的调用顺序也相同，会产生相同的数字序列。</p>
<p>BigDecimal类用于创建精确的浮点数。</p>
<p>不应该将double类型值作为构造器参数来创建BigDecimal对象，因为double不能精确表示浮点数，应该使用基于String的构造器，如果必须使用浮点数来构造BigDecimal对象，应该通过BigDeciaml.valueOf(double value)来创建。</p>
<p>BigDeciaml类提供了add()、subtract()等方法对精确浮点数进行常规算术运算，提供了doubleValue()方法将BigDecimal对象转换为double浮点数。</p>
<p>Java提供了Date类（java.util.Date，而不是java.sql.Date）来处理时间，但大部分构造器和方法都已经过时，不再推荐使用。Java提供了Calendar类来处理日期和时间，Calendar类是一个抽象类，是所有日历类的模板，不能直接实例化，Java本身提供了GregorianCalendar类，表示公历。</p>
<p>Java 8新增了java.time包，包含多个类：用于获取指定时区的当前日期、时间的Clock、表示持续时间的Duration、表示具体时刻的Instant、不带时区的日期LocalDate、不带时区的时间LocalTime、不带时区的日期与时间LocalDateTime等。</p>
<p>###接口</p>
<p>java.io.Serilizable, Comparable, CharSequence, Cloneable，Iterator，Iterable，Comparator</p>
<p>Iterator接口提供了遍历Collection集合元素的统一编程接口，定义了四个方法：hasNext() next() remove() forEachReamining(Comsumer action)。</p>
<p>Comparable接口定义了一个compareTo(Oject obj)方法，实现该接口的类必须实现该方法，例如obj1.compareTo(obj2)，如果该方法返回0，则两个对象相等，如果返回正整数，则obj1&gt;obj2，如果返回负整数，则obj1&lt;obj2。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>java提供了集合类，集合类主要负责保存、盛装其他数据，因此也称为容器类，所有集合类都位于java.util包下。java.util.concurrent包下提供了一些多线程支持的集合类。</p>
<p>数组既可以保存基本类型的值，也可以是对象（实际上保存的是对象的引用变量），而集合里只能保存对象。</p>
<p>Java集合类主要有两个接口派生而出：Collection和Map，</p>
<p>Collection接口派生出元素不可重复的无序集合Set接口、队列Queue接口、元素可重复的有序集合List接口。</p>
<p>​    Set接口派生出EnumSet类、SortedSet接口、HashSet类。</p>
<p>​        SortedSet接口派生出TreeSet类。HashSet派生出LinkedHashSet类。</p>
<p>​    Queue接口派生出Deque接口、PriorityQueue类。</p>
<p>​        Deque接口派生出ArrayDeque类。</p>
<p>​    List接口派生出ArrayList类、Vector类。</p>
<p>​        Vector类派生出Stack类。</p>
<p>​    List接口和Deque接口派生出LinkedList类。</p>
<ol>
<li>Set<br>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
</ol>
<p>  HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p>
<p>  LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p>
<ol start="2">
<li>List<br>ArrayList：基于动态数组实现，支持随机访问。</li>
</ol>
<p>  Vector：和 ArrayList 类似，但它是线程安全的。</p>
<p>  LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，</p>
<p>  LinkedList 还可以用作栈、队列和双向队列。</p>
<ol start="3">
<li>Queue<br>LinkedList：可以用它来实现双向队列。<br>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
</ol>
<p><img src="JAVA%E5%AD%A6%E4%B9%A0.assets/image-20200924111125099.png" alt="image-20200924111125099"></p>
<p>Map实现类用于保存具有映射关系key-value的数据。</p>
<p>Map接口派生出EnumMap类、IdentityHashMap类、HashMap类、HashTable类、SortedMap类、WeakHashMap类。</p>
<p>HashMap线程不安全，key、value允许为null，派生出LinkedHashMap类。</p>
<p>HashTable线程安全，key、value不能为null，派生出Properties类。</p>
<p>SortedMap派生出TreeMap类。</p>
<p>TreeMap：基于红黑树实现。</p>
<p>HashMap：基于哈希表实现。</p>
<p>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p>
<p>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p>
<p>常用的集合有HashSet类、TreeSet类、ArrayList类、ArrayDeque类、LinkedList类、HashMap类、TreeMap类。</p>
<p>####Collection</p>
<p>Collection接口包含add(Object o) addAll(Collection c) clear() contains(Object o) containsAll(Collection c) isEmpty() iterator() remove(Object o) removeAll(Collection o) size() toArray()方法。</p>
<p>使用Iterator迭代访问Collecton集合元素时，集合内元素不能被改变，只能通过Iterator的remove()方法删除上一次next()方法返回的集合元素，否则将会引起java.util.ConcurrentModificationException异常。Iterator迭代器采用的是快速失败机制，一旦在迭代过程中检测到集合已经被修改（通常是其他线程修改），程序立即跑出异常，避免共享资源引发的潜在问题。</p>
<p>使用Iterator的forEachRemaining()方法或foreach循环迭代访问集合元素时，系统只是白集合元素的值赋值给了迭代变量，修改迭代变量的值对集合元素本身没有影响。</p>
<p>java8中Collecton集合新增了一个removeIf(Predicate filter)方法，该方法将批量删除符合filter条件的所有元素，例如删除集合nums中大于10的元素：nums.removeIf(num -&gt; ((Integer)num) &gt; 10)。</p>
<p>Java8中新增了Stream、IntStream、LongStrem等流式API，独立使用Stream的步骤是：1. 调用Stream的Builder()类方法创建该Strean对应的Builder。 2. 多次调用Builder的add()方法向该流中添加多个元素。 3. 调用Builder的build()方法获取对应的Stream。 4. 调用Stream的聚集方法。</p>
<p>Stream提供的聚集操作方法，可以是中间（intermediate）的，即操作之后返回值是另一个流，可以直接调用后续方法，也可以是末端（terminal）的，即操作之后该流会被消耗，且不可再用。常用的中间方法：filter(Predicate predicate)，mapToXxx(ToXxxFunction mapper)，peeek(Consumer action)，distinct()，sorted()等。末端方法：forEach(Consumer action)、toArray()、reduce()、min()、max()、count()、anyMatch(Predicate predicate)等、</p>
<p>Collection接口提供了一个stream()默认方法，用于可返回集合对应的流，再可以通过流式API来操作集合元素。</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ol>
<li><p>HashSet</p>
<p>使用Hash算法来存储集合中的元素，具有很好的存取和查找性能。不能保证元素排列顺序，不是同步的，集合元素值可以是null。</p>
<p>当向HashSet中存入一个元素时，HashSet会调用该对象的hashCode()方法获得该对象的hashCode值，然后根据该值确定对象的存储位置。HashSet集合判断两个元素相等的标准是两个对象的equals()方法比较相等，且hashCode()方法返回值也相等。</p>
<p>如果需要保存某个类的对象到HashSet集合中，重写这个类的equals()方法和hashCode()方法时，应保证equals()返回true时，hashCode()方法返回值也相等。如果两个对象的hashCode()方法返回的hashCode值相同，但equals()方法返回false，HashSet将使用链式结构这两个对象保存在同一个位置，导致性能下降。</p>
<p>将可变对象添加至HashSet后尽量不要修改该对象中参与计算hashCode() equals()的实例变量，否则会导致HashSet无法正确操作这些集合元素。</p>
</li>
<li><p>LinkedHashSet</p>
<p>LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用链表维护元素的次序，性能略低与HashSet，但在迭代访问中由于又链表维护内部顺序，因此性能更好。</p>
</li>
<li><p>TreeSet</p>
<p>TreeSet可以确保集合元素处于排序状态。因此具有额外的first()、last()、lower()、higher()、subSet()等方法。</p>
<p>TreeSet采用红黑树的数据结构来存储集合元素，支持自然排序（默认）和定制排序。</p>
<p>自然排序：TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系（判断相等时也是通过comparaTo，而不是equals），然后按升序排列。添加到TreeSet的对象的类必须实现Comparable接口，否则程序将会抛出异常。添加到TreeSet中的应该是同一个类的对象。</p>
<p>定制排序：创建TreeSet集合时提供一个Comparator对象，由该Comparator负责集合元素的排序逻辑。Camparator是一个函数式接口，包含一个int compare(T o1, T o2)方法，如果该方法返回正整数则，o1&gt;o2, 返回0，则o1=o2，返回负整数，则o1&lt;o2。</p>
</li>
<li><p>EnumSet</p>
<p>EnumSet中的所有元素都是指定枚举类型的枚举值。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。具有根据索引操作集合元素的方法：add\addAll\get\indexOf\lastIndex\remove\set\subList等。</p>
<p>List判断两个对象相等的标准是equals()方法返回true。</p>
<p>java8中List集合增加了sort(Comparator c)方法，用于对List集合的元素排序，replaceAll(UnaryOperator operator)方法，用于重新设置List集合中的元素。UnaryOperator是一个函数式接口，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定了替换集合元素的规则，将集合元素的长度作为新的集合元素</span><br><span class="line">books.replaceAll(book -&gt; ((String)book).length());</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="ArrayList和Vector"><a href="#ArrayList和Vector" class="headerlink" title="ArrayList和Vector"></a>ArrayList和Vector</h4><p>ArrayList和Vector都封装了一个动态的、允许再分配的Object[]数组。</p>
<p>ArrayList线程不安全，Vector线程安全，但Vector类是一个古老的集合，不推荐使用。Vector提供了一个Stack子类，用于模拟栈数据结构，但也因古老而不推荐使用，可以使用ArrayDeque。</p>
<p>Arrays工具类提供了asList(Object… a)方法，可以把一个数组或指定个数的对象转换成一个Arrays.ArrayList类的List集合，该集合的长度是固定的。</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue用于模拟队列这种数据结构，新元素插入(offer)到队列尾部，访问元素（poll）操作会返回队列头部的元素。</p>
<p>add/offer将元素加入到队列的尾部，element/peek获取头部元素，但不删除，remove/poll获取头部元素、</p>
<p>Queue接口具有PriorityQueue实现类，和Deque接口。Deque接口代表双端队列，可以从两端添加、删除元素，因此可以当成队列使用也可以当成栈使用，Deque具有ArrayDeque和LinkedList两个实现类。</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>PriorityQueue按照队列元素的大小进行重新排序，每次调用peak或poll方法取队列元素时，总是取出队列中最小的元素。如TreeSet类似，PriorityQueue支持自然排序和定制排序。</p>
<h4 id="Deque接口与ArrayDeque实现类"><a href="#Deque接口与ArrayDeque实现类" class="headerlink" title="Deque接口与ArrayDeque实现类"></a>Deque接口与ArrayDeque实现类</h4><p>Deque接口相比与Queue接口，增加了操作双端队列的方法，这类方法添加了后缀First和Last，表示是从队列开头还是末尾操作，例如addFirst/addLast、getFirst/getLast等。同时Deque接口还有具有pop/push方法，因此可以被当成栈来使用。</p>
<p>ArrayDeque实现了Deque接口，内部如ArrayList类似，采用动态可重分配的Object[]数组保存元素。可以当成栈数据结构来使用。</p>
<p>ArrrayDeque可以当成队列使用，按照先进先出的方式操作元素。</p>
<h4 id="LinkedList实现类"><a href="#LinkedList实现类" class="headerlink" title="LinkedList实现类"></a>LinkedList实现类</h4><p>LinkedList类实现了List和Deque接口，因此可以当成List集合、双端队列、栈来使用。</p>
<p>LinkedList内部以链表的形式来保存集合中的元素，因此随机访问性能较差，但在插入、删除元素时性能比较出色。</p>
<p>由于数组以一块连续内存区来保存所有的数组元素，因此数组在随机访问时性能最好。所有的内部以数组作为底层实现的集合在随机访问时性能比较好，内部以链表作为底层实现的集合在执行插入、删除操作时有比较好的性能。总的来说，ArrayList的性能比LinkedList的性能要好。如果要在多线程环境中访问List集合中的元素，可以使用Collections将集合包装成线程安全的集合。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map接口定义了常用方法：clear() containsKey(Object key) containsValue(Object value) entrySet()（返回Map中包含的key-value对所组成的set集合，每个集合元素都是Map.Entry对象） get(Object key) isEmpty() keySet() put(Object key, Object value) putAll(Map m) remove(Object key) size() values()。</p>
<p>Map包括一个内部类Entry，该类封装了key-value对，Entry包含getKey() getValue() setValue(V value)三个方法。</p>
<p>Map的实现类（HashMap、LinkedHashMap、SortedMap、TreeMap、EnumMap）和子接口中key集的存储形式和对应Set集合中元素的存储形式完全相同，实际上Java是先实现了Map，然后通过包装一个所有value都为null的Map就实现了 Set集合。3、</p>
<p>HashMap中判断两个key相等的标准是equals()方法返回true且hashCode值也相等。containsValue()方法判断value相等是根据对象的equals()方法。</p>
<p>LinkedHashMap使用双向链表维护key-value对的次序（其实只需考虑key的次序），因此性能略低于HashMap的性能。但在迭代访问时性能较好。</p>
<p>EnumMap中的所有key都是单个枚举类的枚举值。</p>
<p>HashMap是为了快速查询而设计的，TreeMap在插入和删除时更慢，因为TreeMap底层使用了红黑树来管理kv对，因此一般的应用场景下使用HashMap，当程序需要一个总是排好序的Map时使用TreeMap。LinkedHashMap比HashMap慢一点，因为它需要链表来保持kv对的添加顺序。</p>
<p>HashSet和HashMap采用Hash算法来决定集合中元素的存储位置。hash表中可以存储元素的位置被称为桶bucket，通常情况下单个桶里存储一个元素，此时hash算法直接根据hashCode值计算桶的位置，并取出元素，此时具有最好的性能。当发生hash冲突时，单个桶会存储多个元素，这些元素以链表形式存储，必须按顺序搜索。</p>
<p>HashSet和HashMap的Hash表具有如下属性：1. 容量capacity，hash表中桶的数量。 2. 初始化容量initial capacity，创建hash表时的容量，两者都可以在构造器中指定初始化容量。 3. 尺寸size，当前hash表中的记录。 4.负载因子load factor，即size/capacity，负载越小的hash表的冲突少，适宜插入和查询。 5. 负载极限，当负载因子达到指定的负载极限时，hash表会自动成倍地增加容量，并重新分配原有对象至新的桶内，称为rehashing。</p>
<h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>Collections是一个操作Set、List和Map等集合的工具类，提供了排序、查询、修改等操作，以及将集合对象设置为不可变、对集合对象实现同步控制等方法。</p>
<p>排序：reverse sort swap rotate shuffle等。</p>
<p>查询与替换：binarySearch max min fill frequency replacyAll等。</p>
<p>同步控制：Collections类提供了多个synchronizedXxx()方法将指定集合Xxx包装成线程同步的集合，解决多线程并发访问集合时的线程安全问题。常用的集合框架的实现类HashSet、TreeSet等都是线程不安全的。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>参数化类型parameterized type允许程序在创建集合时指定集合元素的类型，称为泛型generic。泛型允许在定义类、接口、方法时使用类型形参，这个类型形参在声明变量、创建对象、调用方法时动态指定（即传入实际的类型参数，也可称为类型实参）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E x)</span></span>;</span><br><span class="line">	<span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用带泛型声明的接口和父类时，接口和父类不能在包含类型形参。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码是错误的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Apple</span>&lt;<span class="title">T</span>&gt; </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生子类时需要为Apple类的T形参传入类型参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Apple</span>&lt;<span class="title">String</span>&gt; </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>从指定了类型形参的父类/接口中派生子类，父类/接口中所有使用类型形参的地方都会被替换成指定的类型实参，例如从Apple&lt;String&gt;派生子类，它的子类会继承到String getInfo()方法（Apple&lt;T&gt;中包含T getInfo()方法）。</p>
<p>如果在派生子类时没有传入实际的类型参数（public class A extends Apple {}），代码能正确编译，但编译器可能发出泛型检查的警告：使用了未经检查或不安全的操作。</p>
<p>系统并没有为每个不同类型实参生成新的类（即没有生成新的class文件），因此指定了不同类型实参的同一种类是同一个类，其getClass()方法值相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; l1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 以下等式为true</span></span><br><span class="line">l1.getClass() == l2.getClass()			</span><br></pre></td></tr></table></figure>

<p>不管为泛型的类型参数传入哪一种类型实参，java依然把它们当成同一个类处理，在内存中也只占用一块内存空间，因此在静态方法、静态初始化块和静态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以instanceof运算符后面不能使用泛型类。</p>
<p>如果Foo是Bar的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G&lt;Foo&gt;并不是G&lt;Bar&gt;的子类型，而Foo[]是Bar[]的子类型。</p>
<p>泛型可以使用类型通配符（一个问号）表示可以匹配任何类型，例如元素类型未知的List可以写作List&lt;?&gt;、但这样使用类型通配符定义的List不能添加对象（null除外），因为List&lt;E&gt;接口定义中，add(E x)方法有类型参数E作为集合元素的元素类型，所以传给add的参数必须是E类的对象或其子类的对象，而此处程序无法确定集合中元素的类型，只能读取元素。</p>
<p>受限通配符List&lt;? extends C&gt; list表示此处的未知类型只能匹配C类及其子类，称C为这个通配符的上限。定义类型形参时同样可以设定上限Apple&lt;T extends Number&gt;，类型形参只能有一个父类上限，可以有多个接口上限，表明该类型形参必须是其父类的子类或父类，并且实现多个上限接口，例如Apple&lt;T extends Number &amp; java.io.Serializable&gt;。与类同时继承父类、实现接口类似，接口上限必须位于类上限之后，及类上限必须位于第一位。</p>
<p>受限通配符&lt;? super Type&gt;表示此处的未知类型只能匹配Type本身或其父类。</p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>泛型方法是指在声明方法是定义一个或多个类型形参，用法如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰符 &lt;T,S&gt; 返回值类型 方法名(形参列表) &#123;</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="keyword">static</span> &lt;T, E&gt; <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T[] a, List&lt;E&gt; c)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在声明时定义T类型形参后，这个T类型形参就可以在方法内当成普通类型使用。与类、接口中使用的泛型参数不同的是，方法中的泛型参数无须显式传入实际类型参数，编译器会根据实参推断出类型形参的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &lt;T extends E&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? extends T&gt; from, List&lt;T&gt; to)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述copy方法将from列表中的元素复制到to列表中，只要from列表中的元素类型是to列表中的元素类型的子类或同类即可。</p>
<p>如果类型形参用来表示多个参数之间、方法返回值与参数之间的类型依赖关系，则使用泛型方法，否则使用类型通配符。</p>
<p>泛型构造器是指在构造器签名中声明类型形参，一旦定义了泛型构造器，则在调用该构造器时，可以让java根据数据参数的类型来推断类型参数的类型<code>new foo(1)</code>，也可以由程序员显式地为构造器中的类型参数指定实际类型<code>new &lt;Integer&gt; foo(1)</code>。</p>
<p>使用带泛型声明的类时可以不指定实际的类型参数，则该类型参数被称作raw type，默认是声明该类型参数时指定的第一个上限类型（如果是&lt;T extends E&gt;，则不指定&lt;T&gt;参数时默认是E，如果是&lt;T&gt;，则不指定时是Object。</p>
<p>当把一个具有泛型信息的对象赋给一个没有泛型信息的变量时，会丢失泛型信息，例如把List&lt;String&gt;类型转换成List时，List对集合元素的类型检查变成了类型参数的上限（即Object），此即擦除。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>java的异常处理机制依赖于try catch finally throw throws关键字，try关键字后紧跟一个花括号括起来的代码块，用于放置可能引发异常的代码，catch后对应异常类型和一个代码块，用于表明该catch块用于处理这种异常类型的代码块，多个catch块后跟一个finally块，异常机制保证finally块总被执行，可用于回收try块中打开的物理资源等。throws用于在方法签名中声明该方法可能会抛出的异常。throw用于抛出一个实际的异常，即具体的异常对象。</p>
<p>java将异常分为Checked异常和Runtime异常，Checked异常都可以在编译阶段被处理，所以强制程序处理。</p>
<p>运行时异常，例如用户输入错误、操作系统故障、硬件故障、网络故障等在编写代码时不可预估的错误。</p>
<p>异常处理机制将业务功能实现代码和错误处理代码分离，提供更好的可读性。</p>
<p>系统在执行任何代码块时出现异常，总会自动生成一个异常对象，该异常对象被提交给java运行时环境，称为抛出throw异常。java运行时环境收到异常对象后，会寻找处理该异常对象的catch块，如果找到则把该异常对象交给该catch块处理，称为捕获catch异常。如果找不到捕获异常的catch块，则运行时环境终止，java程序退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  statement1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionClass1 e1) &#123;</span><br><span class="line">  exception handler statement1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionClass2 e2) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java运行时环境接收到异常对象后，会依次判断异常对象是否是catch块后异常类或其子类的实例，如果是，则调用该catch块处理异常，否则再继续与后一个catch块进行判断。进入catch块时，系统自动生成的异常对象ex将会传给catch块后的异常类型形参，从而允许catch块通过该对象获得异常的详细信息。进入catch块后不会再继续向下执行其他catch块。</p>
<p>多个catch块可以避免使用if switch判断异常类型，但依然可以针对不同的异常类型提供响应的处理逻辑。</p>
<p>try块和catch块的花括号不能省略，try块中定义的变量属于代码块内局部变量，只在try块内有效。</p>
<p>java提供的异常类有严格的继承关系，java将所有非正常情况分为异常Exception和错误Error，两者都继承自Throwable父类，Error是指与虚拟机相关的问题，例如系统奔溃、虚拟机错误、动态连接失败等，这类错误不可恢复或者不可能被捕获，将导致程序退出。</p>
<img src="JAVA%E5%AD%A6%E4%B9%A0.assets/image-20200926203434656.png" alt="image-20200926203434656" style="zoom:80%;" />

<p>异常捕获时，所有父类异常的catch块都应该排在子类异常的catch块前，即先捕获小异常，再捕获大异常。</p>
<p>java7开始支持多异常捕获，一个catch块可以捕获多种类型的一场，多种异常类型之间用竖线|分隔<code>catch (ExceptionA | ExceptionB e)</code>，异常变量e隐式使用final修饰。</p>
<p>所有异常对象提供了如下几个常用方法：getMessage()返回该一场的详细描述字符串，printStackTrace()将该一场的跟踪栈信息输出到标准错误输出，getStackTrace()返回该异常的跟踪栈信息。</p>
<p>java的垃圾回收机制不会回收任何物理资源。</p>
<p>在try或catch块中执行return语句后，依然会执行finally块，但调用System.exit(1)语句退出虚拟机则不会执行finally块。</p>
<p>Java程序执行到try或catch块中的return或throw语句时，并不会马上执行而结束该方法，而是去寻找该异常处理流程中是否包含finally块，如果没有则立即执行return语句或throw语句，方法终止，否则执行finally块，当finally块执行完成后再执行try或catch块中的return或throw方法。如果finally块中使用了return或throw等导致方法终止的语句，则直接结束方法，而不会再执行try或catch块中的任何代码，因此要尽量在finally块中使用return或throw语句。</p>
<p>异常处理流程代码可以在任何可执行代码的代码，因此异常处理支持嵌套。</p>
<p>java7之后，try后紧跟一对圆括号，圆括号内可声明、初始化一个或多个必须在程序结束时显示关闭的资源，例如数据库连接和网络链接等，try语句在结束时将自动关闭这些资源。要实现自动关闭，这些资源实现类必须实现AutoCloseable或Closeable接口，这两个接口中定义了close()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">	BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;a.java&quot;</span>));</span><br><span class="line">	PrintStream ps = ....</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Closeable是AutoCloseable的子接口，Closeable接口的close()方法声明抛出了IOException，因此它的实现类实现该方法时只能抛出IOException或其子类，而AutoCloseable接口的close()方法声明抛出了Exception。</p>
<p>由于自动关闭资源的try块隐式包含了用于关闭资源的finally快，因此该try块可以没有catch块和finally块。java7几乎所有资源类都实现了AutoCloseable或Closeable接口。</p>
<p>java的异常分为Checked异常（其他异常）和Runtime异常（RuntimeException类及其子类），java程序必须显式处理Checked异常，否则编译器报错。Checked异常的处理方式有两种：使用try\catch块处理异常，在定义该方法时声明抛出异常。</p>
<p>当前方法不知道如何处理这种类型的异常，该异常应该由上一级调用者处理，即调用该方法时要么放在try块中显式捕获该异常，要么放在另一个带throws声明的抛出的方法中。如果main方法也不知道如何处理，则交给JVM处理。JVM处理一场的方法是：打印异常的跟踪栈信息，并中止程序运行。</p>
<p>方法签名中使用throws声明抛出多个异常类，多个异常类之间以逗号隔开。一旦使用throws抛出异常，程序就无须使用try/catch块来捕获该异常。</p>
<p>子类方法声明抛出的异常类型应该是父类方法声明抛出的异常类型的子类或相同，并且子类方法声明抛出的异常不允许比父类方法声明抛出的异常多。</p>
<p>使用throw主动抛出异常，每次只能抛出一个异常实例。如果throw抛出的异常是Checked异常，则该throw语句要么处于try块里，显式捕获该异常，要么放在一个带有throws声明的方法中，由该方法的调用者处理异常。如果throw语句抛出的是Runtime异常，则没有限制。</p>
<p>用户自定义异常类需要继承Exception基类或其子类，并且需要提供一个无参数的构造器和一个带有字符串参数的构造器，这个字符串将作为该异常对象的描述信息，也就是异常对象的getMessage()方法的返回值。通常，自定义异常类可如下定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionA</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ExceptionA</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ExceptionA</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(msg)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 所有Throwable的子类在构造器中都可以接收一个原始异常对象作为参数，从而把原始异常传递给新的异常。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExceptionA</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(t)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在异常出现的当前方法中，程序只在catch块中对异常进行部分处理，并使用throw语句再次抛出异常，让该方法的调用者进行进一步的处理。</p>
<p>把底层的原始错误直接传给用户是一种不负责任的表现，通常程序先捕获原始异常，然后抛出一个包含对用户的提示信息的新的业务异常，这称为异常转译。把原始异常隐藏起来，仅向上提供必要的异常提示信息的处理方式，保证底层异常不会向上扩散，避免向上暴露太多实现西昌，符合面向对象的封装原则。这种把捕获一个异常然后抛出另一个异常，并把原始异常信息保存下来是一种典型的链式处理，也称为异常链。</p>
<p>成功的异常处理应该实现：使代码混乱最小、捕获并保留诊断信息、通知合适人员，采用合适的方式结束异常。异常处理的基本准则：</p>
<ol>
<li>异常处理机制的初衷是将不可预期异常的处理代码和正常的业务逻辑处理代码分离，对于完全可与之而处理方式清楚的错误，应该提供相应的错误处理代码。</li>
<li>不要在try块中放置大量的代码。</li>
<li>避免在一个catch块中处理所有可能异常。</li>
<li>捕获到异常后应该采取适当措施，例如：在catch块中对异常进行修复，使程序继续运行。或者在catch块中重新抛出新的异常，由上层调用者处理。或者不适用catch块，直接使用thorws声明抛出该异常，由上层调用者负责处理。</li>
</ol>
<p>###注释</p>
<p>Annotation注释，其实就是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用注释，程序开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或进行部署。</p>
<p>Annotation能被用来为程序元素（包、类、构造器、方法、成员变量、参数、局部变量）设置元数据，不影响程序代码的执行。</p>
<p>@Override用来指定方法覆盖，它可以强制一个子类必须覆盖父类的方法，作用是告诉编译器检查这个方法，保证父类要包含一个被该方法重写的方法，否则会编译出错。</p>
<p>@Deprecated用于表示某个程序元素（类、方法等）已经过时，当其他程序使用已过时的类、方法时，编译器将会给出警告。</p>
<p>@SuppressWarnigs指示被该注释修饰的程序元素以及该程序元素中的所有子元素取消显示指定的编译器警告。</p>
<p>@SafeVarargs：把一个带泛型的对象赋给一个不带泛型的变量，或反之，都会产生堆污染警告，@SafeVarargs用于抑制这种警告。</p>
<p>@FunctionalInterface用来指定某个接口必须是函数式接口，否则报错。</p>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>java的IO是通过java.io包下的类和接口来支持，主要包括输入、输出两种IO流，每种流又可以分为字节流和字符流，其中字节流以字节为单位来处理，字符流以字符来处理。JAVA的IO流使用一种装饰器设计模式，它将IO流分为底层节点流和上层处理流，其中节点流用于和底层的物理存储节点直接关联，不同的物理节点获取字节流的方式可能存在一定的差异，但程序可以把不同的物理节点流包装成统一的处理流，从而隐藏底层设备上节点流的差异，允许程序使用统一的输入、输出代码来读取不同物理存储节点的资源。</p>
<p>File类是java.io包下代表与平台无关的文件和目录，File类不能访问文件内容本身，需要使用输入/输出流访问。File类可以使用文件路径字符串来创建File实例，路径可以是绝对路径，也可以是相对于用户工作路径（通常是java虚拟机所在路径）的相对路径。</p>
<p>java中把不同的输入/输出源（键盘、文件、网络连接等）抽象表述为流stream，通过流的方式允许java使用相同的方式来访问不同的输入/输出源，stream是从起源source到接收sink的有序数据。</p>
<p>读取数据的称为输入流，写入数据的称为输出流。划分输入/输出流是从程序运行所在的内存的角度来考虑的。</p>
<p>字节流操作的数据单元是8位字节，主要由InputStream和OutputStream作为基类，字符流操作的数据单元是16位字符，主要由Reader和Writer作为基类。这些基类是抽象基类，无法直接创建实例。</p>
<p>InputStrem和Reader包含方法：int read()从输入流中读取单个字节或字符，返回所读取的字节或字符数据, int read(byte[] b/char[] cbuf)从输入流中最多读取数组b或cbuf长度个字节或字符的数据，并存储在数组b或cbuf中，返回实际读取的字节或字符数, int read(byte[] b/char[] cbuf, int off, int len)从输入流中最多读取len个字节或字符的的数据，并将其存储在数组b或cbuf off位置处，返回实际读取的字节或字符数。</p>
<p>OutputStrem和Writer包含的方法与上面的几乎一致。void write(int c), void write(byte[]/char[] buf), void write(byte[]/char[] buf, int off, int len), void write(String str), void write(String str, int off, int len).</p>
<p>从/向一个特定的IO设备（磁盘、网络等）读写数据的流，称为节点流，程序直接连接到实际的数据源，和实际的输入/输出节点连接。处理流则用于对一个已存在的流进行链接或封装，通过封装后的流来实现数据读写功能，不会直接连接到实际的数据源，没有和实际的输入/输出节点连接。这是一种装饰器设计模式，通过使用处理流来包装不同的节点流，可以消除不同节点流的实现差异。</p>
<p>JAVA7之后的所有IO资源类都实现了AutoCloseable接口，可以通过自动关闭资源的try语句来关闭这些IO流。</p>
<p>使用处理流的典型思路是：使用处理流来包装节点流，程序通过处理流来执行输入/输出功能，让节点流与底层的IO设备/文件交互。以物理IO节点作为构造器参数的流属于节点流，以已存在的流作为构造器参数的是处理流。关闭最上层的处理流时，系统会自动关闭被该处理流包装的节点流。</p>
<p><img src="JAVA%E5%AD%A6%E4%B9%A0.assets/image-20201008153116922.png" alt="image-20201008153116922"></p>
<p>访问数组时有一种以数组为物理节点的节点流，字节流/字符流分别以字节/字符数组为节点，在创建这类节点流时，需要传入一个字节或字符数组，其他用法与文件节点流完全相似。字符流还可以使用字符串作为物理节点，或将内容写入字符串（StringBuffer充当字符串）。</p>
<p>创建StringReader和StringWriter对象时传入的是字符串节点，而不是文件节点，由于String是不可变的字符串对象，所以StringWriter使用StringBuffer作为输出节点，调用StringWriter的toString()方法得到输出字符串。</p>
<p>访问管道的流用于实现进程间通信。</p>
<p>缓冲流增加了缓冲功能，可以提高输入、输出的效率，增加缓冲功能后需要使用flush()才可以将缓冲区的内容写入实际的物理节点。</p>
<p>对象流主要用于实现对象的序列化。</p>
<p>转换流主要用于将字节流转换为字符流，InputStreamReader将字节输入流转换为字符输出流，OutputStreamWriter将字节输出流转换为字符输出流。</p>
<p>java使用System.in代表标准输入，即键盘输入，这个标准输入流是InputStream的实例，可以使用InputStreamReader将其转换为字符输入流，再使用BufferReader将其转换为带缓冲的流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">BufferedRead br = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">line = br.readLine()</span><br></pre></td></tr></table></figure>

<p>推回输入流PushBackInputStream和PushBackReader提供了unread(byte[]/char[] buf)将一个字节/字符数组中的内容推回到缓冲区，从而允许重复读取。unread(byte[]/char[] b, int off, int len)将一个字节/字符数组里从off开始，长度为len字节/字符的内容推回到缓冲区里，从而允许重复读取。unread(int b)将一个字节/字符推回缓冲区，从而允许重复读取。</p>
<p>推回输入流带有一个推回缓冲区，推回输入流每次调用read()方法是总是先从推回缓冲区读取，不够时再从原始输入流中读取。调用unread()方法时，系统会把指定数组的内容推回到该缓冲区里。</p>
<p>通常如果输出文本内容，都应该将输出流包装成PrintStream后进行输出。</p>
<p>Java的标准输入和输出分别通过System.in和System.out来代表，默认情况下代表键盘和显示器。通过System.in来获取输入时，实际上是从键盘读取输入，通过System.out执行输出时，程序总是输出到屏幕。可以通过setErr/setIn/setOut来重定向标准错误输出流、标准输入流、标准输出流。</p>
<p>RandomAccessFile支持自由定位文件记录指针来访问文件的任意位置，可以读取文件内容，也可以向文件输出数据（在文件尾部追加内容，而不能直接在文件的指定位置插入内容，这样新的内容会覆盖文件中原有的内容，一个解决办法是将插入点后面的内容读入缓冲区，插入完数据后再将缓冲区中的内容追加到文件后面）。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>对象序列化机制允许把内存中的java对象转换成平台无关的二进制流。从而允许把这种二进制流持久地保存在磁盘上，或通过网络进行传输。其他程序一旦获得这种二进制流，都可以将其恢复成原来的java对象。</p>
<p>对象的序列化Serialize指将一个java对象写入IO流，对象的反序列化Deserialize则指从IO流中恢复该JAVA对象。</p>
<p>为了让某个类是可序列化的，则该类必须实现Serializable或Externalizable接口。Serializable接口是一个标记接口，实现该接口无须实现任何方法。</p>
<p>序列化对象步骤：创建一个ObjectOutputStream，这是一个处理流，必须建立在其他节点流的基础上。调用ObjectOutputStream对象的writeObject()方法输出可序列化对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">Person per = <span class="keyword">new</span> Person(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStrem(<span class="keyword">new</span> FileOutputStrem(<span class="string">&quot;object.txt&quot;</span>));</span><br><span class="line">oos.write(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.txt&quot;</span>));</span><br><span class="line">Person p = (Person)ois.readObject();</span><br></pre></td></tr></table></figure>

<p>反序列化读取的仅仅是Java对象的数据，而不是Java类，因此采用反序列化恢复Java对象时，必须提供该Java对象所属类的class文件，否则会引发ClassNotFoundException异常。</p>
<p>反序列化机制无需通过构造器来初始化Java对象。</p>
<p>用序列化机制向一个文件中写入多个Java对象，使用反序列化机制恢复对象时必须按实际写入的顺序读取。</p>
<p>当一个可序列化类有多个父类（直接父类或间接父类），这些父类要么有无参数的构造器，要么也是可序列化的，否则反序列化时将抛出InvalidClassException异常。如果父类不可序列化，但带有无参数的构造器，则该父类中定义的成员变量值不会序列化到二进制流中。</p>
<p>如果某个类的成员变量是引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型成员变量的类也是不可序列化的。</p>
<p> Java序列化机制采用了一种特殊的算法：所有序列化的对象都有一个序列化编号，当程序试图序列化一个对象时，会先检查是否已经序列化过，如果从未被序列化过，则系统将该对象转换成字节序列并输出，否则系统只是直接输出一个序列化编号，而不是再次重新序列化该对象。</p>
<p>java序列化机制序列化可变对象时，只有第一次调用writeObject()方法时才会将对象转换成字节序列，并写入到ObjectOutputStream，后续即使该对象的实例变量发生改变，再次调用writeObject()方法时，改变后的实例变量也不会被输出。</p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>java.io下输入流、输出流都是阻塞式的输入输出，并且都是通过字节移动来处理，一次只能处理一个字节，效率不高。</p>
<p>NIO采用内存映射的方式来处理输入输出，将文件或文件的一段区域映射到内存中，从而像访问内存一样来访问文件。</p>
<p>java.nio包含各种与Buffer相关的类，java.nio.channels包含与Channel和Selector相关的类，java.nio.charset包含与字符集相关的类。</p>
<p>Channel和Buffer是NIO中的两个核心对象，Channel是对传统的输入输出流的模拟，NIO中的所有数据都需要通过Channel传输，Channel与Stream的区别在于它提供了一个map方法，将一块数据映射到内存中。传统的输入输出是面向流的，则NIO是面向块的处理。Buffer可以被理解为一个容器，本质是一个数组，发送至Channel或从Channel中读取的数据都必须先放到Buffer中。可以从Channel中单个字节的读取，也可以直接使用Channel直接将文件的某块数据映射成Buffer。</p>
<p>####Buffer</p>
<p>Buffer有ByteBuffer、CharBuffer、ShortBuffer等，Buffer没有提供构造器，只能通过static XxxBuffer.allocate(int capacity)创建一个容量为capacity的XxxBuffer对象。ByteBUffer的一个子类MappedByteBuffer用于表示Channel将文件的部分或全部内容映射到内存中后得到的结果，通常由Channel的map()方法返回。</p>
<p>Buffer中的容量capacity表示该Buffer可存储的最大数据量，界限limit表示该Buffer中limit后的数据既不可读也不可写，位置position用于指明该Buffer中下一个可读或可写的位置索引。buffer的主要作用是装入、输出数据。初始时，positon为0，limit为capacity，程序通过put()方法向buffer中放入一些数据，或者从Channel中获取，每放入一些数据，position相应的向后移动。装入数据结束后，调用buffer的flip()方法，将limit设为当前position的位置，并将position设置为0，为输出数据做好准备。数据数据结束后，调用buffer的clear()方法，将position设置为0，limit设置为capacity，为再次装入数据做准备。</p>
<p>Buffer提供put()和get()方法，用于向Buffer中放入、读取数据，可以单个访问，也可以通过数组批量访问。可以采取相对Relative访问方式，该方式从position处开始读取或写入数据，并将position按处理元素的个数增加，也可以采取绝对Absolute访问方式，直接根据索引向buffer中读取或写入数据，不影响position的值。</p>
<p>ByteBuffer还提供了allocateDirect()方法来创建直接Buffer，直接Buffer的创建成本比普通Buffer创建成本更高，但读取效率更高，适用于长生存期的Buffer。</p>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Channel可以直接将指定文件的部分或全部直接映射成Buffer，程序不能直接访问Channel中的数据，必须通过Buffer，即读取时，先用Buffer从Channel取出一些数据，然后从Buffer读取数据，写入时，先将数据放入Buffer，在将Buffer中的数据写入Channel。</p>
<p>Channel接口有DatagramChannel、FileChannel、Pipe.SinkChannel、ServerSocketChannel、SocketChannel等实现类。所有Channel都不应该通过构造器直接创建，而是通过传统节点InputStream、OutputStream的getChannel()方法返回对应的Channel。</p>
<p>Channel中常用的方法是map()、read()和write()，MappedByteBuffer map(FileChannel.MapMode mode, long position, long size)用于将Channel对应的数据（position开始，长度为size）映射成ByteBuffer，mode参数便是映射时的模式，有只读、读写等模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStrem(f);</span><br><span class="line">FileChannel inChannel = fis.getChannel();</span><br><span class="line">MappedByteBuffer buffer = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, f.length());</span><br><span class="line">FileChannel outChannel = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>).getChannel();</span><br><span class="line">outChannel.write(buffer)</span><br></pre></td></tr></table></figure>



<p>将字符序列转换成二进制序列称为编码Encode，将二进制序列转换成字符序列成为解码Decode。</p>
<p>使用文件锁可以有效阻止多个进程并发修改同一个文件。</p>
<p>NIO中的FileChannel提供了lock()/tryLock()方法，lock()方法是阻塞式的，如果无法得到文件锁，则程序将一直阻塞，tryLock()是尝试锁定文件，如果获得文件锁则返回该文件锁FileLock，否则返回null。两种方法中有share参数，为true时表示该锁是一个共享锁，允许多个进程读取该文件，但阻止其他进程获得对该文件的排他锁，为false时表示该锁是一个排他锁，它将锁住对该文件的读写。处理完文件后可通过FileLock的release()方法释放文件锁。</p>
<p>NIO.2</p>
<p>NIO.2提供了全面的文件IO和文件系统访问支持，表现为新增的java.nio.file包及各个子包。还提供了基于异步Channel的IO，表现为在java.nio.channels包下增加了多个以Asynchronous开头的Channel接口和类。</p>
<p>NIO.2引入了代表一个平台无关的平台路径的Path接口，提供了Files\Paths两个工具类，Files包含大量静态的工具方法来操作文件，大大地简化了文件IO。</p>
<h3 id="类的加载、连接和初始化"><a href="#类的加载、连接和初始化" class="headerlink" title="类的加载、连接和初始化"></a>类的加载、连接和初始化</h3><p>使用java命令运行某个java程序时，系统会启动一个java虚拟机进程，同一个JVM的所有线程和变量都处于同一个进程里，都使用该JVM进程的内存区。当系统遇到：1. 程序正常结束， 2. 程序调用System.exit()或Runtime.getRuntime.exit()结束程序， 3. 程序遇到未捕获的异常或错误而结束， 4. JVM进程被强制结束时，JVM进程被终止。</p>
<h4 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h4><p>类的加载是将类的class文件读入内存，并创建一个java.lang.Class对象。类的加载由类加载器完成，JVM提供的类加载器通常成为系统类加载器，开发者可以通过继承ClassLoader基类来创建自己的类加载器。通过使用不同的类加载器可以从不同来源加载类的二进制数据：本地文件系统加载class文件、从JAR包中加载class文件，通过网络加载class文件，动态编译Java源文件并加载。</p>
<p>java虚拟机规范允许系统预先加载某些类。</p>
<h4 id="类的连接"><a href="#类的连接" class="headerlink" title="类的连接"></a>类的连接</h4><p>类被加载之后便就进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中，类连接又可以分为：</p>
<p>验证： 验证加载的类是否有正确的内部结构，并和其他类协调一致。</p>
<p>准备：为类的类变量分配内存，并设置默认初始值。</p>
<p>解析：将类的二进制数据中的符号引用替换成直接引用。</p>
<h4 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h4><p>类的初始化阶段，虚拟机对类进行初始化，主要是对类变量进行初始化：声明类变量时指定初始值，或使用静态初始化块为类变量指定初始值。这两种方式都是类的初始化语句，JVM按这些语句在程序中的排列顺序依次执行它们。</p>
<p>JVM初始化一个类包含如下几个阶段：</p>
<p>1， 如果类还没被加载和连接，则先加载并连接该类。</p>
<ol start="2">
<li>如果该类的直接父类还没有被初始化，则先初始化其直接父类（继续上溯直接父类的直接父类，直至该类的直接父类和所有间接父类都被初始化，因此最先初始化的总是java.lang.Object类）。</li>
<li>如果该类有初始化语句，则执行初始化语句。</li>
</ol>
<p>当java程序首次通过以下方式使用某个类或接口时，系统就会初始化该类或接口：</p>
<ol>
<li>通过new操作符、反射、反序列化来创建类的实例。</li>
<li>调用某个类的类方法（静态方法）。</li>
<li>访问某个类或接口的类变量，或为该类变量赋值。</li>
<li>使用反射强制创建某个类或接口对应的java.lang.Class对象。</li>
<li>初始化某个类的子类。</li>
<li>直接使用java.exe命令运行某个主类。</li>
</ol>
<p>final类型的类变量的值如果在编译时就可以确定，则该类变量相当于宏变量，java编译器会在编译时直接把这个类变量出现的地方替换成它的值，因此即使程序使用该静态类变量，也不会导致该类的初始化。</p>
<p>ClassLoad的loadClass()方法只加载某个类，不会执行该类的初始化，使用Class的forName方法时才会导致强制初始化该类。</p>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>类加载器负责加载所有类，每一个被载入内存中的类都会生成一个java.lang.Class实例，一个类只会加载一次。在JVM中一个类用其全限定类名（包括包名和类名）和其类加载器作为其唯一标识。</p>
<p>JVM启动时会形成由三个类加载器组成的初始类加载器层次结构（父子关系）：</p>
<ol>
<li>Bootstrap ClassLoader：根类加载器，也称为引导、原始或根类加载器，负载加载Java的核心类。它并不是java.lang.ClassLoader的子类，而是由JVM自身实现。</li>
<li>Extension ClassLoader：扩展类加载器，负责加载JRE的拓展目录。</li>
<li>System ClassLoader：系统类加载器，负载在JVM启动时加载来自java命令的的classpath选项、java.class.path系统属性、CLASSPATH环境变量所指定的JAR包和类路径。默认情况下，用户自定义的类加载器都以系统类加载器作为父加载器。</li>
<li>用户类加载器</li>
</ol>
<p>JVM中除根类加载器之外的所有类加载器都是ClassLoader子类的实例，开发者可以通过拓展ClassLoader的子类，并重写该ClassLoader所包含的方法来实现自定义的类加载器。</p>
<p>JVM的类加载器机制有三种：</p>
<ol>
<li>全盘负责，由同一个类加载器负责加载某个类及其所依赖和引用的其他类。</li>
<li>父类委托，先由父类加载器尝试加载，加载失败时才尝试从自己的类路径中加载。</li>
<li>缓冲机制，缓冲所有加载过的Class，当程序需要使用时，类加载器先从缓冲区中搜寻，搜寻不到时再读取该类对应的二进制数据，并将其转换为Class对象。</li>
</ol>
<p>类加载器加载Class大致要经过如下8个步骤：</p>
<ol>
<li>检测此Class是否被载入过，即在缓冲区中是否有此Class，如果有则进入第8步，否则继续。</li>
<li>如果父类加载器不存在（此时，要么parent一定是根类加载器，要么本身就是根类加载器），则执行第4步，否则继续。</li>
<li>请求父类加载器加载，如果成功则进入第8步，否则执行第5步。</li>
<li>请求根类加载器加载，如果成功则进入第8步，否则执行第7步。</li>
<li>当前类加载器尝试寻找Class文件，如果找到则执行第6步， 否则执行第7步。</li>
<li>从文件中载入Class，成功后执行第8步。</li>
<li>抛出ClassNotFoundException异常。</li>
<li>返回对应的java.lang.Class对象。</li>
</ol>
<p>其中第5、6步允许重写ClassLoader的findClass()方法来实现自己的载入策略，甚至重写loadClass()方法来实现自己的载入过程。通常推荐重写findClass()方法。findClass()方法根据指定名称来查找类，loadClass()方法是ClassLoader的入口点，根据指定名称来加载类，系统就是调用该方法来获取指定类对应的Class对象。</p>
<p>ClassLoader下的Class defineClass(String name, byte[] b, int off, int len)方法用于将指定类的字节码文件（Class文件，可来源于文件、网络等）读入字节数组b内，并将字节码分析成运行时数据结构、校验有效性等，最终返回对应的Class对象。该方法由final修饰，不可重写。</p>
<h3 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h3><p>java程序中的对象在运行时会出现两种类型：编译时类型和运行时类型。</p>
<p>每个类被加载后，系统会为该类生成一个Class对象，通过该Class对象就可以访问到JVM中的这个类，java程序获得Class对象通常有如下三种方式：</p>
<ol>
<li>使用Class类的forName(String clazzName)静态方法，clazzName的值是某个类的全限定类名。</li>
<li>调用某个类的class属性来获取该类对应的Class对象，例如Person.class。</li>
<li>调用某个对象的getClass()方法，返回该对象所属类对应的Class对象。</li>
</ol>
<p>Class类提供了大量方法来获取该Class对象所对应类的详细信息，例如通过getConstructors\getMethods\getFields等来得到Method\Constructor\Field等对象，分别代表方法、构造器和成员变量。再通过这些对象来执行实际的功能，例如调用方法、创建实例。</p>
<p>java8在java.lang.reflect包下新增了一个代表可执行的类成员的Executable抽象基类，该类派生出Constructor、Method子类，该类提供了大量方法来获取相关信息。</p>
<p>javac命令编译java源程序时，默认生成的class文件并不包含方法的形参名信息，可以在编译程序时为javac命令添加-parameters选项来保留形参信息。</p>
<h4 id="使用反射操作对象"><a href="#使用反射操作对象" class="headerlink" title="使用反射操作对象"></a>使用反射操作对象</h4><p>通过反射来生成对象有如下两种方式：</p>
<ol>
<li><p>使用Class对象的newInstance()方法来创建该Class对象的实例，该方法利用默认构造器来创建对象实例。</p>
</li>
<li><p>使用Class对象的getConstructor()方法获取指定的Constructor构造器对象，再调用Constructor对象的newInstance()方法来创建该Class对象的实例。该方法能使用指定的构造器来创建实例。</p>
</li>
</ol>
<p>通过Class对象的getMethod/getMethods方法获取该类所包含的指定或全部成员方法，即Method对象，每个Method对象对应一个方法，程序通过该Method对象的invoke(Object obj, Object… args)来调用它对应的方法，其中obj是执行该方法的主调，args是执行该方法时传入的实参。</p>
<p>通过Method的invoke()方法调用对应方法时，java要求程序必须要有调用该方法的权限。如果需要调用某个对象的private方法，则先调用Method对象的setAccessible(boolean flag)方法将该Method对象的accessible设置为指定的布尔值，flag为true时指示该Method在使用时应该取消java语言的访问权限检查。</p>
<p>setAccessible()方法属于Method、Constructor、Field的父类AccessibleObject类，因此通过该方法可以取消访问权限检查，实现通过反射访问private成员。</p>
<p>通过Class对象的getField/getFields方法获取该类所包含的指定或全部成员变量，即Field对象，并提供如下方法来读取或设置成员变量值：</p>
<ol>
<li>getXxx(Object obj)：获取obj对象的该成员变量值，Xxx对应8种基本类型，成员变量为引用类型时则直接使用get。</li>
<li>setXxx(Object obj, Xxx val)：将obj对象的该成员变量设置为val值，Xxx对应8种基本类型，成员变量为引用类型时则直接使用set。</li>
</ol>
<p>java.lang.reflect包下提供了Array类，程序可以通过使用Array来动态创建数组、操作数据元素。包含如下几类方法：</p>
<ol>
<li>static Object newInstance(Class&lt;?&gt; componentType, int… length)：创建一个具有指定的元素类型和维度的新数组。</li>
<li>static Xxx getXxx(Object array, int index)：返回array数据中第index个元素，Xxx对应8种基本类型，数组元素为引用类型时则直接使用get。</li>
<li>static void setXxx(Object array, int index, Xxx val)：将array数组中第index个元素的值设置为val，Xxx对应8种基本类型，数组元素为引用类型时则直接使用set。</li>
</ol>
<p>获得成员变量对应的Field对象后，使用如下代码获得指定成员变量的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; a = f.getType();</span><br></pre></td></tr></table></figure>

<p>该方式不能得到泛型参数，需要使用以下方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; <span class="keyword">var</span>;</span><br><span class="line"><span class="comment">// 获得成员变量f的泛型类型</span></span><br><span class="line">Type gType = f.getGenericType();</span><br><span class="line"><span class="comment">// 将Type对象强制类型转换为ParameterizedType对象，该对象代表被参数化的类型，即增加了泛型限制的类型。</span></span><br><span class="line">ParameterizedType pType = (ParameterizedType) gType;</span><br><span class="line"><span class="comment">// 获取原始类型</span></span><br><span class="line">Type rType = pType.getRawType();</span><br><span class="line"><span class="comment">// rType  interface java.util.Map</span></span><br><span class="line"><span class="comment">// 取得泛型类型的泛型参数</span></span><br><span class="line">Type[] tArgs = pType.getActualTypeArguments();</span><br><span class="line"><span class="comment">// tArgs[0] class java.lang.String,</span></span><br><span class="line"><span class="comment">// tArgs[1] class java.lang.Integer</span></span><br></pre></td></tr></table></figure>

<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>每个运行中的程序就是一个进程process，一个进程内部可能包含多个顺序执行流，每个顺序执行流就是一个线程thread。</p>
<p>进程是系统进行资源分配和调度的一个独立单位。</p>
<p>进程包含如下三个特征：1. 独立性，每个进程都拥有独立的资源和自己私有的地址空间。 2. 动态性，程序只是一个静态的指令集合，进程是一个正在系统中活动的指令集合。进程具有自己的生命周期和各种不同的状态。 3. 多个进程可以在单个处理器上并发执行，多个进程之间不会互相影响。</p>
<p>并发性concurrency是指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。并发性parallel是指在同一个时刻，有多条指令在多个处理器上同时执行。</p>
<p>现在的操作系统都支持多进程的并发，常用的方式有共用式多任务操作策略、抢占式多任务操作策略。</p>
<p>多线程使得一个进程可以同时并发处理多个任务，线程Thread也被称为轻量级进程Lightweight Process。线程是进程的执行单元，线程在程序中是独立、并发的执行流。一个进程可以拥有多个线程，一个线程必须有一个父进程。线程可以拥有自己的堆栈、程序计数器和局部变量，但不拥有系统资源，它与父进程的其他线程共享该进程所拥有的全部资源。</p>
<p>线程是独立运行的，线程的执行是抢占式的，当前运行的线程在任何时候都可能被挂起，以便另外一个线程可以运行。一个线程可以创建可撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</p>
<p>系统对多线程实现调度和管理以及资源分配，线程的调度和管理由进程本身负责完成。</p>
<p>线程比进程具有更高的性能，多个线程共享同一个进程虚拟空间（共享内存、文件句柄和其他进程应有的状态等），共享的环境包括：进程代码段、进程的共有数据等，利用这些共享数据，线程很容易实现相互之间的通信。</p>
<p>线程的划分尺度小于进程，操作系统创建一个进程时需要为该进程分配独立的内存空间，并分配大量的相关资源，但创建线程时则更简单，代价更小，因此使用多线程来实现并发比使用多进程实现并发的性能要高得多。</p>
<p>####线程的创建与使用</p>
<p>Java使用Thread类代表线程，程序通过继承Thread类来创建并启动多线程：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该方法代表了线程需要完成的任务，称为该线程的线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象。</li>
<li>调用线程对象的start()方法来启动线程。</li>
</ol>
<p>java程序至少会创建一个主线程，主线程的线程执行体是main()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> ThreadA.start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。</p>
<p>实现Runable接口来创建并启动多线程：</p>
<ol>
<li>定义Runable接口的实现类，并重写该接口的run()方法，该方法为线程执行体。</li>
<li>创建Runable实现类的实例，并以该实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
<li>调用该线程对象的start()方法来启动线程。</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadA t = <span class="keyword">new</span> ThreadA();</span><br><span class="line">    <span class="keyword">new</span> Thread(t, <span class="string">&quot;Thread A&quot;</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runable对象仅作为Thread对象的target，其包含的run()方法仅作为线程执行体，而真正的线程对象依然是Thread实例，即该Thread对象调用runable对象的run()方法。而使用继承Thread类的方式中，线程对象即是包含run()方法的Thread类的子类实例。</p>
<p>Runable接口是函数式接口，可以使用Lambda表达式创建Runable对象。</p>
<p>使用Runable接口的方式创建的多个线程可以共享线程类的实例变量。</p>
<p>使用Thread的方式创建的多线程执行体不能带返回值。</p>
<p>java提供了Callable接口，该接口提供了call()方法作为线程执行体，call()方法可以有返回值，可以声明抛出异常。</p>
<p>Callable()接口不是Runable接口的子接口，不能直接作为Thread的target。call()方法不是直接调用，而是作为线程执行体被调用（与继承Thread方式中的run()方法一致，而实现Runable接口方式中，run()方法是由Thread直接调用）。</p>
<p>Java5的FutureTask实现类实现了Future接口，并实现了Runable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用lambda表达式创建Callable&lt;Integer&gt;对象，并使用FutureTask来包装Callable对象。</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;) () -&gt; &#123; <span class="keyword">int</span> i= <span class="number">0</span>; <span class="keyword">return</span> i&#125;);</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(task, <span class="string">&quot;Thread with return&quot;</span>).start();</span><br><span class="line"><span class="comment">// 获取返回值</span></span><br><span class="line">task.get()</span><br></pre></td></tr></table></figure>



<p>实现Runable、Callable接口创建多线程的优缺点：</p>
<ol>
<li>线程只是实现了两个接口，还可以继承其他类。</li>
<li>多个线程可以共享同一个target对象，适合多个相同线程来处理同一份资源的情况。</li>
<li>需要使用Thread.currentThread()方法来访问当前线程。</li>
</ol>
<p>采用继承Thread类来创建多线程的优缺点：</p>
<ol>
<li>不能继承其他父类。</li>
<li>可以直接使用this获得当前线程。</li>
</ol>
<p>一般推荐使用实现Runable、Callable接口来创建多线程。</p>
<h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p>线程具有五种状态：新建new、就绪runable、运行running、阻塞blocked、死亡dead。</p>
<p>新建状态：使用new关键字创建一个线程后，该线程就处于新建状态，仅仅由java虚拟机为其分配内存，并初始化其成员变量值，不会被执行。</p>
<p>就绪状态：当线程对象调用start()方法之后，线程处于就绪状态。JVM为其创建方法调用栈和程序计数器，但并没有开始运行，仅表示可以运行，至于程序何时运行，取决于JVM线程调度器的调度。</p>
<p>启动线程应使用start()方法，而不是直接调用run()方法。直接调用run()方法时，系统会把线程对象当成普通对象，run()方法当初普通方法，run()方法会立即执行，而不是作为线程执行体。</p>
<p>运行状态：处于就绪状态的线程获得CPU，开始执行run()方法的线程处于运行状态。线程在运行过程中可能会被中断，以使其他线程获得执行的机会，线程调度取决与底层平台所采用的策略（抢占式策略下，系统给每个可执行的线程一个小时间片段来处理任务，当该时间段用完后，系统会剥夺该线程所占用的资源，以让其他线程获得执行的机会，在选择下个线程时，会考虑线程的优先级。协作式策略：由线程主动放弃所占用的资源）。就绪状态和运行状态之间的转换通常不受程序控制（运行状态时可以调用Thread.yield()方法时当前线程进入就绪状态），而是由系统线程调度所决定。</p>
<p>发生如下情况时，线程将会进入阻塞状态：</p>
<ol>
<li>线程调用sleep()方法主动放弃所占用的处理器资源。</li>
<li>线程调用一个阻塞式IO方法，在该方法返回前，该线程被阻塞。</li>
<li>线程尝试获得一个正被其他线程所持有的同步监视器。</li>
<li>线程在等待某个通知notify。</li>
<li>程序调用了线程的suspend()方法将该线程挂起。</li>
</ol>
<p>当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞线程的阻塞解除后进入就绪状态，等待线程调度器再次调度。解除阻塞的情况：</p>
<ol>
<li>调用sleep方法的线程经过了指定时间。</li>
<li>线程调用的阻塞式IO方法已经返回。</li>
<li>线程成功获得了同步监视器。</li>
<li>线程等待的通知被发出。</li>
<li>线程的resume()方法被调用。</li>
</ol>
<p>发生如下情况时，线程处于死亡状态：</p>
<ol>
<li>run()方法或call()方法执行完成，线程正常结束。</li>
<li>线程抛出一个未捕获的Exception或Error。</li>
<li>直接调用该线程的stop()方法来结束该线程。</li>
</ol>
<p>死亡后的线程不可再次调用start()方法使它重新启动，程序只能对处于新建状态的线程调用start()方法。</p>
<p>当主线程结束时，其他线程不受任何影响，并不会随之结束。子线程启动后拥有与主线程相同的地位。</p>
<p>在某个程序中调用其他线程的join()方法时，调用线程将被阻塞，直到被join的线程执行完成或超时。</p>
<p>调用Thread对象的setDaemon(true)方法将指定线程设为为后台线程（守护线程），后台线程的任务是为其他线程提供服务，如果所有前台线程死亡，后台线程自动死亡。主线程默认是前台线程，前台线程创建的子线程默认是前台线程，后台线程创建的子线程默认是后台线程。</p>
<p>Thread类的静态方法sleep()用于让当前正在执行的线程睡眠（暂停）一会儿，并进入阻塞状态，此时线程不会获得执行的机会，即使系统中没有其他可执行的线程。</p>
<p>Thread类的静态方法yield()用于让当前正在执行的线程进入就绪状态，让系统的线程调度器重新调度一次。</p>
<p>每个线程都具有一定的优先级，优先级高的线程获得较多的执行机会。每个线程默认的优先级与创建它的父线程的优先级相同，默认情况下main线程具有普通优先级。Thread类提供了setPriority(int newPriority)方法设置指定线程的优先级，Thread类提供了MAX_PRIORITY\MIN_PRIORITY\NORM_PRIORITY静态常量，值分别是10、1、5。由于优先级操作需要操作系统支持，不同操作系统支持的优先级并不相同，因此尽量避免直接为线程指定优先级，而是使用上述三个静态常量。</p>
<h4 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h4><p>多个线程并发修改同一个共享资源时会产生安全问题，java多线程引入了同步监视器来解决多线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">  <span class="comment">// 同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述语句中，synchronized后括号里的obj就是同步监视器，其含义是：线程开始执行同步代码块之前，必须先获得对同步监视器的锁定。任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对该同步监视器的锁定。</p>
<p>多线程对共享资源（临界资源）的操作应该符合“加锁-修改-释放锁”的逻辑，任何线程在修改资源之前先对该资源加锁，在加锁期间其他线程无法修改改资源。当该线程修改完成后，释放对该资源的锁定。从而保证并发线程在任一时刻只有一个线程可以就如修改共享资源的代码区（临界区）。</p>
<p>使用synchronized关键字修饰的方法称为同步方法，此时无须显式指定同步监视器，同步方法的同步监视器是this，即调用该方法的对象。</p>
<p>线程安全的类具有如下特征：</p>
<ol>
<li>该类的对象可以被多个线程安全地访问。</li>
<li>每个线程调用该对象的任意方法之后都将得到正确结果，且该对象状态依然保持合理状态。</li>
</ol>
<p>不可变类总是线程安全的，因为它的对象状态不可改变。</p>
<p>synchronized关键字可以修饰方法、代码块，不能修饰构造器、成员变量等。</p>
<p>保证可变类的线程安全会降低程序的运行效率，因此采取如下策略较少线程安全带来的负面影响：</p>
<ol>
<li>只对会修改共享资源的方法进行同步，而不是所有方法。</li>
<li>为单线程环境和多线程环境分别提供线程不安全和线程安全版本（例如StringBuilder和StringBuffer）。</li>
</ol>
<p>任何线程进入同步代码块、同步方法之前，必须先获得对同步监视器的锁定，程序无法显式释放对同步监视器的锁定，会在如下几种情况释放对同步监视器的锁定：</p>
<ol>
<li>代码正常执行结束。</li>
<li>出现了未处理的Error或Exception。</li>
<li>程序执行了同步监视器对象的wait()方法（该方法在Object类中定义），当前线程暂停并释放同步监视器。</li>
</ol>
<p>如下情况不会释放同步监视器：</p>
<ol>
<li>调用sleep()\yield()方法暂停当前线程的执行。</li>
<li>其他线程调用了该线程的suspend()方法将该线程挂起。</li>
</ol>
<p>Java5开始，java可以通过显式定义同步锁对象来实现同步，同步锁由Lock对象充当。</p>
<p>Lock、ReadWriteLock（允许对共享资源的并发访问）是java5提供的两个根接口，并分别提供了ReentrantLock（可重入锁，即一个线程可以对已被加锁的ReentrantLock锁再次加锁，ReentrantLock对象会维持一个计数器来追踪lock()方法的嵌套调用，线程每次调用lock()加锁后必须显示调用unlock()来释放锁）、ReentrantReadWriteLock（为读写操作提供了三种锁模式，writing、ReadingOptimistic、Reading）实现类。java8新增了StampedLock，可替代传统的ReentrantReadWriteLock。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> vod <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当两个线程互相等待对方释放同步监视器时就会发生死锁。出现死锁的线程处于阻塞状态，无法继续，且程序不会发生任何异常，也不会给出任何提示。</p>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><p>线程的调度具有一定的透明性，程序通常无法控制线程的轮换执行。</p>
<p>Object类提供了wait()\notify()notifyAll()方法，这三个方法必须由同步监视器调用：</p>
<ol>
<li>使用synchronized修饰的同步方法，this就是同步监视器，因此可以直接调用这三个方法。</li>
<li>使用synchronized修饰的同步代码块，synchronized后括号的对象是同步监视器，因此必须使用该对象调用这三个方法。</li>
</ol>
<p>这三个方法：</p>
<ol>
<li>wait()：导致当前线程等待，并释放对同步监视器的锁定，直到到达指定等待时间后自动苏醒或其他线程调用该同步监视器的nofity()\notifyAll()方法唤醒。</li>
<li>notify()：唤醒在此同步监视器上等待的单个线程，如果有多个线程等待，则随机唤醒一个。只有当前线程放弃对该同步监视器的锁定后，被唤醒的线程才能被执行。</li>
<li>nofityAll()：唤醒在此同步监视器上等待的所有线程。只有当前线程放弃对该同步监视器的锁定后，被唤醒的线程才能被执行。</li>
</ol>
<p>如果程序直接使用Lock对象来保证同步，则系统中不存在隐式的同步监视器，因此不能使用wait()..方法进行进程间通信，此时可以使用Condition类，对应于wait\nofity\notifyAll，condition类提供了await\signal\signalAll。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition cond = lock.newCondition();</span><br><span class="line"></span><br><span class="line">cond.await();</span><br><span class="line">cond.signalAll();</span><br></pre></td></tr></table></figure>



<p>BlockingQueue是Queue的子接口，但它不是作为容器，而是作为线程同步的工具，其特征是：当生产者线程试图向其中放入元素（put(E e))时，如果该队列已满，则该线程被阻塞。当消费者线程试图从其中取出元素(take())时，如果该队列已空，则该线程被阻塞。其常用的实现类有：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue（对该队列的存取操作必须交替进行）等。</p>
<p>Java使用ThreadGroup表示线程组，线程组可以对一批线程进行分类管理，对线程组进行控制相当于同时控制这批线程。创建线程时没有显式指定线程组则属于默认线程组，默认情况下子线程和创建它的父线程属于同一个线程组。一旦线程加入指定线程组后，运行过程中可不能改变它所属的线程组。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>系统启动一个新线程的成本具有较高的成本，使用线程池可以提高性能，尤其是程序中需要创建大量生存期很短暂的线程时，并且线程池的最大线程参数可以控制系统中的并发线程数。</p>
<p>线程池在系统启动时创建大量空闲线程，程序将一个Runable对象或Callable对象传递给线程池时，线程池就会使用一个线程来执行他们的run或call方法，当执行结束后，线程不会死亡，而是再次返回线程池中成为空闲状态，等待下一次执行。</p>
<p>java的Excutors工厂类用于产生线程池，包含如下几个静态工厂方法来创建线程池：</p>
<ol>
<li>newCachedThreadPool(): 创建具有缓存功能的线程池，系统根据需要创建缓存在线程池中的线程。</li>
<li>newFixedThreadPool(int nThreads)：创建一个可重用的、具有固定线程数的线程池。</li>
<li>newWorkStealingPool(int parallelism)：创建足够大小的后台线程池（所有前台线程都死亡后，池中的线程自动死亡）来支持指定的并行级别，不提供parallelisem参数时，其默认值是Runtime.availableProcessors()方法的返回值，即系统可用的处理器个数。</li>
<li>newScheduledThread(int corePoolSize)：创建具有指定线程数的线程池，在指定延迟后执行线程任务。</li>
</ol>
<p>前三个返回一个ExcutorService对象，代表一个线程池，可以执行Runable或Callable对象所代表的线程。最后一个返回ScheduledExecutorService对象。</p>
<p>ExcutorService代表尽快执行线程的线程池，只要线程池中有空闲线程，就立即执行线程任务。提供如下三种方法：</p>
<ol>
<li>Future&lt;?&gt; submit(Runable task)：将一个Runable对象提交给指定的线程池，线程池将在有空闲线程时执行Runable对象代表的任务。其中Future对象代表Runable任务的返回值，由于run()方法没有返回值，因此Future对象将在run方法执行结束后返回null，但可以调用Future的isDone等方法来获得Runable对象的执行状态。</li>
<li>&lt;T&gt; Future&lt;T&gt; submit(Runable task, T result)，与上个方法类似，但result显示指定了线程执行结束后的返回值，即Future在run方法执行结束后返回result。</li>
<li>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)：将一个Callable对象提交给指定的线程池，Future代表Callable对象里call方法的返回值。</li>
</ol>
<p>用完线程池后调用该线程池的shutdown方法将启动线程池的关闭序列：不在接收新任务，但会将以前所有已提交的任务执行完成，之后池中的所有线程死亡。也可以调用shutdownNow方法关闭线程池，该方法试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。</p>
<p>使用线程池执行线程任务的步骤如下：</p>
<ol>
<li>调用Executors类的静态工厂方法来创建一个ExecutorService对象，该对象代表一个线程池。</li>
<li>创建Runable实现类或Callable实现类的实例，作为线程执行任务。</li>
<li>调用ExcutorService对象的submit方法来提交Runable或Callable实例。</li>
<li>调用ExecutorService对象的shutdown方法来关闭线程池。</li>
</ol>
<p>ForkJoinPool类支持将一个任务拆分为多个小任务并行计算，再把多个小任务的结果合并成总的计算结果，是ExecutorService的实现类。可以使用ForkJoinPool的submit(ForkJoinTask task)或invoke(ForkJoinTask task)方法来执行指定任务，ForkJoinTask代表一个可以并行、合并（即可分解）的任务，具有两个抽象子类，分别是代表有返回值的任务RecursiveTask和没有返回值的任务RecursiveAction。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可分解的任务, 不带返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskA</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">  <span class="meta">@OverRide</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">      <span class="comment">// 小任务直接执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 拆分</span></span><br><span class="line">    	TaskA task1 = <span class="keyword">new</span> TaskA();</span><br><span class="line">    	TaskA task2 = <span class="keyword">new</span> TaskA();</span><br><span class="line">    	task1.fork();</span><br><span class="line">    	task2.fork();      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">  pool.sumbit(<span class="keyword">new</span> TaskA());</span><br><span class="line">  pool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可分解的任务, 带返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskA</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@OverRide</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">      <span class="comment">// 小任务直接执行</span></span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 拆分</span></span><br><span class="line">    	TaskA task1 = <span class="keyword">new</span> TaskA();</span><br><span class="line">    	TaskA task2 = <span class="keyword">new</span> TaskA();</span><br><span class="line">    	task1.fork();</span><br><span class="line">    	task2.fork();  </span><br><span class="line">      <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool.commonPool();</span><br><span class="line">  Future&lt;Integer&gt; future = pool.sumbit(<span class="keyword">new</span> TaskA());</span><br><span class="line">  future.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ThreadLocal类代表一个线程局部变量，通过把数据放在ThreadLocal中可以让每个线程创建一个该变量的副本，从而避免并发访问的线程安全问题，提供了：T get()、remove()、set(T value)三个方法，分别是返回、删除、设置此线程局部变量中当前线程副本中的值。如果多个线程之间需要共享资源，以达到线程之间的通信功能，就使用同步机制；如果仅仅需要隔离多个线程之间的共享冲突，则使用ThreadLocal。</p>
<h4 id="包装线程不安全的集合"><a href="#包装线程不安全的集合" class="headerlink" title="包装线程不安全的集合"></a>包装线程不安全的集合</h4><p>Java集合中的ArrayList、LinkedList、HashSet等都是线程不安全的，可以使用Collections工具类中的类方法将这些集合包装成线程安全的集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c);</span><br><span class="line">static &lt;T&gt; List&#x2F;Set&#x2F;SortedSet&lt;T&gt; synchronizedList&#x2F;Set&#x2F;SortedSet(List&#x2F;Set&#x2F;SortedSet&lt;T&gt; list&#x2F;s&#x2F;s)</span><br><span class="line">static &lt;K,V&gt; Map&#x2F;SortedMap&lt;K,V&gt; synchronizedMap&#x2F;SortedMap(Map&#x2F;SortedMap&lt;K,V&gt; m)</span><br></pre></td></tr></table></figure>

<p>需要在某个集合创建后立即将其包装成线程安全的集合。</p>
<p>java.util.concurrent下提供了大量支持高效并发访问的集合接口和实现类。</p>
<img src="JAVA%E5%AD%A6%E4%B9%A0.assets/image-20201013111108706.png" alt="image-20201013111108706" style="zoom:40%;" />

<p>上述线程安全的集合类可分为如下两类：</p>
<ol>
<li>以Concurrent开头的集合，例如ConcurrentHashMap/LinkedQueue/LinkedDeque等，这类集合支持多个线程并发写入访问。</li>
<li>以CopyOnWrite开头的集合，例如CopyOnWriteArrayList/Set等，这类集合采用复制底层数组的方式来实现写操作，当对这类集合执行读取操作时，线程将会直接读取集合本身，无需加锁与阻塞。当执行写入操作（add\remove\set等方法）时，该集合会在底层复制一份新的数组，并对新数组执行写入操作，因此是线程安全的。但由于执行写入操作时需要频繁地复制数组，性能比较差，适合用在读取操作远远大于写入操作的场景中，例如缓存等。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/" data-id="ckmn1li2f000tn8a81ew9e22c" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/24/Python%20Cheatsheet/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/24/Python%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/24/tofino-command/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/24/%E5%AE%89%E8%A3%85mininet%E5%92%8Ctofino-model/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/24/TNA%20model/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 xbo<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>