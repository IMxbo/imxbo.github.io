<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>xbo&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="xbo&#39;s Blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="xbo&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="xbo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="xbo's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xbo&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-微信公众号笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.589Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Linux服务器最大支撑多少TCP连结"><a href="#Linux服务器最大支撑多少TCP连结" class="headerlink" title="Linux服务器最大支撑多少TCP连结"></a>Linux服务器最大支撑多少TCP连结</h3><p>TCP连接四元组：源IP、源端口、目的IP、目的端口，理论上一个服务，例如Nginx，其接受的连接的目的IP和目的端口是固定的，故可以建立2^32^（IP数）*2^16^（端口数）个链接。</p>
<p>进程每打开一个文件（Linux下一切皆文件）都会消耗一定的内存资源，Linux基于安全考虑，对可打开的文件描述符的数量有系统级、用户级、进程级的限制（分别是当前系统、指定用户、单个进程可打开的最大数量）。</p>
<p>###以太网最小帧为什么是64字节</p>
<p>早期以太网使用集线器构建星型网络，集线器会将一个端口收到的数据包泛红出去，为了避免数据冲突，网卡使用CSMA/CD载波监听多路访问/冲突避免协议，在发送数据时会检测信道上是否已有主机在发送数据，如果有则终止发送。</p>
<p>假设A向B发送数据，在数据到达B的前极小一段时间$t-\delta$($\delta\rightarrow0$,t为单程端到端传播时延)内，B检测到信道空闲，于是发送数据，此时发送碰撞，经过t时间后A检测到发送碰撞，此次发送失败。如果A超过2t时间都没有检测到碰撞，则A发送的数据一定不会发生碰撞，因此为了使A检测到碰撞，需要使A单次发送数据的时长需要超过2t，这个时长又称为争用期或碰撞事件。</p>
<p>电磁波在1km电缆中的传播时延约为5us，10Mbps以太网允许最大连接长度是2500米，最多经过4个中继器，因此最大往返时间为50us，考虑到中继器的转发时延等，实际争用期确定为51.2us。10Mbps*51.2us=64Bytes，这就是以太网帧的最小长度，又称为以太网时隙。如果某主机发送完一个帧的64字节仍无冲突，则以后也不会再发生冲突了，称此主机捕获了信道。由于信道是所有主机共享，为了避免单一主机占用信道时间过长，规定了以太网帧的最大帧长为1500。</p>
<h3 id="Linux网络接收包过程"><a href="#Linux网络接收包过程" class="headerlink" title="Linux网络接收包过程"></a>Linux网络接收包过程</h3><p>Linux实现的是链路层、网络层和传输层，链路层协议靠网卡驱动实现，内核协议栈来实现网络层和传输层，内核对应用层提供socket接口来供用户进程访问。</p>
<p>用户执行完recvfrom调用后，用户进程就通过系统调用进入到内核态工作，如果接收队列没有数据，进程就进入睡眠状态被操作系统挂起。</p>
<p>网口收到数据后，网卡驱动会以DMA的方式将接收到的帧写到内存里的环形缓冲队列RingBuffer，再向CPU发起硬中断（给CPU的相关引脚上触发一个电压变化），CPU再调用网卡驱动注册的中断处理函数，由于该硬中断优先级过高，并且网络模块的处理过程比较复杂和耗时，如果在中断函数中完成所有处理将过度占用CPU，因此Linux将中断处理函数分为上半部分和下半部分，上半部分只进行简单工作，快速处理后释放CPU，剩下的绝大部分工作都放到下半部分，下半部分采用的是软中断（通过改变内存中的一个变量值以通知软中断处理程序），软中断将调用网卡注册的poll函数开始从RingBuffer内轮询收包，交由内核的各级协议栈开始处理，处理完的数据data被放置到socket的接收队列中，然后由内核唤醒用户进程，进入用户态。</p>
<p>收包过程的CPU开销：1. 用户进程通过系统调用陷入内核态的开销， 2. CPU响应网口硬中断的CPU开销， 3. 软中断中各级协议栈处理数据包的CPU开销。</p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>Linux系统中一切皆文件，因此许多操作都可以归类与读写操作，零拷贝技术是为了提高读写性能。</p>
<p>读操作：</p>
<ol>
<li><p>仅CPU方式</p>
<p>应用程序调用read()陷入内核态，CPU向磁盘控制器发起IO请求，磁盘控制器将数据放至磁盘缓冲区后向CPU发起IO中断，CPU将数据拷贝至内核缓冲区，再拷贝至用户缓冲区，read()调用返回，切换到用户态。</p>
</li>
<li><p>CPU&amp;DMA方式</p>
<p>相比于仅CPU方式，CPU向DMA控制器发起IO请求，由DMA控制器向磁盘发起IO请求，磁盘控制器将数据放至磁盘缓冲区后向DMA控制器发送完成信号，由DMA控制器将数据拷贝至内核缓冲区，再由CPU拷贝至用户缓冲区。</p>
</li>
</ol>
<p>写操作：</p>
<p>应用程序调用write()陷入内核态，CPU将用户缓冲区数据拷贝至内核缓冲区，再由CPU或DMA控制器将数据拷贝至socket缓冲区，完成拷贝，write()调用返回，切换到用户态。</p>
<p>零拷贝技术：</p>
<ol>
<li><p>mmap+write</p>
<p>mmap是Linux提供的一种内存映射文件的机制，它实现了将内核中读缓冲区地址与用户空间缓冲区地址进行映射，从而实现内核缓冲区与用户缓冲区的共享。减少了一次用户态和内核态之间的CPU拷贝，但是在内核空间内仍然有一次CPU拷贝。</p>
</li>
<li><p>sendfile</p>
<p>sendfile在两个文件描述符之间拷贝数据，拷贝在内核态中完成，因此相比于read+write和mmap+write减少了一次系统调用（少了两次状态切换），用于数据不经过用户缓冲区，因此数据无法被修改。</p>
</li>
<li><p>sendfile+DMA</p>
<p>sendfile将内核空间缓冲区中对应的数据描述信息（文件描述符、地址偏移量等信息）记录到socket缓冲区中，DMA控制器根据socket缓冲区中的地址和偏移量将数据从内核缓冲区拷贝到网卡中，从而省去了内核空间中仅剩的1次CPU拷贝。</p>
</li>
</ol>
<h3 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h3><p>程序直接使用物理内存会使所有进程的安全性得不到保证。</p>
<p>地址空间：进程可用于寻址内存的一套地址集合，每个进程都有一套自己的地址空间，各个进程的地址空间是独立的。进程所使用的内存地址是虚拟地址，操作系统将不同进程的虚拟地址和内存中不同的物理地址映射起来，对进程而言是透明的。</p>
<p>地址空间建立：</p>
<ol>
<li><p>直接将每个进程的地址空间分别映射到物理内存的不同部分，操作系统为每个进程提供一个基址和界限，为此CPU中配置了基址寄存器和界限寄存器。</p>
<p>如果程序太大，超过内存容量，可以采用手动覆盖技术：把程序按照自身逻辑结构，划分成多个功能相互独立的程序模块，常用的模块常驻内存，不常用的模块平时放到外存中，在需要时加载到内存中，不同时执行的模块可以共享同一块内存区域。</p>
<p>如果程序太多，超过内存容量，可以采用交换技术，将暂时不能运行的程序换出到外存中，以接收新的进程，或将外存中的进程换入到内存中。</p>
</li>
<li><p>使用虚拟内存</p>
<p>确保每个程序拥有自己的地址空间，地址空间被分成多个块，同时物理内存空间也分成多个块，块大小和虚拟地址空间的块大小一致，操作系统会自动将虚拟地址空间映射到真实物理地址空间，程序所关注的只是虚拟内存，请求的也是虚拟内存，其实真正使用的是物理内存。</p>
<p>虚拟内存技术一般是在页式管理的基础上实现</p>
<p>  在装入程序时，不必将其全部装入到内存，而只需将当前需要执行的部分页面装入到内存，就可让程序开始执行；</p>
<p>  在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页异常）。则由处理器通知操作系统将相应的页面调入到内存，更新页表，然后继续执行程序；</p>
<p>  操作系统将内存中暂时不使用的页面调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面。 </p>
</li>
</ol>
<p>虚拟内存映射到物理内存由CPU中的内存管理单元MMU完成，虚拟内存不直接送到内存总线，而是先给MMU。</p>
<p>分页内存管理：</p>
<p>将虚拟地址空间和物理地址空间分成若干个连续且固定大小的块，虚拟地址空间中的块就被称为<strong>页Page</strong>，物理地址空间这些块被称为<strong>页框</strong>。页面太大容易产生空间浪费，页面太小会导致页表占用空间过大，大多数系统都使用4KB作为页的大小。</p>
<p>MMU通过<strong>页表</strong>将虚拟地址转换为物理地址。虚拟地址分成两部分（页号和偏移量），页号作为页表的索引，MMU通过页表找到了页号对应的页框的物理基地址，页框的物理基地址+偏移量就是实际访问的物理地址。</p>
<p>页表结构：</p>
<p>| 页号 | 内存块号 | 状态位 | 访问字段 | 修改位 | 外存地址 |</p>
<p>TLB：</p>
<p>每条指令执行基本都会进行多次页表查询，依据程序局部性原理（时间局部性：对一条执行/数据的的执行/访问都集中在一个较短时间内， 空间局部性：当前执行/访问的指令/数据都集中在一个较小区域内），通过在CPU中加入专门存放程序最常访问的页表项的缓存，提高页表查询映射的速度，这个缓存称为 TLB（<em>Translation Lookaside Buffer</em>，转换检测缓冲区） ，通常称为页表缓存、转址旁路缓存、快表等。MMU每次进行虚拟地址转换时，首先去TLB中查找，找到了有效的物理页框则直接返回，如果没有找到则进行正常的页表访问。</p>
<p>多级页表：</p>
<p>32/64位操作系统有很大的虚拟地址空间，其对应的页表会非常大，同时每个进程都有自己的页表，会导致页表占用过大的内存空间，解决方法是使用多级页表。以一个32位虚拟地址的二级页表为例，将32位虚拟地址划分为10位的PT1域，10位的PT2域，以及12位的offset域，当一个虚拟地址被送入MMU时，MMU首先提取PT1域并把其值作为访问第一级页表的索引，之后提取PT2域把把其值作为访问第二级页表的索引，之后再根据offset找到对应的页框号。</p>
<p>32位的虚拟地址空间下：每个页面4KB，且每条页表项占4B：</p>
<p><strong>一级页表</strong>：进程需要1M个页表项（4GB / 4KB = 1M, 2^20个页表项），即页表（每个进程都有一个页表）占用4MB（1M * 4B = 4MB）的内存空间。</p>
<p><strong>二级页表</strong>：一级页表映射4MB（2^22）、二级页表映射4KB，则需要1K个一级页表项（4GB / 4MB = 1K, 2^10个一级页表项）、每个一级页表项对应1K个二级页表项（4MB / 4KB = 1K），这样页表占用4.004MB（1K * 4B + 1K * 1K * 4B = 4.004MB）的内存空间。</p>
<p>每个进程都有4GB的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到4GB，因此不必要映射不可能用到的空间，也就是说，一级页表覆盖了整个4GB虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。假设只有20%的一级页表项被用到了，那么页表占用的内存空间就只有0.804MB （1K*4B+0.2*1K*1K*4B=0.804MB）。由于页表承担的职责是将虚拟地址翻译成物理地址，页表一定要覆盖全部虚拟地址空间，因此未分级的页表不能通过减少映射 未使用空间的 表项来减少内存占用。</p>
<p>缺页中断：</p>
<p>缺页中断就是要访问的页不在主存中，需要操作系统将页调入主存后再进行访问，此时会暂时停止指令的执行，产生一个页不存在的异常，对应的异常处理程序就会从选择一页调入到内存，调入内存后之前的异常指令就可以继续执行。</p>
<p>缺页会带来巨大的软件开销：决定置换哪个或哪些驻留页、交换页所需要的IO操作、调度另一个进程导致的进程切换等。</p>
<p>缺页中断处理过程：如果内存中有空闲的物理页框，则直接将外存中所需要访问的页装入该物理页框中，否则根据某种页面置换算法选择一个将被替换的物理页框，将该页框内的页写入外存，再将外存中所需要访问的页装入该物理页框中，然后重新运行被中断的指令。</p>
<p>页面读取策略：</p>
<ul>
<li>请求分页：只有当访问到某页中的一个单元时才将该页读入内存。</li>
<li>预先分页：基于局部性原理和存储设备特性（一次读取多个连续页比连续读取多个页更快，省略了寻道时间和延迟），一次读取多个连续的页。</li>
</ul>
<p>驻留集管理：驻留集即驻留在内存中的页面构成的集合，</p>
<ul>
<li>固定分配策略：在进程加载时，为一个进程在内存中分配固定数量的页框。</li>
<li>可变分配策略：分配给一个进程的页框在该进程的生命周期中不断变化，若进程的缺页率一直比较高，说明在该进程中局部性原理表现比较弱，应该给它多分配一些页框以减少缺页率，否则可以减少分配的页框数。</li>
</ul>
<p>清除策略：</p>
<ul>
<li>请求式清除：只有当一页被选择用于置换时才被写回外存。</li>
<li>预约式清除：就已修改的多页在需要使用它们所占据的页框之前成批写回外存。</li>
</ul>
<p>页面分配：</p>
<p>为了提升向内存中读入和从内存中写出页的效率。</p>
<p>伙伴系统 用于把连续的页映射到连续的页框中。 Linux内核维护一系列大小固定的连续页框组，一组可以包含1、2、4、8、16或32个页框，当一页在内存中被分配或被解除分配时，可用的页框组使用伙伴算法来分裂或合并。</p>
<p>页面置换算法：</p>
<p>页面置换算法的目的是尽可能减少页面的换入换出次数（缺页中断次数），尽量把未来不再使用的或短期内较少使用的页面换出，通常在程序局部性原理指导下依据过去的统计数据来进行预测。</p>
<ol>
<li><p>最优置换算法（OPT, Optimal）</p>
<p>选择距离下一次访问时间最久（即在内存中即将等待最长时间）的页面。最佳置换算法可以保证最低的缺页率，但是实际上，只有进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面的访问序列，因此该算法无法实现。</p>
</li>
<li><p>先进先出置换算法（FIFO）</p>
<p>选择最早进入内存的页面，FIFO算法与进程实际运行时的规律不适应。因为最先进入的页面也有可能最经常被访问，因此该算法性能差。</p>
</li>
<li><p>最近最少使用置换算法（LRU, Least Recently Used）</p>
<p>选择最近最少使用（即最近最久未被使用）的页面，在每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t最大的页面，即最近最久未使用。该算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p>
</li>
<li><p>时钟置换算法（CLOCK，NRU）</p>
<p>为内存中每个页面设置一个<strong>访问位</strong>，再将内存中的页面都通过链接指针链接成一个循环队列，并使用另一个表指针指向最老的页面。当某个页被访问时，将其访问位置1.当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出，并将表指针指向下一个页面；如果是1，则将其访问位置0，再继续检查下一个页面，若第一轮扫描中所有的页面都是1，则将这些页面的访问位全部置为0后，再进行第二轮扫描。</p>
<p>由于该算法循环地检查各页面的情况，故称为 CLOCK 算法，又称为最近未用( Not Recently Used, NRU )算法。</p>
</li>
<li><p>改进型的时钟置换算法</p>
<p>简单的时钟置换算法仅考虑到了一个页面最近是否被访问过。事实上，如果淘汰的页面没有被修改过，就不需要执行I/O操作写回外存，只有淘汰的页面被修改过时，才需要写回外存。因此，除了考虑一个页面最近有没有被访问过之外，操作系统还需要考虑页面有没有被修改过。改进型时钟置换算法的算法思想<strong>：</strong>在其他在条件相同时，应该优先淘汰没有被修改过的页面，从而来避免I/O操作。用（访问位，修改位）的形式表示各页面的状态。如（1,1）表示一个页面近期被访问过，且被修改过。</p>
<p>将所有可能被置换的页面排成一个循环队列</p>
<p>  第一轮：从表指针位置开始扫描第一个（0,0）的页用于替换（淘汰的是<strong>最近没有访问且没有修改</strong>的页面），本轮扫描不修改任何标志位。<br>  第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0,1）的页用于替换（淘汰的是<strong>最近没有访问但修改</strong>的页面）。本轮将所有扫描的过的页访问位设为0。<br>  第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0,0）的页用于替换（淘汰的是<strong>最近访问但没有修改</strong>的页面）。本轮扫描不修改任何标志位。<br>  第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0,1）的页用于替换（淘汰的是<strong>最近访问且修改</strong>的页面）。</p>
<p>该算法开销小，性能也不错</p>
</li>
<li><p>最不常用算法</p>
</li>
</ol>
<p>  为每个页面设置一个计数器，被访问时，该页面的访问计数器加1，在需要淘汰时，选择计数器值最小的那个页面。但当一个页面在进程的初始阶段大量使用但是随后不再使用时，由于它具有一个大的计数，它会仍久保留在内存中，一种解决方案是，定期地将计数右移 1 位，以形成指数衰减的平均使用计数。</p>
<p>  该算法的实现是昂贵的，并且它们不能很好地近似 OPT 置换。</p>
<p>分段内存管理：</p>
<p>8086CPU时期，程序访问内存时使用的是真实物理地址，为了方便多道程序并发执行，需要支持对各个程序进行重定位。通过分段机制，程序中使用的地址由段基址+段内偏移量组成，操作系统通过更改段基址，就可进行重定位。而且8086CPU的地址线宽度是20位，可寻址范围可以达到1MB，但是它们的寄存器都是16位，直接使用1个16位寄存器不可能访存达到1MB，因此引入了段，引入了段寄存器，段寄存器左移4位+偏移量就可以生成20位的地址，从而达到1MB的寻址范围。</p>
<p>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），这相当于屏蔽了处理器中的段式内存管理，段只被用于访问控制和内存保护。</p>
<p>Linux中的虚拟地址空间的内部又被分为<strong>内核空间（内核态下可访问）和用户空间（进程在用户态下可访问</strong>两部分，每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址关联的都是相同的物理内存，从而当进程切换到内核态后可以很方便地访问内核空间内存。</p>
<p>32位系统的内核空间占用高位1G（0xC0000000-0xFFFFFFFF)，用户空间占用低位3G（0x0-0xC0000000)，64位系统的内核空间占用高位128T（0xFFFF800000000000-0xFFFFFFFFFFFFFFFF)，用户空间占用低位128T（0x0-0x00007FFFFFFFF000)，其余中间部分是未定义空间。</p>
<p>用户空间内存中，从低到高依次是程序文件段、已初始化数据段、未初始化数据段、堆段（包括动态分配的内存，从低地址开始向上增长）、文件映射段（包括动态库、共享内存等）、栈段（包括局部变量和函数调用的上下文等）。堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 <code>malloc()</code> 或者 <code>mmap()</code> ，就可以分别在堆和文件映射段动态分配内存。</p>
<h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>I/O一般指磁盘I/O和网络I/O。</p>
<p>I/O多路复用是指用一个或少量线程处理多个TCP连接。</p>
<p>I/O模型：阻塞、非阻塞、同步、非同步。</p>
<p>进程模型：单进程、多进程、多线程。</p>
<p>一次IO分为两个阶段：等待数据（数据可能来自其他应用程序或者网络）、拷贝数据（将就绪的数据拷贝到应用程序工作区）</p>
<p>同步和非同步的概念描述的是用户线程和内核的交互方式，同步是指用户线程发起I/O请求后需要等待或轮询内核I/O操作，异步是指用户线程发起I/O请求后仍继续执行，当内核I/O操作完成后通知用户线程，或者调用用户线程注册的回调函数。</p>
<p>阻塞和非阻塞的概念描述的是用户线程调用内核I/O操作的方式，阻塞是指I/O操作需要彻底完成后才能返回用户空间，非阻塞是指I/O操作被调用后立即返回给用户一个状态值，而无需等待I/O操作彻底完成。</p>
<p>传输层、网络层、链路层由系统内核负责，内核处理所有通信细节，包括收发数据、等待确认、给无序到达的数据排序等。</p>
<p>同步阻塞IO：用户线程通过调用系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接受的数据拷贝到用户空间，完成read操作。整个IO请求过程，用户线程都是被阻塞的，对CPU利用率不够。JAVA传统的BIO（Blocking IO）属于此种方式。</p>
<p>传统的服务器端同步阻塞I/O处理（也就是BIO，Blocking I/O）的经典编程模型，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞。在这种模型下使用多线程的主要原因在于socket.accept()、socket.read()、socket.write()三个主要函数都是同步阻塞的，当一个连接在处理I/O的时候，系统是阻塞的。</p>
<p>这个模型严重依赖于线程，但线程是很”贵”的资源，主要表现在：</p>
<ol>
<li><strong>线程的创建和销毁成本很高</strong>，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。</li>
<li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，占用的内存将非常惊人。</li>
<li><strong>线程的切换成本是很高的</strong>。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。</li>
<li><strong>容易造成锯齿状的系统负载</strong>。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高而且外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。</li>
</ol>
<p>同步非阻塞IO：在同步基础上将socket设置为NONBLOCK，用户线程在发起IO请求后立即返回，此时并未读到任何数据，用户线程需要不断的轮询内核，直到数据到达后才能真正读到数据。不断的轮询消耗了大量的CPU资源，实际用处不大。JAVA的NIO（Non-blocking IO/New IO）属于此种方式。</p>
<p>多路复用IO：也称为事件驱动IO，由单个线程处理多个IO连接。</p>
<p>信号驱动式IO：用户线程发起IO请求时注册一个信号函数，请求立即返回，操作系统底层则处于等待状态（等待数据就绪），直到数据就绪，然后通过信号通知主调程序，主调程序才去调用系统函数recvfrom()完成IO操作。属于非阻塞式IO，针对于一个IO的完成过程。</p>
<p>异步IO：将整个IO操作（包括等待数据就绪，复制数据到应用程序工作空间）全都交给操作系统完成。数据就绪后操作系统将数据拷贝进应用程序运行空间之后，操作系统再通知应用程序，这个过程中应用程序不需要阻塞。</p>
<p>IO多路复用使用的系统调用select/poll/epoll，目的在于同时处理多个连接，解决线程/进程数量过多对服务器开销造成的压力，而不是更快，在连接数不大的情况下，性能不一定优于多线程+阻塞IO。</p>
<p>select/poll/epoll都是阻塞式IO，调用这些I/O多路复用函数时如果任何一个需要监视的文件描述符都不可读或者可写那么进程会被阻塞暂停执行，直到有文件描述符可读或者可写才继续运行。</p>
<p>I/O多路复用就是使用一个进程监视多个描述符（socket），一旦某个描述符就绪（读就绪或写就绪），就通知程序进行相应的读写操作了，</p>
<p>LINUX中一切皆文件，比如设备、网络连接、进程间通信管道等，所有的I/O操作都可以通过文件读写来实现，一般有打开文件open、改变读写位置seek、文件读写read/write、关闭文件close等。文件描述符（file description）唯一标识了一个文件。</p>
<p>select：</p>
<p>将需要监控的文件描述符集合通过参数传递给select，调用select后函数会阻塞，直到有描述符就绪（有数据读、写、或异常）或超时，函数返回所有文件描述符集合。当select函数返回后，通过遍历文件描述符集合找到就绪的描述符。</p>
<p>可监控的文件描述符集合不能超过1024个，无法实现高并发；需要遍历文件描述符数组，轮询的开销会随着文件描述符数量的增加而线性增加，效率低；涉及到大量文件描述符数组在内核空间和用户空间之间的拷贝，而不论这些文件描述符是否就绪，性能消耗大；</p>
<p>poll：</p>
<p>取消了可监控文件描述符最大数量限制。</p>
<p>epoll：</p>
<p>使用事件驱动，避免了轮询查看可读写事件。</p>
<p>epoll在阻塞监听描述符就绪状态时，仅会返回已经就绪的文件描述符集合，而无需再遍历集合。epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知，这样IO的效率不会随着监视fd的数量的增长而下降。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span> <span class="comment">//创建一个epoll的句柄，size是最大的描述符监听数。size并不会真正限制epolll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span> <span class="comment">//对指定描述符的监听事件执行指定的Op操作，epfd：是epoll_create()的返回值，fd：是需要监听的文件描述符，epoll_event：是告诉内核需要监听什么事，op：表示操作，有三个宏定义，分别是添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span> <span class="comment">//等待epfd上的io事件，最多返回maxevents个事件, 该方法与Java NIO的select()方法类似，maxevents的值不能超过epoll_create中的参数size的大小，也就是说，size的大小也间接限制了epoll的线程一次会批量处理几个IO事件。</span></span></span><br></pre></td></tr></table></figure>



<p>###Reactor模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers</span><br></pre></td></tr></table></figure>

<ol>
<li>Reactor模式是一种事件驱动模式</li>
<li>一个或多个输入是同时交付的</li>
<li>服务控制器会分离到达的多个请求并同步的分发给相关的处理器进行处理</li>
</ol>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%AC%94%E8%AE%B0.assets/1df6c196ed6c08f700b253e2039da1e3.png" alt="reactor模型.png"></p>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%AC%94%E8%AE%B0.assets/4de8505e72cdbd67db7cc4ba91ad14a2.png" alt="reactor模式.png"></p>
<ul>
<li>Synchronous Event Demutiplexer是同步事件分离器，是IO多路服用技术实现的关键，主要任务是监听系统的Handlers中事件的发生，监听的过程是阻塞等待的</li>
<li>Handle是句柄，即操作系统管理的资源</li>
<li>Dispatcher是分发器，负责根据Event的类型来调用EventHandler</li>
<li>EventHandler是事件处理器，每个事件处理器会关联一个Handle</li>
</ul>
<p>流程如下所述：</p>
<ul>
<li>初始化Dispatcher</li>
<li>注册EventHandler到Dispatcher中，每个EventHandler包含对相应Handle的引用，从而建立Handle到EventHandler的映射</li>
<li>启动Event Loop。在Event Loop中，调用select()方法,Synchronous Event Demultiplexer阻塞等待Event发生</li>
<li>当某个或某些Handle的Event发生后，select()方法返回，Dispatcher根据返回的Event找到注册的EventHandler，并回调该EventHandler的handle_event()方法</li>
<li>在EventHandler的handle_event()方法中还可以向Dispatcher中注册新的EventHandler，用来处理下一个Event</li>
</ul>
<p>主从Reactor多线程模型</p>
<p>Reactor分成两部分：</p>
<ol>
<li>mainReactor负责监听server socket，用来处理网络IO连接建立操作，将建立的socketChannel指定注册给subReactor。</li>
<li>subReactor主要做和建立起来的socket做数据交互和事件业务处理操作。通常，subReactor个数上可与CPU个数等同。</li>
</ol>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%AC%94%E8%AE%B0.assets/image-20210104150151546.png" alt="image-20210104150151546"></p>
<p>消息处理流程：</p>
<ol>
<li>从主线程池中随机选择一个Reactor线程作为acceptor线程，用于绑定监听端口，接收客户端连接</li>
<li>acceptor线程接收客户端连接请求之后创建新的SocketChannel，将其注册到主线程池的其它Reactor线程上，由其负责接入认证、IP黑白名单过滤、握手等操作</li>
<li>步骤2完成之后，业务层的链路正式建立，将SocketChannel从主线程池的Reactor线程的多路复用器上摘除，重新注册到Sub线程池的线程上，并创建一个Handler用于处理各种连接事件</li>
<li>当有新的事件发生时，SubReactor会调用连接对应的Handler进行响应</li>
<li>Handler通过Read读取数据后，会分发给后面的Worker线程池进行业务处理</li>
<li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li>
<li>Handler收到响应结果后通过Send将响应结果返回给Client</li>
</ol>
<p>NIO</p>
<ul>
<li>NIO是Java SDK提供的基于Reactor模式的非阻塞IO工作模式的实现</li>
<li>NIO与IO的主要区别包括：</li>
</ul>
<table>
<thead>
<tr>
<th>NIO</th>
<th>IO</th>
</tr>
</thead>
<tbody><tr>
<td>面向缓冲</td>
<td>面向流</td>
</tr>
<tr>
<td>非阻塞IO</td>
<td>阻塞 IO</td>
</tr>
</tbody></table>
<p>面向缓冲是NIO与传统IO最大的区别，传统的IO是基于字节的，所有的IO都被看作是单个子节的移动，而NIO是基于块的，一个块则由多个字节组成，从简单的原理上看，NIO的性能提升主要来源于每一次IO操作都能尽可能的读写更多的字节，而更直接的提升是得益于NIO使用的IO读写结构Channel和Buffer非常贴近操作系统执行IO的方式:通道和缓冲器。简单的理解就是越接近操作系统底层，越快速。</p>
<p>NIO对Reactor模型组件的实现</p>
<ol>
<li>Selector : Synchronous Event Demultiplexer</li>
<li>SelectKey : Event</li>
<li>SocketChannel : Handle</li>
<li>(Handlers write by yourself) : EventHandler</li>
</ol>
<h3 id="高性能开发要点"><a href="#高性能开发要点" class="headerlink" title="高性能开发要点"></a>高性能开发要点</h3><p>CPU：提升主频（加快指令执行速度）、使用多级缓存（加快CPU读取数据速度）、多核技术、超线程技术、多线程技术、无锁编程技术、协程技术。</p>
<p>内存：提升主频与容量、降低读取时延、换页/交换技术、TLB、大页内存技术、NUMA感知（CPU核需要通过内存总线访问内存，NUMA架构把CPU核心划分不同的分组，各自使用独立的内存访问总线，减少内存总线的竞争，提高内存访问速度，降低访问延迟）。</p>
<p>I/O：非阻塞IO、I/O多路复用、异步I/O、DMA、零拷贝、线程池。</p>
<p>算法架构：分布式集群、负载均衡、数据库索引、数据库缓存中间件、CDN。</p>
<ul>
<li>I/O优化：零拷贝技术</li>
<li>I/O优化：多路复用技术</li>
<li>线程池技术</li>
<li>无锁编程技术</li>
<li>进程间通信技术</li>
<li>RPC &amp;&amp; 序列化技术</li>
<li>数据库索引技术</li>
<li>缓存技术 &amp;&amp; 布隆过滤器</li>
<li>全文搜索技术</li>
<li>负载均衡技术</li>
</ul>
<h3 id="进程和线程相关问题"><a href="#进程和线程相关问题" class="headerlink" title="进程和线程相关问题"></a>进程和线程相关问题</h3><p>什么是进程？</p>
<p>标准定义：进程是一个具有一定独立功能的程序在一个数据集合上依次动态执行的过程。进程是一个正在执行程序的实例，包括程序计数器、寄存器和程序变量的当前值。简单来说进程就是一个程序的执行流程，内部保存程序运行所需的资源。</p>
<p>在操作系统中可以有多个进程在运行，可对于CPU来说，同一时刻，一个CPU只能运行一个进程，但在某一时间段内，CPU将这一时间段拆分成更短的时间片，CPU不停的在各个进程间快速切换，这就给人一种并行的错觉，像CPU可以同时运行多个进程一样，这就是伪并行。</p>
<p>进程和程序有什么联系？</p>
<p>一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</p>
<p>程序是产生进程的基础</p>
<p>程序的每次运行产生不同的进程</p>
<p>进程是程序功能的体现</p>
<p>通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序</p>
<p>进程和程序有什么区别？</p>
<p>进程是动态的，程序是静态的：程序是有序代码的集合，进程是程序的执行。</p>
<p>进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存。</p>
<p>进程和程序的组成不同：进程的组成包括程序、数据和进程控制块（进程状态信息）。</p>
<p>进程如何创建？</p>
<p><strong>系统初始化</strong>：当启动操作系统时，通常会创建很多进程，有些是同用户交互并替他们完成工作的前台进程，其它的都是后台进程，后台进程和特定用户没有关系，但也提供某些专门的功能，例如接收邮件等，这种功能的进程也称为守护进程。计划任务是个典型的守护进程，它每分钟运行一次来检查是否有工作需要它完成。如果有工作要做，它就会完成此工作，然后进入休眠状态，直到下一次检查时刻的到来。</p>
<p><strong>正在运行的程序执行了创建进程的系统调用</strong>。</p>
<p><strong>用户请求创建一个新进程</strong>。</p>
<p><strong>一个批处理作业的初始化</strong>：这种情形不常见，仅在大型机的批处理系统中应用，用户在这种系统中提交批处理作业，在操作系统认为有资源可运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。</p>
<p>进程为何终止？</p>
<p><strong>正常退出</strong>：进程完成了工作正常终止，UNIX中退出进程的系统调用是exit。</p>
<p><strong>出错退出</strong>：进程发现了错误而退出。可以看如下代码：</p>
<p><strong>严重错误</strong>：进程发生了严重的错误而不得不退出，通常是程序的错误导致，例如执行了一条非法指令，引用不存在的内存，或者除数是0等，出现这些错误时进程默认会退出。而有些时候如果用户想自行处理某种类型的错误，发生不同类型错误时进程会收到不同类型的信号，用户注册处理不同信号的函数即可。</p>
<p><strong>被其它进程杀死</strong>：其它进程执行kill系统调用通知操作系统杀死某个进程。</p>
<p>操作系统如何进行进程管理？</p>
<p>一个数据结构：进程控制块（PCB），操作系统为每个进程都维护一个PCB，用来保存与该进程有关的各种状态信息。进程可以抽象理解为一个PCB，PCB是进程存在的唯一标志，操作系统用PCB来描述进程的基本情况以及运行变化的过程，进程的任何状态变化都会通过PCB来体现。</p>
<p>PCB包含进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其它在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未中断过一样。</p>
<p>中断向量是指中断服务程序的入口地址。一个进程在执行过程中可能会被中断无数次，但是每次中断后，被中断的进程都要返回到与中断发生前完全相同的状态。</p>
<p>进程控制块中存储了什么信息？</p>
<p><strong>进程标识信息</strong>：如本进程的标识，本进程的父进程标识，用户标识等。</p>
<p><strong>处理机状态信息保护区</strong>：用于保存进程的运行现场信息：</p>
<p>  用户可见寄存器：用户程序可以使用的数据，地址等寄存器</p>
<p>  控制和状态寄存器：程序计数器，程序状态字</p>
<p>  栈指针：过程调用、系统调用、中断处理和返回时需要用到它</p>
<p><strong>进程控制信息</strong>：</p>
<p>  调度和状态信息：用于操作系统调度进程使用</p>
<p>  进程间通信信息：为支持进程间与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中</p>
<p>  存储管理信息：包含有指向本进程映像存储空间的数据结构进程所用资源：说明由进程打开使用的系统资源，如打开的文件等</p>
<p>  有关数据结构连接信息：进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB</p>
<p>进程如何进行生命周期管理？</p>
<p><strong>进程创建</strong>：创建进程有三个主要事件：</p>
<p>  系统初始化</p>
<p>  用户请求创建一个新进程</p>
<p>  一个正在运行的进程执行创建进程的系统调用</p>
<p><strong>进程运行</strong>：内核根据调度策略选择一个就绪的进程，让它占用CPU并运行。</p>
<p><strong>进程等待</strong>：在以下情况下进程会等待（阻塞）：</p>
<p>  请求并等待系统服务，</p>
<p>  无法马上完成启动某种操作，</p>
<p>  无法马上完成需要的数据没有到达。</p>
<p>注意：进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生。</p>
<p><strong>进程唤醒</strong>：进程只能被别的进程或操作系统唤醒，唤醒进程的原因有：</p>
<p>  被阻塞进程需要的资源可被满足</p>
<p>  被阻塞进程等待的事件到达</p>
<p>  将该进程的PCB插入到就绪队列</p>
<p><strong>进程结束</strong>：在以下四种情况下进程会结束：自愿型正常退出、自愿型错误退出、强制型致命错误退出、强制型被其它进程杀死退出</p>
<p>进程都有什么状态？</p>
<p>不同系统设置的进程状态是不同的，多数系统中的进程在生命结束前有三种基本状态，进程只会处于三种基本状态之一：</p>
<p><strong>运行状态</strong>：进程正在CPU上运行时就处在运行状态，该时刻进程时钟占用着CPU；</p>
<p><strong>就绪状态</strong>：进程已经获得了除CPU之外的一切所需资源，一旦得到CPU就可以运行；就绪态中的进程其实可以运行，但因为其它进程正在占用着CPU而暂时停止运行；</p>
<p><strong>等待状态（阻塞状态）</strong>：进程正在等待某一事件而暂停运行，等待某个资源或者等待输入输出完成。除非某种外部事件发生，否则阻塞态的进程不能运行；</p>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%AC%94%E8%AE%B0.assets/640" alt="图片"></p>
<p>什么是进程挂起？为什么会出现进程挂起？</p>
<p>进程挂起就是为了合理且充分的利用系统资源，把一个进程从内存转到外存。进程在挂起状态时，意味着进程没有占用内存空间，处在挂起状态的进程映射在磁盘上。进程挂起通常有两种状态：</p>
<p>  阻塞挂起状态：进程在外存并等待某事件的出现；</p>
<p>  就绪挂起状态：进程在外存，但只要进入内存即可运行。</p>
<p>进程挂起可能有以下几种情况：</p>
<p>  <strong>阻塞到阻塞挂起</strong>：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程；</p>
<p>  <strong>就绪到就绪挂起</strong>：当有高优先级阻塞进程或低优先级就绪进程时，系统会选择挂起低优先级就绪进程；</p>
<p>  <strong>运行到就绪挂起</strong>：对于抢占式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态；</p>
<p>  <strong>阻塞挂起到就绪挂起</strong>：当有阻塞挂起进程有相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。</p>
<p>  <strong>有进程挂起那就有进程解挂：指一个进程从外存转到内存，相关状态有</strong>：</p>
<p>  <strong>就绪挂起到就绪</strong>：没有就绪进程或就绪挂起进程优先级高于就绪进程时，就会进行这种转换；</p>
<p>  <strong>阻塞挂起到阻塞</strong>：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起进程转换为阻塞进程。</p>
<p>####什么是进程调度？操作系统对于进程调度都有什么策略？</p>
<p>当系统中有多个进程同时竞争CPU，如果只有一个CPU可用，那同一时刻只会有一个进程处于运行状态，操作系统必须要选择下一个要运行的是哪个进程，在操作系统中，完成选择工作的这部分称为调度程序，该程序使用的算法称作<strong>调度算法</strong>。</p>
<p><strong>什么时候进行调度</strong>？</p>
<p>系统调用创建一个新进程后，需要决定是运行父进程还是运行子进程</p>
<p>一个进程退出时需要做出调度决策，需要决定下一个运行的是哪个进程</p>
<p>当一个进程阻塞在I/O和信号量或者由于其它原因阻塞时，必须选择另一个进程运行</p>
<p>当一个I/O中断发生时，如果中断来自IO设备，而该设备现在完成了工作，某些被阻塞的等待该IO的进程就成为可运行的就绪进程了，是否让新就绪的进程运行，或者让中断发生时运行的进程继续运行，或者让某个其它进程运行，这就取决于调度程序的抉择了。</p>
<p><strong>调度算法可以分类：</strong></p>
<ul>
<li><p><strong>非抢占式调度算法</strong>：挑选一个进程，然后让该进程运行直至被阻塞，或者直到该进程自动释放CPU，即使该进程运行了若干个小时，它也不会被强迫挂起。这样做的结果是，在时钟中断发生时不会进行调度，在处理完时钟中断后，如果没有更高优先级的进程等待，则被中断的进程会继续执行。简单来说，调度程序必须等待事件结束。</p>
<p>非抢占方式引起进程调度的条件：</p>
<ul>
<li>进程执行结束，或发生某个事件而不能继续执行</li>
<li>正在运行的进程因有I/O请求而暂停执行</li>
<li>进程通信或同步过程中执行了某些原语操作（wait、block等）</li>
</ul>
</li>
<li><p><strong>抢占式调度算法</strong>：挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行，进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便CPU控制返回给调度程序，如果没有可用的时钟，那么非抢占式调度就是唯一的选择。简单来说，就是当前运行的进程在事件没结束时就可以被换出，防止单一进程长时间独占CPU资源。</p>
</li>
</ul>
<p><strong>调度策略</strong>：</p>
<p>  不同系统环境下有不同的调度策略算法。调度算法也是有KPI的，对调度算法首先提的需求就是：</p>
<ul>
<li><p><strong>公平</strong>：调度算法需要给每个进程公平的CPU份额，相似的进程应该得到相似的服务，对一个进程给予较其它等价的进程更多的CPU时间是不公平的。</p>
</li>
<li><p><strong>执行力</strong>：每一个策略必须强制执行，需要保证规定的策略一定要被执行。</p>
</li>
<li><p><strong>平衡</strong>：需要保证系统的所有部分尽可能都忙碌</p>
</li>
</ul>
<p>但是因为不同的应用有不同的目标，不同的系统中，调度程序的优化也是不同的，大体可以分为三种环境：</p>
<ul>
<li><p>批处理系统</p>
<ul>
<li>批处理系统的管理者为了掌握系统的工作状态，主要关注三个指标：</li>
<li>吞吐量：是系统每小时完成的作业数量</li>
<li>周转时间：指从一个作业提交到完成的平均时间</li>
<li>CPU利用率：尽可能让CPU忙碌，但又不能过量</li>
</ul>
<p>调度算法：</p>
<ul>
<li><strong>先来先服务</strong>（FCFS/FIFO）：进程按照它们请求CPU的顺序来使用CPU，该算法最大的优点就是简单易于实现，但平均等待时间波动较大，时间短的任务可能排队排在了时间长的任务后面。</li>
<li><strong>最短执行时间进程优先</strong>：该调度算法是非抢占式的算法，每个进程执行期间不会被打断，每次都选择执行时间最短的进程来调度，但操作系统可能不知道进程具体的执行时间，所以该算法注定是基于预测性质的理想化算法，而且有违公平性，而且可能导致运行时间长的任务得不到调度。</li>
<li><strong>最短剩余时间优先</strong>：该调度算法是抢占式的算法，是最短进程优先的抢占版本，在进程运行期间，如果来了个更短时间的进程，那就转而去把CPU时间调度给这个更短时间的进程，它的缺点和最短进程优先算法类似。</li>
</ul>
</li>
<li><p>交互式系统</p>
<p>对于交互系统最重要的指标就是响应时间和均衡性：</p>
<ul>
<li><p>响应时间：一个请求被提交到产生第一次响应所花费的时间。</p>
</li>
<li><p>均衡性：减少平均响应时间的波动。需要符合固有期望和预期，</p>
</li>
</ul>
<p>调度算法：</p>
<ul>
<li><p><strong>轮转调度</strong>：基于时钟的抢占策略，每个进程被分配一个时间段，称为时间片，CPU根据周期性的时钟中断，在多个进程间快速切换，进程仅允许在时间片内运行，所有进程具有相同优先级。时间片太短会导致过多的进程切换，频繁的上下文切换会降低CPU效率，而如果时间片设的太长又可能对短的交互请求的响应时间变长。</p>
</li>
<li><p><strong>优先级调度</strong>：简单的轮转调度算法中默认每个进程具有相同优先级，在优先级调度算法中，每个优先级都有相应的队列，队列里面装着对应优先级的进程，首先在高优先级队列中进行轮转调度，当高优先级队列为空时，转而去低优先级队列中进行轮转调度，如果高优先级队列始终不为空，那么低优先级的进程很可能就会饥饿到很久不能被调度。</p>
</li>
<li><p><strong>多级反馈队列</strong>：多级队列算法与优先级调度算法不同，优先级算法中每个进程分配的是相同的时间片，而在多级队列算法中，不同队列中的进程分配给不同的时间片，当一个进程用完分配的时间片后就移动到下一个具有更多时间片的队列中，这样可以更好的避免上下文频繁切换。</p>
</li>
<li><p><strong>最短执行进程进程优先</strong>：交互式系统中应用最短进程优先算法其实是非常适合的，每次都选择执行时间最短的进程进行调度，这样可以使任务的响应时间最短，没有办法非常准确的在当前可运行进程中找出最短的进程，有一种办法就是根据进程过去的行为进行预测。</p>
</li>
<li><p><strong>保证调度</strong>：这种调度算法就是向用户做出明确的可行的性能保证，然后去实现它。一种很实际的可实现的保证就是确保N个用户中每个用户都获得CPU处理能力的1/N，类似的，保证N个进程中每个进程都获得1/N的CPU时间。</p>
</li>
<li><p><strong>彩票调度</strong>彩票调度算法基本思想是为进程提供各种资源（CPU时间）的彩票，一旦需要做出调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源，很明显，拥有彩票越多的进程，获得资源的可能性越大。</p>
</li>
<li><p><strong>公平分享调度</strong></p>
<p>上述调度算法考虑的都是单个用户下的进程池。在多用户系统中，用户关心的是构成应用程序的一组进程（而不是特定进程）如何执行。公平共享调度是基于进程组的调度策略。</p>
<p>每个用户被指定了某种类型的权值，该权值定义了用户对系统资源的共享，即用户占用的资源在所有可使用资源中的比例。</p>
<p>假设有系统两个用户，用户1启动了1个进程，用户2启动了9个进程，如果使用轮转调度算法，那么用户1将获得10%的CPU时间，用户2将获得90%的CPU时间。</p>
</li>
</ul>
</li>
<li><p>实时系统</p>
<p>实时系统最关键的指标是实时性：</p>
<ul>
<li>满足截止时间：需要在规定期限前完成作业；</li>
<li>可预测性：可预测性是指在系统运行的任何时刻，在任何情况下，实时系统的资源调配策略都能为争夺资源的任务合理的分配资源，使每个实时任务都能得到满足。</li>
</ul>
<p>调度算法分类：</p>
<ul>
<li><strong>硬实时</strong>：必须在规定期限之前完成工作，如果延迟则可能会发生灾难性或发生严重的后果；</li>
<li><strong>软实时</strong>：必须在规定期限之前完成工作，但如果偶尔延迟了，也可以容忍。</li>
</ul>
<p>调度算法：</p>
<ul>
<li><strong>单调速率调度</strong>：采用抢占式、静态优先级的策略，调度周期性任务。每个任务最开始都被配置好了优先级，当较低优先级的进程正在运行并且有较高优先级的进程可以运行时，较高优先级的进程将会抢占低优先级的进程。在进入系统时，每个周期性任务都会分配一个优先级，周期越短，优先级越高。这种策略的理由是：更频繁的需要CPU的任务应该被分配更高的优先级。</li>
<li><strong>最早截止时间调度</strong>：根据截止时间动态分配优先级，截止时间越早的进程优先级越高。该算法中，当一个进程可以运行时，它应该向操作系统通知截止时间，根据截止时间的早晚，系统会为该进程调整优先级，以便满足可运行进程的截止时间要求。它与单调速率调度算法的区别就是一个是静态优先级，一个是动态优先级。</li>
</ul>
</li>
</ul>
<p><strong>如何配置调度策略？</strong></p>
<p>调度算法有很多种，各有优缺点，操作系统自己很少能做出最优的选择，那么可以把选择权交给用户，由用户根据实际情况来选择适合的调度算法，这就叫策略与机制分离，调度机制位于内核，调度策略由用户进程决定，将调度算法以某种形式参数化，由用户进程来选择参数从而决定内核使用哪种调度算法。</p>
<p><strong>操作系统怎么完成进程调度？</strong></p>
<p>进程的每次变化都会有相应的状态，而操作系统维护了一组状态队列，表示系统中所有进程的当前状态；不同的状态和同一个状态的不同的优先级都有不同的队列，有就绪队列、阻塞队列等，每个进程的PCB都根据它的状态加入到相应的队列中，当一个进程的状态发生变化时，它的PCB会从一个状态队列中脱离出来加入到另一个状态队列。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9lFFFiaKpEr8Pnej5HSUaPCia1zguc4Kbh0KM76luxZCsRicZBsaLrx9snP0acox4yKbIGg3mDmCfwwB9yMSamwfA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>多处理器调度：</p>
<ul>
<li>负载分配：系统维护一个就绪线程的全局队列，每个处理器只要空闲就从队列中选择一个线程运行。</li>
<li>组调度：一组相关的线程按照一对一的原则，同时调度到一组处理器上运行。</li>
<li>专用处理器分配：把线程指定到特定处理器。每个程序在其执行过程中，都分配有一组处理器，处理器数量与程序中线程数量相等，即将每个线程都分配给一个专用处理器，直至程序结束。</li>
<li>动态调度：</li>
</ul>
<p>####什么是线程？</p>
<p>  线程是进程当中的一条执行流程，一个进程内可以有多个子执行流程，即线程。</p>
<h4 id="为什么使用线程？"><a href="#为什么使用线程？" class="headerlink" title="为什么使用线程？"></a>为什么使用线程？</h4><p>因为要并发编程，在许多情形中同时发生着许多活动，而某些活动有时候会被阻塞，通过将这些活动分解成可以准并行运行的多个顺序流程是必须的，而如果使用多进程方式进行并发编程，进程间的通信也很复杂，并且维护进程的系统开销较大：创建进程时分配资源建立PCB，撤销进程时回收资源撤销PCB，进程切换时保存当前进程的状态信息。所以为了使并发编程的开销尽量小，所以引入多线程编程，可以并发执行也可以共享相同的地址空间。并行实体拥有共享同一地址空间和所有可用数据的能力，这是多进程模型所不具备的能力。</p>
<p>使用线程有如下优点：</p>
<ul>
<li><p>可以多个线程存在于同一个进程中</p>
</li>
<li><p>各个线程之间可以并发的执行</p>
</li>
<li><p>各个线程之间可以共享地址空间和文件等资源</p>
</li>
<li><p>线程比进程更轻量级，创建线程撤销线程比创建撤销进程要快的多，在许多系统中，创建一个线程速度是创建一个进程速度的10-100倍。</p>
</li>
<li><p>如果多个线程是CPU密集型的，并不能很好的获得更好的性能，但如果多个线程是IO密集型的，线程存在着大量的计算和大量的IO处理，有多个线程允许这些活动彼此重叠进行，从而会加快整体程序的执行速度。</p>
</li>
</ul>
<p>但也有缺点：</p>
<ul>
<li><p>一旦一个线程崩溃，会导致其所属进程的所有线程崩溃。</p>
</li>
<li><p>由于各个线程共享相同的地址空间，那么读写数据可能会导致竞争关系，因此对同一块数据的读写需要采取某些同步机制来避免线程不安全问题。</p>
</li>
</ul>
<h4 id="什么时候用进程、线程？"><a href="#什么时候用进程、线程？" class="headerlink" title="什么时候用进程、线程？"></a>什么时候用进程、线程？</h4><ul>
<li><p>进程是资源分配单位，线程是CPU调度单位；</p>
</li>
<li><p>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</p>
</li>
<li><p>线程同样具有就绪阻塞和执行三种基本状态，同样具有状态之间的转换关系；</p>
</li>
<li><p>线程能减少并发执行的时间和空间开销：</p>
<ul>
<li>线程的创建时间比进程短</li>
<li>线程的终止时间比进程短</li>
<li>同一进程内的线程切换时间比进程短</li>
<li>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信</li>
</ul>
</li>
</ul>
<h4 id="线程是如何实现的？线程的实现可分为用户线程和内核线程："><a href="#线程是如何实现的？线程的实现可分为用户线程和内核线程：" class="headerlink" title="线程是如何实现的？线程的实现可分为用户线程和内核线程："></a>线程是如何实现的？线程的实现可分为用户线程和内核线程：</h4><p>  <strong>用户线程</strong>：在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建终止同步和调度等。</p>
<p>用户线程有如下优点：</p>
<ul>
<li><p>由于用户线程的维护由相应进程来完成（通过线程库函数），不需要操作系统内核了解内核了解用户线程的存在，可用于不支持线程技术的多进程操作系统。</p>
</li>
<li><p>每个进程都需要它自己私有的线程控制块列表，用来跟踪记录它的各个线程的状态信息（PC，栈指针，寄存器），TCB由线程库函数来维护；</p>
</li>
<li><p>用户线程的切换也是由线程库函数来完成，无需用户态/核心态切换，所以速度特别快；</p>
</li>
<li><p>允许每个进程拥有自定义的线程调度算法；</p>
</li>
</ul>
<p>但用户线程也有缺点：</p>
<ul>
<li><p>如果一个线程发起系统调用而阻塞，则整个进程在等待。</p>
</li>
<li><p>当一个线程开始运行后，除非它主动交出CPU的使用权，否则它所在进程当中的其它线程将无法运行；</p>
</li>
<li><p>由于时间片分配给进程，与其它进程比，在多线程执行时，每个线程得到的时间片较少。</p>
</li>
</ul>
<p><strong>内核线程</strong>：是指在操作系统的内核中实现的一种线程机制，由操作系统的内核来完成线程的创建终止和管理。</p>
<p>  在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息（PCB TCB）；</p>
<p>  线程的创建终止和切换都是通过系统调用内核函数的方式来进行，由内核来完成，因此系统开销较大；</p>
<p>  在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其它内核线程的运行；</p>
<p>  时间片分配给线程，多线程的进程获得更多CPU时间；</p>
<p>由于在内核中创建或撤销线程的代价比较大，某些系统采取复用的方式回收线程，当某个线程被撤销时，就把它标记不可运行，但是内核数据结构没有受到任何影响，如果后续又需要创建一个新线程时，就重新启动被标记为不可运行的旧线程，从而节省一些开销。</p>
<p><strong>轻量级进程</strong>：它是内核支持的用户线程模型，一个进程可以有多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。在Linux下是没有真正的线程的，它所谓的线程其实就是使用进程来实现的，就是所谓的轻量级进程，其实就是进程，都是通过clone接口调用创建的，只不过两者传递的参数不同，通过参数决定子进程和父进程共享的资源种类和数量，进而有了普通进程和轻量级进程的区别。</p>
<h4 id="什么是上下文切换？"><a href="#什么是上下文切换？" class="headerlink" title="什么是上下文切换？"></a>什么是上下文切换？</h4><p>上下文切换指的是操作系统停止当前运行线程（从运行状态改变成其它状态）并且调度其它线程（就绪态转变成运行状态）。操作系统必须在切换之前存储许多部分的线程上下文，必须能够在之后恢复它们。同时切换上下文这个过程必须快速，因为上下文切换操作是非常频繁的。</p>
<p>上下文指的是任务所有共享资源的工作现场，每一个共享资源都有一个工作现场，包括用于处理函数调用、局部变量分配以及工作现场保护的栈顶指针，和用于指令执行等功能的各种寄存器。</p>
<h4 id="进程间通信有几种方式？"><a href="#进程间通信有几种方式？" class="headerlink" title="进程间通信有几种方式？"></a>进程间通信有几种方式？</h4><p>由于各个进程不共享相同的地址空间，任何一个进程的全局变量在另一个进程中都不可见，所以如果想要在进程之间传递数据就需要通过内核，在内核中开辟出一块区域，该区域对多个进程都可见，即可用于进程间通信。</p>
<ul>
<li><p><strong>匿名管道</strong></p>
<p>匿名管道就是<strong>pipe</strong>，pipe只能在父子进程间通信，而且数据只能<strong>单向流动</strong>（半双工通信）。</p>
<p>使用方式：</p>
<ul>
<li>父进程创建管道，会得到两个文件描述符，分别指向管道的两端；</li>
<li>父进程创建子进程，从而子进程也有两个文件描述符指向同一管道；</li>
<li>父进程可写数据到管道，子进程就可从管道中读出数据，从而实现进程间通信，</li>
</ul>
</li>
</ul>
<p>使用关于管道的命令行：<code>ls | less</code>，该命令行的流向图如下：1：shell创建管道， 2：为ls创建一个进程，设置stdout为管理写端， 3：为less创建一个进程，设置stdin为管道读端</p>
<ul>
<li><strong>高级管道</strong></li>
</ul>
<p>​    通过popen将另一个程序当作一个新的进程在当前进程中启动，它算作当前进程的子进程，高级管道只能用在有亲缘关系的进程间通信，这种亲缘关系通常指父子进程。</p>
<ul>
<li><p><strong>命名管道</strong></p>
<p>匿名管道有个缺点就是通信的进程一定要有亲缘关系，而命名管道就不需要这种限制。命名管道其实就是一种特殊类型的文件，所谓的命名其实就是文件名，文件对各个进程都可见，通过命名管道创建好特殊文件后，就可以实现进程间通信。</p>
</li>
<li><p><strong>消息队列</strong></p>
<p>可以有多个进程向队列中写入数据，也可以有多个进程从队列里读出数据。消息队列中的每个消息可以赋予类型，从消息队列读消息时不一定要使用先进先出的顺序，可以按消息的类型读取，非指定类型的消息继续保留在队列中。本质上MessageQueue是存放在内核中的消息链表，每个消息队列链表会由消息队列标识符表示，这个消息队列存于内核中，只有主动的删除该消息队列或者内核重启时，消息队列才会被删除。</p>
<p><strong>消息队列VS命名管道</strong></p>
<ul>
<li>消息队列收发消息自动保证了同步，不需要由进程自己来提供同步方法，而命名管道需要自行处理同步问题；</li>
<li>消息队列接收数据可以根据消息类型有选择的接收特定类型的数据，不需要像命名管道一样默认接收数据。</li>
<li>消息队列有一个缺点就是发送和接收的每个数据都有最大长度的限制。</li>
</ul>
</li>
<li><p><strong>共享内存</strong></p>
<p>可开辟中一块内存，用于各个进程间共享，使得各个进程可以直接读写同一块内存空间，就像线程共享同一块地址空间一样，该方式基本上是最快的进程间通信方式，因为没有系统调用干预，也没有数据的拷贝操作，但由于共享同一块地址空间，数据竞争的问题就会出现，需要自己引入同步机制解决数据竞争问题。</p>
<p>共享内存只是一种方式，它的实现方式有很多种，主要的有mmap系统调用、Posix共享内存以及System V共享内存等。通过这三种“工具”共享地址空间后，通信的目的自然就会达到。</p>
</li>
<li><p><strong>信号</strong></p>
<p>信号也是进程间通信的一种方式，信号可以在任何时候发送给某一个进程，如果进程当前并未处于执行状态，内核将信号保存，直到进程恢复到执行态再发送给进程，进程可以对信号设置预处理方式，如果对信号设置了阻塞处理，则信号的传递会被延迟直到阻塞被取消，如果进程结束，那信号就被丢弃。我们常用的CTRL+C和kill等就是信号的一种，也达到了进程间通信的目的，进程也可以对信号设置signal捕获函数自定义处理逻辑。这种方式有很大的缺点：只有通知的作用，通知了一下消息的类型，但不能传输要交换的任何数据。</p>
</li>
</ul>
<p>​     Linux系统中常见的信号有：</p>
<p>​       SIGHUP：该信号在用户终端结束时发出，通常在中断的控制进程结束时，所有进程组都将收到该信号，该信号的默认操作是终止进程；</p>
<p>​       SIGINT：程序终止信号，通常的CTRL+C产生该信号来通知终止进程；</p>
<p>​       SIGQUIT：类似于程序错误信号，通常的CTRL+\产生该信号通知进程退出时产生core文件；</p>
<p>​       SIGILL：执行了非法指令，通常数据段或者堆栈溢出可能产生该信号；</p>
<p>​       SIGTRAP：供调试器使用，由断电指令或其它陷阱指令产生；</p>
<p>​       SIGABRT：使程序非正常结束，调用abort函数会产生该信号；</p>
<p>​       SIGBUS：非法地址，通常是地址对齐问题导致，比如访问一个4字节长的整数，但其地址不是4的倍数；</p>
<p>​       SIGSEGV：合理地址的非法访问，访问了未分配的内存或者没有权限的内存区域；</p>
<p>​       SIGPIPE：管道破裂信号，socket通信时经常会遇到，进程写入了一个无读者的管道；</p>
<p>​       SIGALRM：时钟定时信号，由alarm函数设置的时间终止时产生；</p>
<p>​       SIGFPE：出现浮点错误（比如除0操作）；</p>
<p>​       SIGKILL：杀死进程（不能被捕捉和忽略）；</p>
<ul>
<li><p><strong>信号量</strong></p>
<p>信号量就是一个特殊的变量，程序对其访问都是原子操作，每个信号量开始都有个初始值。最简单最常见的信号量是只能取0和1的变量，也叫二值信号量。</p>
<p>信号量有两个操作，P和V：</p>
</li>
</ul>
<p>​    P（down/wait）：如果信号量变量值大于0，则变量值减1，如果值为0，则阻塞进程；</p>
<p>​    V (up/signal)：如果有进程阻塞在该信号量上，则唤醒阻塞的进程，如果没有进程阻塞，则变量值加1</p>
<p>  信号量和信号没有任何关系，完全是不同的东西。</p>
<p>  互斥量用于<strong>互斥</strong>，信号量用于<strong>同步</strong>，互斥指的是某一资源同一时间只允许一个访问者访问，但无法限制访问顺序，访问是无序的，而同步在互斥的基础上可以控制访问者对资源的顺序。</p>
<ul>
<li><p><strong>套接字</strong>：</p>
</li>
<li><p><strong>文件</strong>：</p>
</li>
</ul>
<h3 id="JAVA中的NIO"><a href="#JAVA中的NIO" class="headerlink" title="JAVA中的NIO"></a>JAVA中的NIO</h3><p>JAVA BIO是面向流的，每次从流中读取一个或多个字节，直至读完，数据没有缓存在任何地方，也不能前后移动流中的数据，如果需要前后移动则需要额外将从流中读取到的数据缓存到一个缓存区。</p>
<p>JAVA NIO是面向缓存区的，数据直接读取/写入到一个缓存区，需要时可以在缓存区中前后移动，</p>
<p>JAVA BIO中流是阻塞的，当一个线程调用read() 或write()时，该线程被阻塞，直到有数据被读取或者数据写入。该线程在阻塞期间不能做其他事情。</p>
<p>JAVA NIO是非阻塞的，如果通道不可读/写，读写函数马上返回，而不会阻塞。线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程可以管理多个输入和输出通道（channel），即IO多路复用的原理。</p>
<p>JAVA BIO中调用操作系统提供的底层标准IO系统调用函数read()、write() ，此时调用此函数的进程（在JAVA中即java进程）由当前的用户态切换到内核态，然后OS的内核代码负责将相应的文件数据读取到内核的IO缓冲区，然后再把数据从内核IO缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。</p>
<p>JAVA NIO并不需要将数据拷贝到进程的私有地址空间中，而是直接将数据在内核IO缓冲区中的地址区域与进程的用户私有地址空间建立起映射关系，从而减少了一次CPU拷贝。</p>
<p>JAVA NIO主要由Channel、Buffer、Selector组成。数据只能从Channel读到Buffer，也只能将Buffer中的内容写入Channel。</p>
<p>JAVA NIO中的主要Channel实现：FileChannel(file)、DatagramChannel(UDP)、SocketChannel(TCP)、ServerSocketChannel(TCP)。通过 ServerSocketChannel.accept() 方法监听新进来的连接。当 accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞到有新连接到达。通常不会仅仅只监听一个连接,在while循环中调用 accept()方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开 ServerSocketChannel</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="comment">//do something with socketChannel...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭ServerSocketChannel</span></span><br><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure>



<p>Buffer本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。Buffer实现主要有：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer，分别对应基本数据类型：byte、short、int、long、float、double和char。</p>
<p>Selector允许单线程处理多个 Channel。首先向Selector注册Channel，然后调用Selector的select()方法，该方法会一直阻塞到某个注册的通道有事件就绪（有新连接进来，数据接收等）。一旦这个方法返回，线程就可以处理这些事件。</p>
<h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9TyvNCUZ5V9vVVL9KicIukrtXUBfGpPL3Ngoe2os48MDXAu2FnGTQcdGFaqXRh6puSialDbX5SlPkSqw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li><p>需求分析阶段</p>
<p>  基本思想是用系统工程的思想和工程化得方法，根据用户至上的原则，自始自终按照结构化、模块化，自顶向下地对系统进行分析与设计。建立的主要步骤如下：</p>
<ol>
<li>首先画系统的输入输出，先画顶层数据流程图（DFD：Data Flow Diagram），顶层数据流程图只包含一个加工，用以表示被开发的系统，然后考虑该系统有哪些输入、输出数据流。</li>
<li>画系统内部，即画下层数据流层图。</li>
</ol>
</li>
<li><p>概念设计阶段</p>
<p>  对需求分析阶段的成果进行综合，归档以及抽象出一个独立具体的 DBMS 模型，与具体的 RDBMS 产品无关。</p>
<p>  在实际的开发中，常用 E-R（Entity-Relationship：实体关系）图来表示，常用的工具 PowerDesigner，可以实现 CDM（概念数据模型）-&gt;LDM（逻辑数据模型）-&gt;PDM（物理数据模型）-&gt;Database 的自动转换，这个过程称为<strong>正向工程</strong>，如果有 database 建库脚本，也可以通过 PowerDesigner 工具生成 CDM，即 Database-&gt;PDM-&gt;LDM-&gt;CDM，称为<strong>反向工程</strong>。</p>
<p>  概念设计通常采用自底向上，首先定义各系统局部的概念模型，然后再将他们集成合并起来，得到全局的概念模型。</p>
<p>  <strong>数据库设计三大范式</strong></p>
<ul>
<li>第一范式1NF：确保每个字段保持原子性，不可分割。</li>
<li>第二范式2NF：确保字段完全依赖于主键。</li>
<li>第三范式3NF：必须满足 2NF，实体中每个属性与主键直接相关而不能间接相关。</li>
</ul>
</li>
<li><p>逻辑设计阶段</p>
<p>  将概念数据模型转换为具体的 DBMS 所支持的数据模型，在此阶段，各子模块的 E-R 图之间的冲突主要有三类：属性冲突，命名冲突和结构冲突，同时 E-R 图向关系模型的转换，要解决如何将实体性和实体间的联系转换为关系模式，确定这些关系模式的属性和码，</p>
</li>
<li><p>数据库选型</p>
<p>  数据库方面主要包括数据存储，检索，安全，读写分离，分库分表，数据归档，接入数据仓库都要进行确认，根据业务的场景对相关的数据库产品进行调研比对，选择最适合业务场景的数据库作为存储。</p>
</li>
<li><p>物理设计阶段</p>
<p>  设计跟 RDBMS 相关的对象，例如设计存储过程，触发器，用户自定义函数，表空间等。</p>
</li>
<li><p>数据库实施阶段</p>
<p>  通过 PDM 生成数据库的建库脚本之后，需要进行规范性检查，通过之后就可以创建表结构。</p>
</li>
<li><p>数据库维护阶段</p>
<p>业务支撑：数据库版本变更、数据同步、数据归档、读写分离、分库分表等。</p>
<p>数据库运维：</p>
<p>  监控：基础资源（CPU\内存\IOPS\网络输入输出等）、数据库性能（TPS\QPS\缓存命中\主从延迟等）。</p>
<p>  告警：监控到异常指标时向维护人员发送警报。</p>
<p>  数据库备份、异地容灾、迁移升级（缩扩容、数据库软件版本等）、管理平台开发。</p>
<p><img src="%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%AC%94%E8%AE%B0.assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4.png" alt="图片"></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%AC%94%E8%AE%B0/" data-id="ckmn1ijik000qn8a84mxe0h8q" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-简历-徐博" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/%E7%AE%80%E5%8E%86-%E5%BE%90%E5%8D%9A/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.576Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>姓名：徐博</p>
<p>电话：130-0710-3240</p>
<p>邮箱：<a href="mailto:&#x78;&#98;&#111;&#55;&#55;&#53;&#64;&#111;&#x75;&#x74;&#x6c;&#x6f;&#x6f;&#107;&#46;&#x63;&#x6f;&#x6d;">&#x78;&#98;&#111;&#55;&#55;&#53;&#64;&#111;&#x75;&#x74;&#x6c;&#x6f;&#x6f;&#107;&#46;&#x63;&#x6f;&#x6d;</a></p>
<p>出生年月：1998年3月</p>
<p>籍贯：湖南省岳阳市</p>
<p>现住址：湖北省武汉市</p>
<p>政治面貌：中共预备党员</p>
<h2 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h2><ul>
<li><p>2015.9-2019.6 武汉大学 电子信息学院 电子信息工程</p>
<p>保研综合排名：6/94</p>
</li>
<li><p>2019.9-至今 武汉大学 电子信息学院 信息与通信工程 </p>
<p>先进网络与智能系统实验室 未来网络小组</p>
</li>
</ul>
<h2 id="奖项荣誉"><a href="#奖项荣誉" class="headerlink" title="奖项荣誉"></a>奖项荣誉</h2><ul>
<li><p>2015-2016、2016-2017学年武汉大学丙等奖学金、优秀学生。</p>
</li>
<li><p>2017-2018学年武汉大学甲等奖学金、国家励志奖学金、三好学生。</p>
</li>
<li><p>2019年武汉大学优秀毕业生。</p>
</li>
<li><p>2017年华中地区数学建模竞赛邀请赛二等奖。</p>
</li>
<li><p>2017年“Xilinx杯”全国大学生FPGA创新设计邀请赛国家三等奖。</p>
</li>
<li><p>2018年“Intel杯”全国大学生电子设计竞赛嵌入式系统专题邀请赛国家二等奖</p>
</li>
</ul>
<h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><p>硕士研究生阶段主要聚焦于ONF开源框架下具有可编程数据平面的软件定义网络研究，</p>
<ul>
<li><p>使用Prometheus监控系统+InfluxDB时序数据库+Grafana可视化工具+INT技术监控具有可编程数据平面的软件定义网络的网络状态参数。</p>
<p>本人的工作主要是搭建整个平台、研究Prometheus、INT运行原理，优化终端网络状态数据解析代码、处理数据。</p>
</li>
<li><p>使用Mininet网络仿真平台+BMv2可编程软件交换机+P4Runtime南向协议实现自定义的控制器和网络仿真。</p>
<p>本人的工作主要是搭建网络仿真环境、研究Mininet仿真原理、编写P4程序与仿真程序、研究P4Runtime南向协议、编写基于P4Runtime的简易控制器。</p>
</li>
</ul>
<p>研究生阶段的项目主要目的是追踪可编程数据平面的前沿研究方向，偏向于原理研究，而非生产性质。</p>
<h2 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h2><ul>
<li>掌握Java语言，掌握P4语言，熟悉Python语言，了解Linux Shell编程。</li>
<li>掌握MySQL与JVM，了解gRPC、Docker等。</li>
<li>了解软件定义网络、可编程数据平面、计算机网络、Git等技术。</li>
<li>较好的英语阅读与源码阅读能力，较强的钻研精神，对新技术保持较高的热情。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/%E7%AE%80%E5%8E%86-%E5%BE%90%E5%8D%9A/" data-id="ckmn1ijg2000dn8a864y43jut" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.554Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>中断：</p>
<p>程序中断：算术溢出、除数为0、非法访问等。</p>
<p>时钟中断：定时器中断等。</p>
<p>I/O中断：I/O控制器发送信号通知CPU操作完成或失败等。</p>
<p>硬件失效中断：掉电、存储器奇偶校验错等。</p>
<p>中断时需要把程序状态字PSW和程序计数器PC压入控制栈，然后转向中断服务程序。中断处理完成后再恢复先前的PSW和PC。</p>
<p>处理多个中断：1. 进入中断时禁止再处理中断，其间发生的中断被挂起，未考虑相对优先级和时间限制。 2. 定义中断优先级，高优先级中断可打断低优先级中断。</p>
<p>存储器层次结构：寄存器、高速缓存、内存、硬盘、光盘、磁带。</p>
<p>处理器访问存储器的频率按层次结构递减：局部性原理，执行程序期间，处理器的指令和数据访存呈簇状，即程序会重复访问一个小范围内的指令和数据集合。</p>
<p>高速缓存一致性</p>
<p>直接内存访问DMA</p>
<p>串行处理：用户必须顺序访问计算机。</p>
<p>简单批处理：由监控程序负责执行作业。依赖于处理器可以跳转执行指令，交替地获取或释放控制权。具备==内存保护、定时器、特权指令、中断==等硬件功能。用户程序以==用户模式==执行，不允许访问某些受保护内存区域、不允许执行某些特权指令，监控程序一系统态或==内核模式==运行，可以访问受保护的内存区域，执行特权指令。</p>
<p>多道程序设计或多任务处理：内存中保持操作系统和多个用户程序，依赖==I/O中断==、==直接内存访问==、==内存管理==和==调度算法==。</p>
<p>分时系统：处理器同时处理多个交互作业，多个用户共享处理器时间。</p>
<p>进程：</p>
<p>  一个正在执行的程序、计算机中正在运行的程序的一个实例。</p>
<p>  进程出现错误的主要原因：1. 不正确的同步， 2. 失败的互斥， 3. 不确定的程序调度操作， 4. 死锁。</p>
<p>  进程组成：1. 一段可执行的程序， 2. 程序所需要的相关数据（变量，工作空间，缓冲区等）， 3. 程序的执行上下文，又称进程状态，包括操作系统管理进程及处理器正确执行进程所需的所有信息。</p>
<p>内存管理：</p>
<p>  操作系统的存储器管理职责：进程隔离、自动分配与管理、支持模块化程序设计、保护和访问控制、持久化存储。</p>
<p>  虚拟内存机制允许程序以逻辑方式访问存储器，程序通过虚拟地址访问字，分页系统（内存管理单元）将虚拟地址动态映射为内存中的实际地址或物理地址。</p>
<p>信息保护和安全：</p>
<p>  与操作系统相关的安全和保护问题：可用性、保密性、数据完整性、认证。</p>
<p>调度和资源管理：</p>
<p>  管理各种可用资源（内存空间、I/O设备、处理器），并调度各种活动进程来使用这些资源。</p>
<p>  资源分配和调度策略需要考虑：公平性、有差别的响应性、有效性。</p>
<p>现代操作系统的特征：</p>
<p>  微内核体系结构：相比于将调度、文件系统、网络、设备驱动、存储管理等操作系统功能由一个内核提供，微内核只给内核分配一些最基本的功能，包括地址空间、进程间通信和基本的调度，其他系统服务由运行在用户模式且与其他应用程序类似的进程提供。</p>
<p>  分布式操作系统、多线程、面向对象设计、对称多处理。</p>
<p>容错性：</p>
<p>  可靠性、平均失效时间、平均修复时间、可用性、宕机时间</p>
<p>  通过增加冗余度来实现容错性：</p>
<p>​    空间（物理）冗余：使用多个组件执行相同的功能。</p>
<p>​    时间冗余：检测到错误时重复某一操作。</p>
<p>​    信息冗余：通过复制或编码数据的方式来检测和修复数据。</p>
<p>LINUX主要内核组件：</p>
<p>  信号：内核使用信号来向进程提供信息。</p>
<p>  系统调用：进程通过系统调用来请求系统服务，主要有文件系统、进程、调度、进程间通信、套接字（网络）和其他。</p>
<p>  进程和调度器：创建、管理、调度进程。</p>
<p>  虚拟内存：为进程分配和管理虚拟内存。</p>
<p>  文件系统：为文件、目录和其他文件相关对象提供一个全局的分层命名空间，并提供文件系统函数。</p>
<p>  网络协议：为用户的TCP/IP协议套件提供套接字接口。</p>
<p>  字符设备驱动：管理以单个字节为单位向内核发送、接收数据的设备，例如终端、打印机等。</p>
<p>  块设备驱动：管理以块为单位向内核发送、接受数据的设备，例如各种存储设备。</p>
<p>  网络设备驱动：管理网卡和通信端口。</p>
<p>  陷阱和错误：处理CPU产生的陷阱和错误，如内存错误。</p>
<p>  物理内存：管理实际内存中的内存页池，并为虚拟内存分配内存页。</p>
<p>  中断：处理来自外设的中断。</p>
<p>进程控制块：标识符、状态、优先级、程序计数器、内存指针、上下文数据、I/O状态信息、记账信息。</p>
<p>进程五种状态：</p>
<p>  ==新建态==：刚被创建，还未加入可执行进程组。即该进程的信息已保存在内存中的进程表内，但由于操作系统性能不够而限制了系统中的进程数量或其他原因，进程执行的程序代码还在外存中，内存中也没有分配数据空间。</p>
<p>  新建态-==就绪态==：操作系统准备好再接纳一个进程，进程已在内存中并可以执行。</p>
<p>  就绪态-==运行态==：操作系统的调度器选择一个处于就绪态的进程运行。</p>
<p>  运行态-就绪态：1. 达到时间限制， 2. 被处于就绪态的高优先级进程抢占， 3. 进程自愿释放</p>
<p>  运行态-==退出态==：当前进程表示自身已完成或取消，被操作系统终止。</p>
<p>  ==阻塞态==：进程请求其必须等待的某些事件。</p>
<p>  运行态-阻塞态：1. 操作系统无法立即响应进程的系统服务调用， 2. 进程请求无法立即获得的资源， 3. 等待I/O设备初始化工作完成， 4. 等待其他进程提供输入或信息。</p>
<p>  阻塞态-就绪态：等待的时间发生。</p>
<p>  退出态：进程不再执行，但相关信息会被临时保留。</p>
<p>为每个阻塞事件定义一个队列，等待同一个事件的处于阻塞状态的进程进入同一个队列。为每个优先级定义一个就绪队列，从而容易确定具有最高优先级而等待时间最长的就绪进程。</p>
<p>交换：由于处理器远快于I/O，即使在多道程序中，处理器多数时间仍可能处于空闲状态，因此需要容纳更多进程，方法：1. 扩充内存，但内存价格高，且更大的内存往往导致更大而非更多的进程。 2. 交换，将内存中某些进程的一部分或全部转移到外存中。</p>
<p>==挂起态==：操作系统将处于阻塞状态的进程换出到硬盘中的挂起队列，以释放内存空间供可被调入的其他进程使用，或因父进程请求、长期空闲的定时任务、交互式用户请求等。</p>
<p>阻塞/挂起态：进程在外存中并等待一个事件。</p>
<p>就绪/挂起态：进程在外存中，只要载入内存就可以执行。</p>
<p>阻塞-阻塞/挂起：系统需要更多内存空间，操作系统换出处于阻塞态的进程。</p>
<p>阻塞/挂起-就绪/挂起：等待的事件发生。</p>
<p>就绪/挂起-就绪：内存中没有就绪态进程，或处于就绪/挂起态的进程比处于就绪态的任何进程的优先级更高，操作系统调入处于就绪/挂起态的进程。</p>
<p>就绪-就绪/挂起：操作系统需要更多内存空间，或认为具有更高优先级的阻塞态进程很快将会就绪。</p>
<p>新建-就绪/挂起：新建进程时，操作系统需要创建管理进程的表并分配地址空间，可能出现无足够内存空间的情况，因此转换为挂起态。</p>
<p>阻塞/挂起-阻塞：阻塞/挂起态进程的优先级比任何就绪/挂起态进程的优先级都高，且操作系统认为阻塞进程的时间很快就会发生。</p>
<p>操作系统需要维护内存表、I/O表、文件表、进程表。</p>
<p>进程映像：用户数据、用户程序、栈、进程控制块（任务控制块、进程描述符、任务描述符）。</p>
<p>进程控制块：</p>
<p>  进程标识信息：进程标识符（每个进程都分配有唯一的数字标识符）、父进程标识符、用户标识符。</p>
<p>  处理器状态信息：用户可见寄存器、控制和状态寄存器（程序计数器、条件码、状态信息即程序状态字）、栈指针（用于保存参数和过程调用或系统调用的地址、栈指针指向栈顶）。</p>
<p>  进程控制信息：调度和状态信息（进程状态、优先级、调度相关信息、事件）、数据结构（进程以队列、环或其他结构连接到其他进程，例如同一优先级的就绪态进程可处于同一队列等）、进程间通信（各种标记、信号和信息）、进程特权、存储管理（指向描述分配给该进程的虚存的段表和/或页表的指针）、资源所有权和使用情况（进程控制的资源，例如打开的文件、处理器或其他资源的使用历史等）。</p>
<p>用户模式（非特权模式、用户态）：</p>
<p>内核模式（特权模式、内核态、系统模式）：</p>
<p>操作系统内核典型功能：</p>
<p>  进程管理：进程的创建、调度、切换和终止，进程间同步和通信，管理进程控制块。</p>
<p>  内存管理：内存分配、交换、页和段管理、地址映射、内存保护和共享、虚拟内存。</p>
<p>  I/O管理：缓冲管理、I/O通道和设备分配、完成I/O请求。</p>
<p>  文件管理：文件存储空间管理、目录管理、文件读写管理和保护。</p>
<p>  支持功能：中断处理、监视。</p>
<p>​    进程创建：1. 分配唯一的进程标识符， 2. 分配内存空间（包括程序和数据的进程私有空间、用户栈、进程控制块）， 3. 初始化进程控制块， 4. 设置正确的链接（例如将新进程放在就绪或就绪/挂起链表中）， 5. 创建或扩充其他数据结构。</p>
<p>​    进程切换：可发生在操作系统从当前正在运行的进程中获得控制权的任何时刻，例如处理异步外部事件（例如完成一次I/O操作）的中断、处理错误或异常条件（例如非法文件访问）的陷阱、调用操作系统系统函数（例如请求I/O操作，如打开文件）的系统调用。</p>
<p>操作系统执行：</p>
<p>  无进程内核：在所有进程外部执行操作系统内核。</p>
<p>  在用户进程内运行：在用户进程的上下文中执行所有操作系统软件，进程映像中除了进程自身的数据，还包括内核程序的程序、数据和栈区域。需要额外的进程切换函数。</p>
<p>  作为分离的进程执行：将操作系统的内核功能作为一组独立的系统进程来实现。需要额外的进程切换函数。</p>
<p>进程具有对资源的控制权或所有权，资源包括内存、I/O通道和设备、文件等，操作系统确保进程之间不会发生资源冲突。</p>
<p>线程是可被操作系统调度和分派的实体，又称为轻量级进程。同一个进程的所有线程都驻留在同一块地址空间中，共享该进程的状态和资源。</p>
<p>进程定义为资源分配单元和一个保护单元，与其相关联的有：1. 容纳进程映像的虚拟地址空间， 2. 对处理器、其他进程（用户进程间通信）、文件和I/O资源（设备和通道）的受保护访问。</p>
<p>线程具有：1. 一个线程执行状态， 2. 线程上下文，线程可视为在进程内运行的一个独立程序计数器， 3. 一个执行栈， 4. 每个线程用于局部变量的一些静态存储空间， 5. 与进程内其他线程共享的内存和资源的访问。</p>
<p>相比于进程，创建、切换、终止线程，以及线程间通信的效率更高（独立进程间通信需要内核介入，以提供保护和通信所需要的机制）。</p>
<p>多线程在单用户多处理系统中的应用：1. 前台和后台工作， 2. 异步处理， 3. 加快执行速度， 4. 模块化程序结构。</p>
<p>一个进程中的所有线程共享同一个地址空间和诸如打开的文件之类的其他资源，一个线程对资源的任何修改都会影响同一进程中其他线程的环境，因此需要同步各个线程的活动，以便它们互不干扰且不破环数据结构。</p>
<p>Linux中的进程或任务由一个task_struct数据结构表示，包含如下信息：</p>
<p>  状态：进程的执行状态（执行态、就绪态、挂起态、停止态、僵死态）。</p>
<p>  调度信息：Linux调度进程所需要的信息，进程可能是普通的或实时的，并具有优先级。</p>
<p>  标识符：每个进程都有唯一的一个进程标识符，以及用户标识符和组标识符，组标识符用于给一组进程指定资源访问特权。</p>
<p>  进程间通信：IPC机制。</p>
<p>  链接：每个进程都有一个到其父进程、兄弟进程、子进程的链接。</p>
<p>  时间和计时器：包括进程创建的时刻和进程所消耗的处理器时间总量、一个或多个间隔计时器。</p>
<p>  文件系统：指向被该进程打开的任何文件的指针和指向该进程当前目录与根目录的指针。</p>
<p>  地址空间：定义分配给该进程的虚拟地址空间。</p>
<p>  处理器专用上下文：构成该进程上下文的寄存器和栈信息。</p>
<p>Linux进程的状态：</p>
<p>  运行：就绪态或执行态。</p>
<p>  可中断：阻塞态，该进程正在等待一个事件、一个可用的资源或另一个进程的信号。</p>
<p>  不可中断：阻塞态，该进程正在等待一个硬件条件，不会接收任何信号。</p>
<p>  停止：进程被终止，并且只能由来自另一个进程的主动动作恢复。</p>
<p>  僵死：进程已被终止，但进程表中仍然有其任务结构。</p>
<p>Linux提供了一种不区分进程和线程的解决方案（Linux没有给线程单独定义数据结构），将用户级线程映射到内核级进程，组成一个用户级进程的多个用户级线程则映射到共享同一个组ID的多个Linux内核级进程上，这些进程可以共享文件和内存等资源，使得同一个组中的进程调度切换时不需要切换上下文。</p>
<p>Linux通过复制当前进程的属性可创建一个新进程，新进程可以共享资源，如文件、信号处理程序和虚存。共享相同虚存的两个进程可以视为同一个进程中的线程。Linux使用clone()命令代替通常的fork()命令来创建进程。Linux内核在切换进程时，会检查两个进程的页目录地址是否相同，若相同，则他们共享同一个地址空间，此时的上下文切换仅是切换执行的代码。</p>
<p>属于同一个进程组的克隆进程共享同一个内存空间，但不能共享同一个用户栈，所以clone()调用会为每个进程创建独立的栈空间。</p>
<p>Linux的命名空间可使一个进程或同一命名空间下的多个进程拥有与其他命名空间下的其他进程不同的系统视图，从而实现控制组（cgroups，也称容器），使得进程或进程组像是系统上的唯一进程。</p>
<p>Linux具有6个命名空间，命名空间由系统调用clone()创建，或由unshare()系统调用创建一个依附于所调用进程的新命名空间。</p>
<p>  Mount命名空间：为进程提供文件系统层次结构的特定视图，不同mount命名空间内的进程具有不同的文件系统层次结构，一个进程使用的所有文件操作仅适用于该进程可见的文件系统。</p>
<p>  UTS命名空间：</p>
<p>  IPC命名空间：隔离某些进程间通信IPC资源，如信号量。因此并发机制由可在进程中启动IPC的程序员使用，这些进程享有相同的IPC命名空间。</p>
<p>  PID命名空间：隔离进程ID空间，可使不同PID命名空间中的进程拥有相同的PID。</p>
<p>  网络命名空间：隔离与网络相关的系统资源，每个网络命名空间都拥有自己的网络设备、IP地址、IP路由表、端口号等，这些命名空间虚拟化所有对网络资源的访问，允许每个cgroup访问其需要的网络。一个网络设备或一个套接字在任何给定时间只能属于一个命名空间。</p>
<p>  用户命名空间：</p>
<p>并发包括的设计问题有：进程间通信、资源共享与竞争（如内存、文件、I/O访问）、进程间同步、进程调度等。</p>
<p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<p>原子操作：一个函数或动作的指令序列要么全部成功执行，要么都不执行。</p>
<p>临界资源：多个进程/线程都需要访问的不可共享的资源。</p>
<p>临界区：访问临界资源的一段代码。</p>
<p>死锁：两个进程/线程因互相等待对方释放资源而无法继续执行的情况。</p>
<p>互斥：一个进程/线程进入临界区后，其他进程/线程不能再进入。</p>
<p>竞争条件：多个进程/线程在读写一个共享数据时，结果依赖于他们执行的相对顺序。</p>
<p>并发机制：信号量、互斥量、条件变量、管程、事件标志、消息、自旋锁。</p>
<p>信号量：wait操作使信号量值减一，如果信号量值变成负数，则阻塞当前进程，否则继续。signal操作使信号量值加一，如果信号量值依旧小于等于零，则将某个被wait操作阻塞的进程解除阻塞（唤醒）。当信号量值大于等于0时，信号量值是执行wait操作而不被阻塞的进程数，信号量值小于0时，信号量值是执行wait操作而阻塞的进程数。</p>
<p>互斥锁被设置为锁定（一般为0）时用于阻塞其他进程使用数据，当数据不再需要时解锁（设定值为1），锁定/解锁互斥锁的的进程必须是同一个，信号量可以是不同进程加锁/解锁。</p>
<p>生产者/消费者问题：生产者产生数据，并放置在缓冲区中，消费者从缓冲区中每次取出一个数据。每次只有一个生产者或消费者可以访问缓冲区，同时当缓冲区已满时，生产者不能继续向其中添加数据（阻塞），当缓冲区为空时，消费者不能继续取出数据（阻塞）。</p>
<p>管程：由一个或多个过程、一个初始化序列和局部数据组成的软件模块，局部数据只能被管程的过程访问，一个进程只能通过调用管程的一个过程进入管程，任何时候都只能有一个进程在过程中执行，其他调用管程的进程被阻塞。管程的所有同步机制都在管程内部实现。</p>
<p>管程使用条件变量来同步，wait(c)表示调用进程在条件c上阻塞，管程现在可以被另一个进程使用，signal(c)表示恢复执行某个在条件c上阻塞的进程，如果有多个则选择其中一个，如果没有，则什么也不做。</p>
<p>相比于信号量，管程的所有同步机制都被限制在管程内部，易于验证同步的正确性，易于检测出错误，若一个管程被正确编写，则所有进程对受保护资源的访问都是正确的。</p>
<p>notify(x)改进：执行notify(x)会使得在x条件上等待的队列得到通知，但发信号的进程继续执行，在将来合适且处理器可用时恢复执行位于x条件上等待的队列头的进程，并且这个等待的进程恢复执行时重新检查条件。每个等待的进程都有一个监视计时器，等待超时未收到通知时，该进程被设置为就绪态，防止产生饥饿现象。notifyAll(x)用于发送广播，使所有在x条件上等待的进程都置于就绪态。</p>
<p>进程间的合作需要通过消息传递机制交换信息，发送或接收消息可以是阻塞或非阻塞的，寻址可以是直接通过进程标识符的直接寻址，或通过消息队列的间接寻址。</p>
<p>消息格式包括了消息源和目的的标识符、消息长度与类型、额外的控制信息和消息内容。</p>
<p>排队原则可以是先进先出或指定消息的优先级。</p>
<p>读/写问题：存在一个被多个进程共享的数据区，有些进程只能读数据，有些进程只能写数据，且任意数量的读进程可同时读，一次只有一个写进程可以写文件，若有写进程在写文件，则禁止任何其他杜进程读文件。</p>
<p>死锁：一组线程相互等待对方占有的资源而陷入永久性阻塞的现象。</p>
<p>死锁的三个必要条件：</p>
<ol>
<li>互斥，一个资源一次只能被一个线程占有。</li>
<li>占有且等待，一个线程在等待其他线程释放资源时，会继续占有已分配的资源。</li>
<li>不可抢占， 不能强行抢占进程已占有的资源。</li>
</ol>
<p>当程序出现： 4. 循环等待，存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源。 会产生死锁。</p>
<p>上述4个条件构成了死锁的充分必要条件。 第4个条件是前3个条件的潜在结果，如果前3个条件满足，则可能会因为进程请求和释放资源的顺序，导致出现不可解的循环等待，此即死锁。</p>
<p>处理死锁的三种方法： 1. 采用某种策略消除4个条件中的某个条件的出现，来预防死锁， 2. 基于资源分配的当前状态做动态选择来避免死锁， 3. 试图检测死锁（满足4个条件）的存在并从死锁中恢复。</p>
<p>死锁预防：</p>
<ol>
<li>互斥不可能避免。</li>
<li>占有且等待的一个解决办法是：要求进程一次性请求所有需要的资源，并阻塞该进程直到所有请求都满足，但：进程可能阻塞很长时间，实际上只要有一部分资源它就可以继续执行，其次，进程占有的资源可能长时间不会使用，此时其他进程也不能使用，再者，进程可能事先并不知道它所需要的全部资源。</li>
<li>不可抢占的解决办法是：1. 占有某个资源的进程进一步申请资源时若被拒绝，则必须释放最初占有的资源，必要时再次申请。 2. 进程请求当前被另一个进程占有的资源时，操作系统可以抢占另一个进程，要求它释放资源。这要求资源的状态很容保存或恢复（像处理器一样）。</li>
<li>循环等待的一个解决办法是：定义资源的线性顺序，进程只能按序申请资源。</li>
</ol>
<p>死锁避免：与预防的差别在于，死锁预防是通过破坏三个必要条件间接完成，或破环循环等待直接完成，死锁避免是允许三个必要条件存在，但通过正确的资源调度，确保不会到达死锁点。</p>
<ol>
<li>进程启动拒绝：若一个进程的请求会导致死锁，则不启动该进程。</li>
</ol>
<p>定义向量（Resource）$\bold{R}={R_1,R_2,…,R_m}$表示系统中每种资源的总量，向量（Available）$\bold{V}={V_1,V_2,…,V_m}$表示未分配给进程的每种资源的总量(可用资源)，矩阵（Claim）$\bold{C}={C_{ij}}，C_{ij}$表示进程i对资源j的需求总量，矩阵（Allocation）$\bold{A}={A_{ij}}，A_{ij}$表示当前分配给进程i的资源j的数量。</p>
<p>只有满足所有当前进程的最大请求及新进程的请求时，才会启动该新进程。</p>
<ol>
<li>资源分配拒绝：若一个进程增加的资源请求会导致死锁，则不允许这一资源分配。</li>
</ol>
<p>银行家算法：</p>
<p>  系统的状态是当前给进程分配的资源状态，包括上述定义的两个向量和两个矩阵，系统安全状态是指至少有一个资源分配序列（即将资源按照该进程序列进行分配，进程获得资源运行至退出后释放资源）不会导致死锁（即所有进程都能运行直到结束），不安全状态是指非安全的一个状态。</p>
<p>  进程请求一组资源时，如果同意该请求后系统的状态仍处于安全状态，则同意该请求，否则阻塞该请求直到同意该请求后系统状态仍是安全的。</p>
<p>死锁检测：</p>
<p>  不限制资源访问或约束进程行为，尽可能给进程分配所请求的资源，操作系统通过周期性的执行一个算法来检测是否出现循环等待现象。</p>
<ol>
<li>最初所有进程都是未标记的，矩阵（Allocation）$\bold{A}={A_{ij}}，A_{ij}$表示当前分配给进程i的资源j的数量，矩阵（Request）$\bold{Q}={Q_{ij}}，Q_{ij}$表示进程i请求的资源j的数量，向量（Available）$\bold{V}={V_1,V_2,…,V_m}$表示未分配给进程的每种资源的总量(可用资源)。</li>
<li>标记矩阵A中一行全为0的进程。</li>
<li>查找进程i，使进程i未标记且对应的资源需求（即矩阵Q中对应的行）都小于等于向量V（此时运行该进程不会导致死锁），如果找不到则终止算法。</li>
<li>若找到这样的行，则标记进程i，并把矩阵A中对应行加到向量V中（运行完该进程后的可用资源数量），返回步骤3。</li>
<li>当且仅当这个算法的最终结果有未标记的进程时，才存在死锁。</li>
</ol>
<p>死锁恢复：</p>
<ol>
<li>直接取消所有死锁进程。</li>
<li>回滚死锁进程，并重新启动。</li>
<li>连续取消死锁进程直到不再存在死锁。所选取消进程的顺序应基于某种最小代价原则（例如已消耗的处理器时间最少、已分配的资源总量最少、优先级最低等），取消后需要重新调用检测算法以测试是否仍存在死锁。</li>
<li>连续抢占资源直到不存在死锁。与3一样需要使用一种基于代价的选择方法来抢占进程的资源，每次抢占后也需要重新检测是否存在死锁，资源被抢占的进程必须回滚到获得这个资源之前的某一状态。</li>
</ol>
<p>哲学家就餐问题：。。。</p>
<p>Unix并发机制：</p>
<ol>
<li>管道，管道是一个环形缓冲区（FIFO队列，一个进程写，另一个进程读），允许两个进程以生产者/消费者的模型进行通信。一次只能有一个进程可以访问管道。具有父子关系的进程可以共享匿名管道，不相关进程只能共享命名管道。</li>
<li>消息，每个进程都有一个与之相关联的信息队列，其功能类似于信箱。</li>
<li>共享内存，虚存中由多个进程共享的一个公共内存块。</li>
<li>信号量，可进行增量signal或减量wait操作。</li>
<li>信号，用于向一个进程通知发生异步事件的机制，一次只能给进程一个信号，且没有优先级。进程只有在被唤醒继续运行或从系统调用中返回时才处理信号，进程可以通过执行某些默认行为、执行一个信号处理函数或忽略该信号来对信号做出响应（由进程本身处理信号，而不是操作系统）。</li>
</ol>
<p>Linux并发机制：</p>
<ol>
<li>包含UNIX中的所有并发机制，并支持实时信号，相比于UNIX中的信号，实时信号可以1. 支持按优先级顺序排列的信号进行传递， 2. 多个信号能排队， 3. 可以将数值（一个整数或指针）随信号一起发送至目标进程。</li>
<li>原子操作， 原子操作在执行时不会被打断或干扰，Linux定义了两种原子操作：针对整数变量的操作和针对位图bitmap中某一位的位图操作。</li>
<li>自旋锁， 基本自旋锁：在同一时刻只有一个线程能获得自旋锁，其他任何试图获得自旋锁的线程将一直进行尝试（即自旋），直到获得了该锁。读写自旋锁：允许多个线程同时以只读的方式访问同一数据结构，只有当有一个线程想要更新数据结构时，才会互斥地访问该自旋锁。</li>
<li>屏障：禁止编译器或处理器进行代码重排序。</li>
</ol>
<p>页框：内存中固定长度的块。</p>
<p>页：固定长度的数据块，存储在二级存储器中，数据页可以临时复制到内存的页框中。</p>
<p>段：变长数据块，存储在二级存储器中，整个段可以临时复制到内存的一个可用区域中（分段），或将一个段分为许多页，然后将每页复制到内存中（分段与分页相结合）。</p>
<p>内存管理需求：</p>
<ol>
<li>重定位， 程序经过换入换出后，在内存中的位置会发生变化，处理器硬件和操作系统必须能以某种方式把程序代码中的内存访问转换为实际的物理内存地址。</li>
<li>保护， 进程不能未经授权地访问（读操作或写操作）其他进程的内存单元。</li>
<li>共享， 在满足基本保护的前提下，允许多个进程对内存共享区域进行受控访问。</li>
<li>逻辑组织， 内存总是被组织成线性或一维的地址空间，且地址空间由一系列字节或字组成，外部存储器在物理层上也是按类似方式组织，但大多数程序被组织成模块，操作系统需要能够有效地处理以某种模块形式组织的用户程序与数据。</li>
<li>物理组织， 在多级存储结构中，操作系统需要处理内存与外存之间信息流的组织。</li>
</ol>
<p>固定分区：系统生成阶段，内存被划分为许多静态分区，进程可装入大于等于自身大小的分区中。</p>
<p>动态分区：系统根据进程大小动态创建分区。</p>
<p>简单分页：内存被划分为许多大小相等的页框，每个进程被划分成许多大小与页框相等的页，装入进程时，把进程包含的所有页装入内存中不一定连续的某些页框中。与固定分区一样，会产生内部碎片。</p>
<p>简单分段：每个进程的程序和数据被划分成许多段，装入进程时，把进程包含的所有段装入内存中不一定连续的某些动态分区中。与动态分区一样，会产生外部碎片。</p>
<p>虚存分页：与简单分页类似，不需要装入进程的所有页，非驻留页在以后需要时自动调入内存。</p>
<p>虚存分段：与简单分段类似，不需要装入进程的所有段，非驻留段在以后需要时自动调入内存。</p>
<p>压缩：操作系统不时地移动进程，使得进程占用的空间连续，并使所有空闲空间连成一片。</p>
<p>进程经过换入换出或内存压缩后，其在内存中的绝对地址会发生移动，进程访问（指令和数据单元）的位置不是固定的。</p>
<p>逻辑地址：与当前数据在内存中的物理分配无关的访问地址，在执行对内存的访问前需要转换成物理地址。</p>
<p>相对地址：是数据相对于某个已知点（通常是程序的开始处，又称基址）的偏移量。</p>
<p>物理地址或绝对地址：数据在内存中的实际位置。</p>
<p>分页：</p>
<p>操作系统为每个进程维护一个页表，页表中给出进程的每页所对应的页框在内存中的位置，同时操作系统维护一个空闲页框列表。</p>
<p>程序中的相对地址由程序的起点和逻辑地址定义，逻辑地址包括一个页号和在该页中的偏移量。处理器根据页表由页号和偏移量产生物理地址。</p>
<p>分段：</p>
<p>分页对程序来说是透明的，而分段通常是可见的，程序员或编译器可把程序和数据指定到不同段。</p>
<p>操作系统为每个进程维护一个段表，段表中给出进程的每个段在内存中的起始位置和长度，同时操作系统维护一个空闲页框列表。</p>
<p>应用程序有许多已编译过或汇编过的模块组成，这些模块以目标代码的形式存在，并被链接起来以解析模块间的任何访问和对库文件的访问，库文件可以合并到程序中，或作为操作系统在运行时提供的共享访问代码。</p>
<p>绝对加载：加载的模块中的所有地址访问是确定的，即是绝对的内存地址。可以在程序设计时由程序员完成，或者在编译或汇编时将程序中包含的符号地址访问转换为实际的绝对内存地址。</p>
<p>可重定位加载：汇编器或编译器不产生实际的绝对内存地址，而是使用相对于某些已知点（例如程序开始）的相对地址。在程序加载时由加载器将相对地址换位为绝对地址。</p>
<p>动态运行时加载：程序加载到内存时所有的内存访问都以相对地址表示，只有在指令真正执行时才计算其绝对地址。</p>
<p>进程中的所有内存访问都是逻辑地址，这些逻辑地址会在运行时动态地转换为物理地址，意味着进程可以被换入或换出内存，可以在执行过程中的不同时刻占据内存中的不同区域。一个进程可以被划分为许多块（页和段），在执行过程中，这些块不需要连续地位于内存中，也不需要全部加载进入内存。</p>
<p>长程调度：决定将哪些进程加入待执行进程池，（新建-就绪，新建-就绪挂起）</p>
<p>中程调度：决定将哪些进程的部分或全部加载入内存，即交换（就绪挂起-就绪，阻塞挂起-阻塞）</p>
<p>短程调度：决定处理器执行哪个可运行进程，（就绪-运行），导致当前进程阻塞或抢占当前运行进程的事件（时钟中断、I/O中断、系统调用、信号）发生时调用短程调度程序。</p>
<p>IO调度：决定可用IO设备处理哪个进程挂起的IO请求</p>
<p>调度本质上属于队列管理（排队论）问题，用于在排队环境中减少延迟并优化性能。</p>
<p>短程调度规则：周转时间（驻留时间）、响应时间、吞吐量、处理器利用率、公平性、优先级等。</p>
<p>面向块的IO设备：块的大小是固定的，传送过程中一次传送一块。</p>
<p>面向流的IO设备：以字节流的方式输入/输出数据。</p>
<p>磁盘IO：等待设备、等待通道、寻道、旋转延迟、数据传输。</p>
<p>寻道时间：磁头臂移到指定磁道所需要的时间，在读写一个磁盘块所需时间中占比最长，磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<p>旋转延迟：磁盘的待访问地址区域旋转到磁头可访问位置所需要的时间。</p>
<p>传输时间：磁盘完成数据读取/写入所需要的时间。</p>
<p>存取时间：寻道时间+旋转延迟</p>
<p>磁盘调度策略：</p>
<p>操作系统为每个IO设备维护一个请求队列，队列中包含来自多个进程的许多IO请求，</p>
<ul>
<li><p>随机调度：随机从IO请求队列中选择项目，此时磁道是随机被访问的，寻道时间过长，性能最差。</p>
</li>
<li><p>FIFO/先到先服务FCFS：按磁盘请求的顺序进行调度，如果请求是访问簇聚的文件扇区，则性能较好，如果是大量进程竞争，则性能接近随即调度。</p>
</li>
<li><p>优先级：不会优化磁盘利用率，但满足操作系统的响应时间。</p>
</li>
<li><p>最短寻道时间优先（shortest seek time first，SSTF）：选择使磁头臂从当前位置开始寻道时间最短的磁盘IO请求。容易出现饥饿现象。</p>
</li>
<li><p>电梯算法/SCAN算法：磁头臂沿一个方向移动，按磁道顺序完成请求，直到到达最后一个磁道，或这个方向没有其他请求为止（对所有请求按块号进行排序），然后反转方向，沿相反方向扫描，同样按磁道顺序完成所有请求。</p>
</li>
<li><p>C-SCAN：循环扫描算法，按一个方向扫描，当磁头臂访问到某个方向的最后一个磁道后，返回到相反方向末端的磁道，并再次开始扫描。</p>
</li>
<li><p>N步SCAN：为避免一个或多个进程对一个磁道有较高的访问频次，不断重复请求这个磁道造成垄断（即磁头粘性），磁盘请求队列被分为多个长度为N的子队列，每次用SCAN处理一个子队列，新请求必须添加到其他未在处理的队列中。</p>
</li>
</ul>
<p>RAID 独立磁盘冗余阵列Redundant Array of Independent Disks</p>
<ul>
<li>raid是一组物理磁盘驱动器，操作系统把它视为单个逻辑驱动器。</li>
<li>数据分布在多个物理驱动器阵列中（条带化）。</li>
<li>使用冗余磁盘保存奇偶校验信息，保证一个磁盘失效时，数据具有可恢复性。</li>
</ul>
<p>磁盘高速缓存是内存中为磁盘扇区设置的一个缓冲区，包含磁盘中某些扇区的副本。</p>
<p>缓存置换策略：</p>
<ul>
<li>最近最少使用算法（Least Recently Used，LRU）：置换缓存中最长时间未被访问的块。</li>
<li>最不常使用算法（Least Frequently Used, LFU）：置换缓存中访问次数最少的块。</li>
</ul>
<p>UNIX中每个单独的io设备都与一个特殊文件相关联，它们由文件系统管理，并按照与用户数据相同的方式读写，即要从设备读或向设备写，可给该设备相关联的特殊文件发送读请求或写请求。</p>
<p>Linux磁盘调度算法：</p>
<ul>
<li>电梯调度：新请求可与队列中访问同一扇区或直接相邻扇区的请求合并；如果队列中存在等待时间过长的请求，则新请求插入队列尾部；否则将新请求按块号顺序插入队列中。</li>
<li>最后期限调度：存在三个队列：包含所有请求的顺序队列、读FIFO队列和写FIFO队列，新请求加入顺序队列，再加入读或写FIFO队列，读写队列中每个请求具有最后期限，调度器默认调度顺序队列，当读写FIFO队列中有超期限请求时，则优先调度超期限的请求。</li>
<li>预期调度：调度一个读请求时，调度系统延迟执行一段时间。</li>
</ul>
<p>Linux页面缓存：缓存磁盘和内存交互的数据，优势在于：1. 将脏数据（修改过的数据）写回磁盘时可进行排序，使写入磁盘更高效。 2. 局部性原理，缓存的页面很可能被再次引用，减少不必要的磁盘IO。 </p>
<p>脏数据在如下情况下写回磁盘：1. 空闲内存低于某个阈值， 2. 脏页面驻留时间超过某个阈值。</p>
<p>虚拟机管理程序Hypervisor对其支持的虚拟机抽象物理硬件，作为代理为虚拟机请求要使用的物理主机资源。</p>
<p>虚拟机优势：易于备份与迁移、快速部署、</p>
<p>两类虚拟机管理程序：</p>
<ul>
<li>作为一个软件层直接运行在物理服务器上，如VMware ESXi、Hyper-V。直接控制主机的物理资源，具有更好的性能、更高的安全性</li>
<li>作为一个应用程序运行在主机操作系统上，VMware Workstation、Oracle Virtual Box。</li>
</ul>
<p>CPU虚拟：</p>
<ul>
<li>以软件的方式模拟芯片并提供访问接口，平台无关、易于移植、性能不高。</li>
<li>向虚拟机提高主机物理CPU的时间片，通过拦截虚拟机操作系统向CPU发送的指令，然后调度主机的物理处理器时间，发送执行请求并将结果返回给虚拟机操作系统。</li>
</ul>
<p>高速缓存一致性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" data-id="ckmn1ijih000nn8a88nqe6zxm" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java并发笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.548Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>java中的每个对象都可以作为synchronized的锁，对于实例方法，锁就是实例对象，对于静态方法，锁就是类的class对象，对于代码块，锁就是括号中指定的对象。synchronized的锁标识存储在对象头中。</p>
<p>单例模式中的变量为什么要使用volatile修饰？</p>
<p>创建一个对象实际分为三步，1. 为对象分配空间， 2. 初始化对象， 3. 将引用变量指向分配的空间。 在运行过程中可能存在指令重排序，例如将先将引用变量指向分配的空间再执行初始化，此时引用变量不为null但为初始化，如果直接返回则可能存在问题，因此使用volatile禁止指令重排序。</p>
<p>notify/notifyAll：唤醒等待在锁对象上的某个/全部线程，使其从等待队列进入同步队列,状态由WAITING变为BLOCKED，获得锁后才从wait()方法中返回。</p>
<p>wait()：线程通过该方法进入等待队列，并释放锁，状态变为WAITING，等待被中断或唤醒。</p>
<p>上述方法在调用前都需要先获得锁。wait/notify的经典范式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待方</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        obj.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知方</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="comment">// 改变条件</span></span><br><span class="line">    obj.notify() <span class="comment">// obj.notifyAll()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread.join()方法会调用线程对象的wait()方法，线程退出前会调用notifyAll()方法。</p>
<p>ThreadLocal：线程本地变量，每个线程都维护了一个ThreadLocalMap，Map的key就是ThreadLocal变量，value就是变量的副本，通过ThreadLocal变量的set/get方法可以设置或获取线程本地变量的值。在线程使用get方法前需要先使用set方法，否则报空指针错误，或者在定义ThreadLocal变量时重写ThreadLocal类的initialValue()方法。</p>
<p>synchronized原理：</p>
<p>JVM通过进入和退出监视器Monitor来实现方法同步和代码块同步，在同步代码块开始处插入monitorenter，在退出处插入monitorexit，而方法是利用编译成的class文件中的方法修饰符来标识。两者的本质都是获取锁对象的监视器。获取监视器成功的线程进入同步块，获取失败的线程被阻塞，进入同步队列，状态变为BLOCKED。</p>
<p>被synchronized修饰的同步块对于同一个线程而言是可重入的。</p>
<p>被synchronized修饰的同步块在被持有锁的线程执行完并释放锁之前，会无条件阻塞其他线程进入。不能强制已获取锁的线程释放锁，也不能强制等待锁的线程退出或超时推出。</p>
<p>J.U.C下的Lock接口能够在类库层面上实现同步，ReentrantLock是Lock接口的一种实现。ReentrantLock支持</p>
<ol>
<li>超时退出，线程在等待持有锁的线程释放锁时，可超时退出。</li>
<li>非阻塞获取锁：可以尝试性地获取锁，而不用被阻塞。</li>
<li>可中断：获取到的锁可以响应中断，抛出中断异常，并释放锁。</li>
<li>支持公平锁，公平锁是指按多个线程在等待同一个锁，必须按申请时间依次获得锁，非公平锁则是每个线程都有机会获得锁。synchronized锁是非公平锁，ReentrantLock默认是非公平锁。使用公平锁会导致性能下降。</li>
<li>支持多个条件，synchronized中锁对象的wait和notify方法配合可以实现一个隐含的条件，ReentrantLocak可以通过newCondition绑定多个条件。</li>
</ol>
<p>ReentrantLock是排他锁，在同一个时刻只允许一个线程进行访问。读写锁ReadWriteLock内部维护了两把锁，一把读锁和一把写锁，同一个时刻允许多个读线程访问，但只允许一个写线程访问，读线程和写线程不能同时访问，写锁能降级为读锁（线程先获取写锁，再获取读锁，再释放写锁，此时线程依旧拥有读锁）。ReentrantReadWriteLock是读写锁的实现。</p>
<p>JUC.LockSupport.park/unpark可以阻塞和唤醒线程。</p>
<p>Lock.newCondition().await/signal/signalAll可以实现等待/通知模式，一个Lock对象可以绑定多个condition。</p>
<p>Condition在内部维护了一个等待队列，每个执行await()方法的线程都会释放锁，加入到等待队列进入等待状态。synchronized具有一个等待队列和一个同步队列，由于Lock支持绑定多个条件，因此有多个等待队列和一个同步队列。</p>
<p>signal会唤醒等待时间最长的线程，将其从等待队列移入同步队列，signalAll则是依次唤醒等待队列中的所有线程。</p>
<p>Lock最好是使用try/catch，并在finally中使用Lock.unlock()。</p>
<p>CPU实现原子操作：1. 锁总线，当一个CPU锁住总线时，其他CPU不能操作内存。 2. 锁缓存，如果数据在一个缓存行中，则直接操作缓存行，并通过缓存一致性机制来保证原子性。</p>
<p>Java实现原子操作：</p>
<ol>
<li><p>使用自旋CAS，即循环执行CAS操作直到成功为止。java并发包中的一些类（AtomicInteger、AtomicLong）支持原子操作）。</p>
<p>使用CAS会产生1. ABA问题，CAS需要检测值是否发生变化，没有变化则更新。如果一个值A，变成了B，又变成了A，CAS在检查时会认为值没有改变，可以通过添加版本号解决。2. 自旋时间长开销大。</p>
</li>
<li><p>使用锁机制实现原子操作，锁机制保证了只有获得锁的线程才能操作锁定的内存区域。</p>
</li>
</ol>
<p>同步是指控制不同线程执行操作的相对顺序，JAVA同步采用的是共享内存模型。只有在线程之间共享的堆内存才会有内存可见性即同步问题，而局部变量等线程私有的不会。</p>
<p>AQS（Abstract Queued Synchronizer）队列同步器，是实现锁和其他同步组件的基础框架，AQS使用一个int类型的变量state来表示同步状态，</p>
<p>同步器是基于模板方法模式的，使用者需要继承同步器并重写指定的方法（tryAcquire/tryRelease,tryAcquireShared/tryReleaseShared)，然后将同步器子类组合在自定义同步组件的实现中（即将同步器子类作为自定义同步组件的静态内部类），并调用同步器提供的模板方法，这些模板方法又调用使用者重写的方法，同步器支持独占和共享模式。</p>
<p>AQS内部维护了一个双向FIFO队列，当线程获取锁失败时，同步器会将其加入同步队列的尾部，然后阻塞该线程。当锁被释放时，会唤醒首节点，使其再次尝试获取锁。</p>
<p>java内存模型：</p>
<p>线程之间的共享变量存储在主内存中，每个线程都有一个本地内存，本地内存中存储了该线程已读写共享变量的副本。本地内存是一个抽象概念，包括缓存、缓冲区、寄存器等。</p>
<p>为了保证内存可见性（一个线程对共享变量进行修改，能立刻被其他操作观察到，即两个操作的happens-befor关系，实现原理是将该线程的本地内存中的共享变量刷新到主内存，并使其他线程的本地内存中的该共享变量失效，其他线程再使用该共享变量时需要从主内存读取），java编译器可以插入内存屏障指令来禁止指令重排序。</p>
<p>happens-before：一个操作执行的结果对另一个操作可见，并不意味着前一个操作一定在后一个操作之前执行。</p>
<p>重排序：编译器或处理器为了优化程序性能而对指令序列进行重新排序。重排序可能会影响多线程的执行结果，需用使用同步机制来保证程序的顺序执行，包括synchronized、volatile和final。</p>
<p>锁保证了临界区内代码的执行具有原子性，锁的加锁和解锁具有happens-before关系，即加锁happens-before解锁。</p>
<p>volatile相当于对单个变量的单个读写操作加锁，可以保证：1. 可见性，由于volatile相当于是对单个变量的单个读写操作加锁，而加锁是happens-before解锁的，因此对volatile变量的读，总能看到任意线程对该变量最后的写。 2. 原子性， 锁保证了临界区内的代码执行具有原子性，因此对任意volatile变量的单个读写操作具有原子性，符合操作例如++没有，++相当于是先读再写。</p>
<p>volatile是轻量级的synchronized，volatile修饰的变量在所有线程中都是一致的。</p>
<p>volatile原理：</p>
<p>对volatile变量进行赋值的java语句编译成汇编代码后会多一条使用lock指令修饰的汇编代码，lock指令会将当前CPU的缓存行（CPU缓存的最小存储单位，每次读写缓存时都读写整个缓冲行）写回系统内存（对应JAVA内存模型，即将本地内存中的共享变量刷新到主内存），并使其他CPU缓存的该内存地址数据失效（缓存一致性协议，CPU通过嗅探总线上的数据来检查自己缓存的值是否过期，如果发现自己缓冲行对应的内存地址的数据被修改，则将该缓存行设置为失效，再次访问或修改这个数据时需要重新从系统内存中读取到缓存中来）。同时，volatile通过插入内存屏障来禁止指令重排序。</p>
<p>synchronized内存语义：</p>
<p>释放锁时会将线程对应的本地内存中的共享变量刷新到主内存中，获取锁时会将线程对应的本地内存中的共享变量设置为无效，从而使得临界区内的代码必须从主内存中读取共享变量。</p>
<p>juc中的包是以volatile读写和CAS来实现线程间的通信同步的，</p>
<p>final变量可以禁止重排序，保证在对象的引用变量被其他线程可见时，该对象的final变量已在构造函数中正确初始化。要求在构造函数中不能使对象引用溢出（即在构造函数中将对象引用this传递出去，被其他线程可见）。</p>
<p>final变量的可见性：如果在构造器中对象的引用this没有逸出，那么在对象引用被其他线程可见时，该对象的final类型变量已正确完成初始化。</p>
<p>有序性：volatile本身就有禁止指令重排序，synchronized保证同一个时刻只有一个线程获得对象的锁，决定了持有同一个锁的两个线程只能串行进入同步块。</p>
<p>每秒事务处理总数Transaction per second TPS表示一秒内服务端平均能响应的请求总数。</p>
<p>CPU的计算速度远大于存储与通信速度，可以使用高速缓存，</p>
<p>为什么要使用多线程：</p>
<ol>
<li><p>现在计算机的CPU几乎都是多核多线程的，部分服务器还含有多个CPU，使用多线程能充分利用CPU核心。</p>
</li>
<li><p>大多数线程的大部分时候都处于阻塞状态，尤其是IO密集型线程，使用多线程能提高CPU利用率。</p>
</li>
<li><p>现在的系统经常需要应对非常高的并发量，使用多线程能提高系统的并发能力。</p>
</li>
</ol>
<p>为什么不使用多进程：</p>
<p>进程创建、销毁、切换和调度需要的开销相比线程而言更大，并且进程间通信比线程间通信更复杂。</p>
<p>使用多线程可能会存在什么问题：</p>
<ol>
<li>同步：多个线程如果没有正确地同步，则执行结果有可能是错误的。</li>
<li>死锁，多个线程互相等待对方持有的锁而形成死锁，解决方法是破坏死锁形成的4个条件：互斥、占用且等待、不可抢占、循环等待。</li>
<li>线程上下文切换，线程进行频繁的上下文切换会产生较大的开销，CPU通过时间片轮转算法来进行线程调度，切换到下一个线程前需要保存当前线程的状态，以便下次切换回时再加载这个状态。切换线程时从保存当前线程状态到加载下一线程的状态的过程就是一次上下文切换。可以通过无锁编程（对数据进行分段）、使用CAS算法、避免创建不需要的线程、使用协程来减少上下文切换。</li>
<li>内存泄露：每个线程都需要占用一定的内存空间，创建线程数量过多时可能会产生内存泄漏问题。</li>
</ol>
<p>线程的实现有两种：1. 内核线程， 直接由操作系统内核支持的线程，由内核负责线程的调度和将线程分配的CPU，这样即使进程的一个线程阻塞了，也不影响整个进程工作，但是，各种线程操作，例如创建、同步、调度等都需要使用系统调用，需要在用户态和内核态之间转换，代价相对较高，而且会消耗内核资源，容纳的线程数量有限。</p>
<p>内核线程的调度成本主要是模式转换，模式转换的开销主要是要响应中断、保护和恢复执行现场，即线程上下文。</p>
<p>Hotspot的每一个java线程都直接映射到一个操作系统原生线程，线程的调度都是由操作系统处理。缺点是：切换、调度的成本较高，容纳的线程数量有限。</p>
<p>线程调度主要有两种方式：</p>
<ol>
<li>协同式线程调度，线程的执行时间由自己决定，由线程通知操作系统切换线程。实现简单，但执行时间不可控。</li>
<li>抢占式线程调度，线程的执行时间由操作系统分配，不会出现一个线程阻塞整个系统。主流方式。</li>
</ol>
<p>CPU的一个核心在一个时刻只能执行一个线程，为了并发支持多个线程，操作系统采用的是时间片轮转的方式，将CPU时间划分为多个时间片，每个线程只能在分配的时间片内执行，CPU快速地在多个时间片间轮转，宏观上就是多个线程并发进行。为了使线程切换回后能恢复到切换前的状态，操作系统需要在切换前保存线程状态，然后在切换回后加载线程状态，这个过程就是线程上下文切换。概括来说就是操作系统在进行线程切换时，保存当前线程状态再加载下一个线程状态的过程。</p>
<p>线程上下文：方法调用过程中的局部变量和资源，即方法调用栈中存储的各种信息。</p>
<p>协程：采用协同式调度的用户线程，用户线程是指在用户空间内实现的多线程。由于是在用户空间内实现，不用进行系统调用和模式转换，不占用内核资源，比较轻量。</p>
<p>线程安全：在多线程并发的情况下，调用对象的任何行为都能得到正确的结果，则称这个对象是线程安全的，例如不变量、hashtable、vector的juc中的同步包装类，例如synchronizedList\synchronizedSet。</p>
<p>线程安全的实现方式：</p>
<ol>
<li><p>使用synchronized进行互斥同步，</p>
</li>
<li><p>使用J.U.C下的Lock接口进行互斥同步，</p>
</li>
<li><p>使用非阻塞同步CAS</p>
<p>互斥同步是一种悲观锁策略，即认为如果不加锁则肯定出现问题，因此在执行操作前都会加锁。乐观锁策略是指，不管风险，不加锁而直接执行操作，如果检测到冲突回就采取补救措施，通常是重试。这也称之为无锁编程。</p>
</li>
</ol>
<p>CAS Compare And Set，比较并设置，需要三个操作数，分别是内存地址、旧值、新值。如果内存地址的值与旧值相等，则就其设置为新值。这也一个原子操作。</p>
<p>锁优化：</p>
<ol>
<li><p>自旋锁/自适应自旋锁，如果一个线程锁定临界资源的时间很短，为了这么短的时间去暂停和恢复线程不值得，因此可以让等待锁的线程在原地等待而不放弃CPU时间，即自旋，避免了暂停和唤醒线程带来的开销。为了避免长时间自旋浪费CPU时间，可以采用自适应自旋，即自旋的时长是自适应的，如果超时还没有获得锁，则用传统方式暂停线程。</p>
</li>
<li><p>轻量级锁/偏向锁，使用CAS方式实现，在没有多线程竞争的情况下，减少互斥同步的开销。依据是：对于绝大部分的锁，在整个同步周期内都是不存在竞争的，而且几乎都是由一个线程获得。这是一个经验法则。</p>
</li>
</ol>
<p>锁升级：锁有四种状态，从低至高分别是无锁、偏向锁、轻量级锁、重量级锁。偏向锁和轻量级锁都不需要进行系统调用，加锁和解锁的开销较小。</p>
<ol>
<li>偏向锁：锁在大部分情况下都不存在竞争，而且几乎都是由一个线程获得。因此可以当一个线程获得锁后，在锁对象的对象头中记录下线程ID，以后该线程再次进入或退出同步块时都不需要执行加锁和解锁操作，只需要判断偏向线程ID是否是自己。如果出现竞争，则撤销偏向锁。</li>
<li>轻量级锁：使用CAS+自旋来获取锁。</li>
<li>重量级锁：由于java采用的是内核线程的方式，会将每一个java线程映射到操作系统的原生线程之上，因此要阻塞和唤醒一个线程需要进行系统调用，在内核态和用户态之间进行模式转换，开销较大，因此synchronized被称为重量级锁。</li>
</ol>
<p>deamon线程：当不存在非deamon进程时，deamon进程就会推出。</p>
<p>可以通过调用线程对象的interrupt()方法对线程进行中断，线程可以通过isInterrupt()方法来检测是否被中断。</p>
<p>suspend、resume、stop不建议使用，因为suspend暂停线程时不会释放资源，可能造成死锁，stop停止线程时可能来不及释放资源。</p>
<p>阻塞队列：插入元素时如果队列已满，则阻塞线程，直到队列不满，获取元素时如果队列已空，则阻塞线程，直到队列不空。</p>
<p>阻塞队列支持：抛出异常的add/remove、返回特殊值的offer/poll、阻塞线程的put/take。</p>
<p>java中的阻塞队列有：</p>
<ol>
<li>LinkedBlockingQueue：链表实现，FIFO队列，默认大小和最大大小是Integer.MAX_VALUE。</li>
<li>LinkedBlockingDeque：链表实现的双向队列。</li>
<li>PriorityBlockingQueue：支持按优先级排序，调用的是自定义类的CompareTo方法，或定义队列时传入的Comparator。</li>
<li>ArrayBlockingQueue：数组实现，FIFO队列，默认是非公平的。</li>
<li>SynchronousQueue：不存储元素，每一个put操作必须必须等待一个take操作，</li>
<li>LinkedTransferQueue：</li>
<li>DelayQueue：延时获取元素，在创建元素时需要指定何时才能获取到当前元素。</li>
</ol>
<p>阻塞队列的实现原理：使用的是等待/通知模式，定义了两个Condition：notfull和notempty，如果生产者添加元素时队列已满，则调用notfull.await进入等待，消费者消费了一个元素，则调用notfull.signal通知生产者。如果消费者消费元素时队列已空，则调用notempty.await进入等待，生产者生产一个元素，则调用notempty.signal通知消费者。</p>
<p>Fork/Join框架是一个并发执行任务的框架，通过把大任务分割成多个小任务并发执行（Fork），再合并多个小任务的执行结果得到大任务的执行结果（Join）。</p>
<p>J.U.C包下的Atomic包提供了多个原子操作类，能够线程安全且性能高效地更新一个变量，这个变量可以是基本数据类型、数组、引用和对象属性。</p>
<p>CountDownLatch：允许一个或多个线程等待其他线程完成操作，创建CountDownLatch对象时，需要传入一个整数类型的计数器初始值，线程可以调用该对象的countDown方法使计数器值减一，当值为0时，阻塞在该对象上的线程（调用了该对象的await方法的线程）被唤醒，恢复执行。不可循环使用</p>
<p>可循环使用的同步屏障CyclicBarrier：线程执行到屏障处时会被阻塞（调用该对象的await()），直到阻塞的线程数达到指定的数量，被屏障拦截的线程才能恢复执行。</p>
<p>信号量Semaphore：控制并发执行的线程数量，每个线程都需要获取许可证才能继续执行，执行完毕后需要释放许可证，许可证数量就是允许的并发数。</p>
<p>线程池的好处：</p>
<ol>
<li>减少资源消耗，避免频繁创建和销毁线程带来的资源消耗。</li>
<li>提高响应速度，收到任务时能立即利用创建好的线程响应。</li>
<li>方便线程管理，使用线程池能对创建的线程进行统一管理。</li>
</ol>
<p>ThreadPoolExecutor执行execute()方法的流程：</p>
<ol>
<li>如果当前工作线程数小于核心线程池大小corePoolSize，则创建新的线程。</li>
<li>否则加入到阻塞队列BlockingQueue。</li>
<li>如果阻塞队列已满，且当前工作线程数小于最大线程池大小MaximunPoolSize，则创建新的线程。</li>
<li>否则执行饱和策略的操作。</li>
</ol>
<p>创建新线程时需要获取全局锁。</p>
<p>创建线程池：new ThreadPoolExecutor()的参数有：</p>
<ol>
<li>corePoolSize：核心线程池大小。</li>
<li>MaximumPoolSize：最大线程池大小。</li>
<li>keepAliveTime：线程空闲后的存活时间。</li>
<li>workQueue：BlockingQueue类型，用于保存等待执行的任务的阻塞队列，可以选用ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue。</li>
<li>RejectedExecutionHandler：饱和策略，当队列和线程池都饱和时，用于处理新提交任务的策略，可以选用：直接抛出异常、直接丢弃、丢弃队列中最老的任务并执行当前任务、使用调用者线程处理任务。还可以通过实现RejectedExecutionHandler接口来自定义策略。</li>
<li>threadFactory：用于创建线程的工厂。</li>
</ol>
<p>可使用execute()方法提交不需要返回值的任务，无法判断线程是否执行成功。submit()方法提交需要返回值的任务，submit方法会返回一个Future对象，可以根据该对象判断线程是否执行成功，并通过get方法来获取返回值，get方法会阻塞调用线程，直到结果返回或超时返回。</p>
<p>可使用线程池对象的shutdown和shutdownNow方法关闭线程池，shutdownNow方法会尝试停止所有正在执行或暂停的线程，而shutdown不会。</p>
<p>如何配置线程池：</p>
<ol>
<li>CPU密集型任务应配置尽可能小的线程，IO密集型可以配置尽可能多的线程。</li>
<li>任务有优先级时使用PriorityBlockingQueue。</li>
<li>使用无界队列，避免内存溢出。</li>
</ol>
<p>Executor框架用于将任务分配到线程，由操作系统负责将线程映射到CPU。</p>
<p>Executor框架包括：</p>
<ol>
<li>任务，实现了Runnable接口的run方法或Callable接口的call方法的类。Runnable不会抛出异常和返回结果，Callable接口可以。</li>
<li>任务执行，创建立即执行任务的线程池ThreadPoolExecutor和创建执行计划或周期任务的线程池ScheduledThreadPoolExecutor。</li>
<li>计算结果，实现了Future接口的FutureTask类。</li>
</ol>
<p>创建线程池：</p>
<ol>
<li>直接创建ThreadPoolExecutor类的对象。</li>
<li>使用Executors工厂类的静态方法。<ol>
<li>Executors.newFixedThreadPool：创建固定线程数量的线程池。核心线程池大小和最大线程池大小都是设定的线程数量，阻塞队列使用的是LinkedBlockingQueue，这是一个无界队列。</li>
<li>Executors.newSingleThreadExcutor：创建单个线程的线程池，用于顺序执行各个任务。核心线程池大小和最大线程池大小都是1，阻塞队列使用的是LinkedBlockingQueue，相当于线程数量为1的固定线程数量线程池。</li>
<li>Executors.newCacheThreadPool:创建大小无界的线程池，用于执行很多短期小任务。核心线程池大小为1，最大线程池大小为Integer.MAX_VALUE，keepAliveTime不为0，阻塞队列使用的是不存储元素的SynchronousQueue，意味着只要任务的提交速度大于线程池处理速度，就会一直创建线程，最终耗尽CPU和内存资源。</li>
</ol>
</li>
</ol>
<p>推荐直接创建而不是使用Executors工厂类，目的是明确线程池运行规则，避免耗尽资源。</p>
<p> 定位故障：</p>
<p>查看虚拟机运行日志、垃圾收集器日志、异常堆栈、线程快照、堆转存快照。</p>
<p>jps 查看虚拟机进程状况</p>
<p>jstat 查看虚拟机统计信息，包括类加载、内存、垃圾收集等运行数据。</p>
<p>jinfo 查看和调整虚拟机的各项参数。</p>
<p>jmap 生成堆转存快照，分析内存。</p>
<p>jstack 生产线程快照，即当前时刻jvm每一条线程正在执行的方法栈集合。</p>
<p>可视化的工具有visualVM、JMC(JAVA MISSION CONTROL，基于JMX，作为JMX的控制台，显示来自JMX的数据和调整JVM参数，也可以显示来自JFR的数据)、JFR(JAVA FLIGHT RECORDER，用于收集数据)、JConsole(基于JMX（JAVA Management Extension），JMX可以对JVM进行信息收集和参数动态调整，从而实现管理与监控）</p>
<p> [<a href="#_msoanchor_4">博4]</a>笔记: 触发条件：</p>
<p>Young GC：Eden区分配满时。</p>
<p>Full GC：Old区或Perm区（如果有的话）的剩余空间小于新生代的历次晋升的平均大小（除CMS外，其余收集器对老年代做gc时会同时收集新生代，即对全堆做gc），或调用System.gc()时。</p>
<p> [<a href="#_msoanchor_5">博5]</a>笔记: GC Roots：</p>
<p>\1. 虚拟机栈中（局部变量、参数、临时变量）中引用的对象。</p>
<p>\2. 类的静态变量、常量引用的对象。</p>
<p>\3. java虚拟机的引用，比如基本数据类型对应的Class对象，一些常驻内存的异常（Nullpoint、stackoverflow）。</p>
<p>\4. 同步锁（Synchronized）持有的对象。</p>
<p>\5. 做partial gc时， 其他区域内含有指向收集区域的引用的对象。</p>
<p> [<a href="#_msoanchor_6">博6]</a>笔记: 虚引用的作用仅仅是在对象被回收时收到系统通知。</p>
<p>不能通过虚引用来获得对象实例。</p>
<p> [<a href="#_msoanchor_7">博7]</a>笔记: 将新生代空间分为较大的eden区和两块较小的from/to survivor区（默认大小比例是8:1），在eden区和from survivor区分配内存，每次gc时将eden区和from survivor区中的存活对象复制至to survivor区，然后再直接清理掉eden区和from survivor区，原from/to survivor区成为下次gc时新的to/survivor区，即to survivor区始终是未使用的空间。这样做的原因是，依据弱分代理论，新生代中每次gc能继续存活的对象非常少，相比于直接将新生代对半分（空用空间只有50%），这样划分下，新生代可用空间占新生代总内存空间的90%。如果to survivor空间不足以容纳一次gc后存活的对象，则通过分配担保的方式，将对象直接保存至老年代。</p>
<p> [<a href="#_msoanchor_8">博8]</a>笔记: 分代收集理论的三个假说：</p>
<p>\1. 弱分代假说：大部分对象的生存周期都很短。（新生代中的对象经过一次gc后的存活概率很低）</p>
<p>2.强分代假说：熬过多次gc的对象更难以消灭。（老年代中的对象经过多次gc后存活的概率较高）</p>
<p>3.跨代引用假说：跨代引用相比于同代引用而言仅占极少数。</p>
<p>基于分代理论，应该将堆分成不同区域，然后根据对象的年龄（年龄即经历过的gc次数），将对象放置在不同区域，然后根据年龄特点选择不同的gc策略，以提高回收效率。</p>
<p> [<a href="#_msoanchor_9">博9]</a>笔记: 标记-清除算法是非移动式的，每次gc时不需要进行复制操作和更新引用关系，因此停顿时间较短，即每次gc的延迟较低，关注延迟的CMS收集器是基于该算法的。但是该算法会产生大量的内存碎片，这就需要更复杂的内存分配和访问机制。</p>
<p>标记-复制算法是移动式的，需要移动存活的对象，并更新这些对象的所有引用，尤其是老年代存活的对象比较多，移动和更新操作开销较大，因此总体延迟较高。</p>
<p>但是，内存分配和访问比垃圾收集的频率要高得多，这个环节的负担会直接影响程序的吞吐量，因此关注吞吐量的parallel scavenge收集器是基于标记-整理算法的。</p>
<p> [<a href="#_msoanchor_10">博10]</a>笔记: 标记-清除算法效率不稳定，会产生大量内存碎片，因此一般不适用。</p>
<p>标记-复制和标记-整理算法能提供规整的内存空间。</p>
<p>新生代中的对象存活率较低，可以使用标记复制算法，老年代的对象存活率较高，如果使用标记复制算法则需要进行较多的赋值操作，效率降低，而且eden区和survivor区的比例要1:1，以应对所有对象都存活的极端情况。否则要使用额外的担保空间，这样空间利用率较低。</p>
<p> [<a href="#_msoanchor_11">博11]</a>笔记: 为什么老年代不使用标记复制算法？</p>
<p>这是不同分代下对象的特点决定的，新生代对象经过一次gc后存活的概率较低，因此可以使用较小的空间来保存每次gc后存活的对象，而老年代对象经过一次gc后存活的概率较高，这样就需要一块较大的空间来保存每次gc后存活的对象，这样空间利用率较低，而且会产生大量的复制操作。</p>
<p> [<a href="#_msoanchor_12">博12]</a>笔记: 垃圾收集区域内的对象可能被其他区域所引用，这就是跨代引用或跨收集区域引用。记忆集就是一种记录从非收集区域指向收集区域的指针集合的抽象收据结构，卡表是记忆集的一种实现，卡表的每一个元素表示一个内存区域（卡页），如果该区域存在包含指向收集区域的引用的对象，则该元素变脏，在进行gc时只需要将变脏的卡页加入gc root中一起扫描，避免了将整个非收集区域加入gc roots扫描范围，减少了扫描区域就提高了效率。</p>
<p>Hotspot虚拟机通过写屏障维护卡表，写屏障可以看成是虚拟机在进行引用类型字段复制的AOP切面，在引用类型变量赋值时，虚拟机会在前后执行额外操作（赋值前的操作称为写前屏障，赋值后的操作称为写后屏障）。</p>
<p>AOP切面：程序在执行到某个点时的前后可以执行程序之外的其他操作，这个点就是横切关注点，程序本身是对这些点无感知的。这样做减少了对程序的侵入，使程序可以专注于自身的业务逻辑，同时可以集中管理散布于系统各处的横切关注点。</p>
<p> [<a href="#_msoanchor_13">博13]</a>笔记: 并发可达性：</p>
<p>将对象分为三种状态：</p>
<p>黑色：该对象及其所有引用的已完成访问。</p>
<p>灰色：该对象已经访问，但至少存在一个引用还没有被访问。</p>
<p>白色：该对象还未被访问。</p>
<p>在收集器工作时，用户线程可能会修改引用关系，导致问题：1. 将原本消亡的对象标记为存活，该错误可以容忍，产生的浮动垃圾可在下次gc时清理掉。 2. 将存活的对象标记为消亡，产生对象消失问题，该问题是致命的。出现条件：插入了从黑色对象到白色对象的引用，并且删除了灰色对象到该白色对象的所有直接或间接引用。</p>
<p>解决方法：破坏出现条件其一即可。</p>
<p>\1. 增量更新：在插入从黑色对象到白色对象的引用时，记录该引用关系，在扫描完成后，再次以记录的引用关系中的黑色对象为根，重新扫描一次，即黑色对象一旦插入指向白色对象的引用，它就成为黑色。</p>
<p>\2. 原始快照：灰色对象删除指向白色对象的引用时，记录该引用关系，在扫描结束后，以记录的引用关系的灰色对象为根，重新扫描，即无论删除与否，都按照扫描开始时的引用关系扫描。</p>
<p> [<a href="#_msoanchor_14">博14]</a>笔记: 额外消耗内存最小，没有线程交互开销。</p>
<p>客户端模式下的默认新生代垃圾收集器。</p>
<p> [<a href="#_msoanchor_15">博15]</a>笔记: 初始标记：暂停用户线程，标记与gc roots直接相连的对象，停顿很短。</p>
<p>并发标记：与用户线程并发进行，从gc roots出发遍历整个对象图。</p>
<p>重新标记：并发标记过程中，用户线程改变了部分引用关系，需要暂停用户线程，使用增量更新，对部分对象重新标记。用时比初始标记长，但远短于并发标记。</p>
<p>并发清除：与用户线程并发进行，清楚标记的已消亡的对象。</p>
<p> [<a href="#_msoanchor_16">博16]</a>笔记: CMS的缺点：</p>
<p>\1. 对CPU资源敏感，在并发阶段，收集器会占用一部分CPU资源，导致用户线程可使用的CPU资源减少。</p>
<p>\2. 无法处理浮动垃圾，可能导致并发失败，而需要暂停用户线程，使用serial old收集器对老年代重新进行垃圾收集。</p>
<p>\3. 标记-清除算法容易导致产生大量内存碎片。</p>
<p> [<a href="#_msoanchor_17">博17]</a>笔记: 用户端模式默认的收集器是serial+serial old。</p>
<p>jdk 9之前，服务器端默认的收集器是parallel scavenge + parallel old，更早以前是parnew + CMS。jdk 9 之后是G1。</p>
<p> [<a href="#_msoanchor_18">博18]</a>笔记: 初始标记：标记与gc roots直接相连的对象。</p>
<p>并发标记：与用户线程并发进行，从gc roots出发遍历整个图，做可达性分析。</p>
<p>最终标记：在并发标记过程中，使用原始快照的方式，记录发生改变的引用关系。在最终标记阶段，暂停用户线程，处理发生改变的引用关系。</p>
<p>筛选回收：暂停用户线程，并行地更新region的统计数据，对各个region的回收成本和收益进行排序，根据用户所期望的停顿时间，选择任意多个region组成回收集，然后将回收集中的存活对象复制到空的region中去，再清理掉旧的region的全部空间。</p>
<p>在并发阶段使用原始快照，如果内存回收速度小于内存回收速度，g1也会暂停用户线程，导致full gc。</p>
<p> [<a href="#_msoanchor_19">博19]</a>笔记: 衡量垃圾收集器的重要指标是：内存占用、吞吐量、延迟。</p>
<p> [<a href="#_msoanchor_20">博20]</a>笔记: G1收集器的特点：</p>
<p>\1. 局部收集：先前的垃圾收集器进行垃圾收集的范围是整个新生代或整个老年代或整个堆，G1可以将堆内任意部分的region区域组成回收集，进行垃圾回收。</p>
<p>\2. 基于region的堆内存布局：不再以固定大小和固定数量进行分代区域划分，而是将整个java堆划分成多个大小相等的独立区域，每个区域都可以按需扮演eden区、survivor区或老年区。为了解决跨region占用，g1使用了记忆集来避免全堆作为gc roots扫描，每个region都维护有自己的记忆集，而且结构更为复杂，因此g1有更高的内存占用。</p>
<p>\3. 可预测的停顿时间模型：垃圾回收所需要的时间大概率不会超过N毫秒. g1收集器会根据每个region的统计数据，预测回收该region所获得的空间大小（收益）以及回收所需要的时间（成本），然后维护一个优先级列表，优先回收价值最大的region。由于需要统计和预测，因此会产生更高的负载。</p>
<p>在小内存应用上CMS的表现大概率优于G1。</p>
<p> [<a href="#_msoanchor_21">博21]</a>笔记: ZGC中的z没有特殊含义，</p>
<p>zgc的只有初始标记和最终标记阶段需要暂停用户线程，其余阶段都是并发执行，而初始、最终标记的停顿时间基本是固定的，与堆容量、堆中对象数量不存在正比例关系，因此zgc可以在任意堆大小下将垃圾收集停顿时间控制在10ms以下。</p>
<p>zgc基于region内存布局、使用了染色指针和内存多重映射等技术实现可并发的标记-整理算法，</p>
<p>染色指针技术：将对象的标记信息直接记录在引用对象的指针上。这是因为64位地址总线的寻址空间远远超过所需要的内存空间（Linux的高18位不能用于寻址），因此可以将其中几位用做标记，而不至于影响目前使用。</p>
<p>以低延迟为首要目标。</p>
<p> [<a href="#_msoanchor_22">博22]</a>笔记: 垃圾收集器更适合称为自动内存管理系统，其基本职责是堆内存的布局与管理、对象的分配与回收。</p>
<p> [<a href="#_msoanchor_23">博23]</a>笔记: 选择垃圾收集器应该考虑的点：</p>
<p>\1. 应用程序的关注点， 在意吞吐量（计算密集型应用）还是延迟（交互式应用）或者是内存占用（客户端应用或嵌入式应用）</p>
<p>\2. 基础设施，包括硬件设施和操作系统。</p>
<p>\3. jdk发行商和版本。</p>
<p> [<a href="#_msoanchor_24">博24]</a>笔记: 对象分配的基本策略：</p>
<p>\1. 对象在eden中分配，如果空间不够，则触发一次minor gc，如果survivor不足以容纳存活对象，则通过分配担保机制转移到老年代去。</p>
<p>\2. 大对象（需要大量连续空间的对象，例如数组或字符串）直接进入老年代，避免产生大量内存复制操作。</p>
<p>\3. 对象具有一个年龄计数器，一次gc进入survivor后年龄设置为1，每经过一次gc，年龄加一，年龄超过一个阈值后进入老年代。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/" data-id="ckmn1ijih000mn8a8bp1ug0nl" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.539Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>分层：</p>
<ol>
<li><p>应用层协议：HTTP、FTP、DNS、SMTP等。</p>
<ol>
<li><p>HTTP协议，超文本传输协议，使用TCP协议</p>
<p>无状态协议，客户端和服务端不会保存连接状态，每一次请求都作为新的请求。解决办法是在客户端设置cookies，在服务端设置session，用来表示用户、跟踪会话。</p>
<p>短链接：HTTP/1.0的默认连接方式，每一次HTTP操作都会新建一个TCP连接，操作结束后就断开连接。缺点：多个TCP连接会消耗更多资源，还会产生更大的延迟。</p>
<p>长连接：HTTP/1.0的默认连接方式，默认在响应头中设置Connection:keep-alive来使用长连接，多次HTTP操作可以使用同一个TCP连接。</p>
<p>HTTP操作：</p>
<p>​    GET：获取URL表示的资源。</p>
<p>​    POST：向服务器提交信息。</p>
<p>​    PUT：在URL下存储文件。</p>
<p>​    DELETE：删除URL表示的资源。</p>
<p>​    HEAD：获取服务器响应信息。</p>
<p>HTTP状态码：响应报文中</p>
<p>​    1xx：通知消息，表示接收的请求正在处理。</p>
<p>​    2xx：成功，表示请求处理成功。200 OK</p>
<p>​    3xx：重定向，301 永久重定向，307 临时重定向</p>
<p>​    4xx：客户端错误，400 请求报文中存在语法错误，401 请求未授权，403 请求被禁止， 404 请求的资源不存在。</p>
<p>​    5xx：服务端错误，500 服务器内部错误， 503 服务不可用， 502 网关错误</p>
<p>HTTP的安全问题：1. 明文传输，不加密，内容可能被窃听， 2. 不进行身份验证，可能遭遇伪装， 3. 不保证报文完整性，可能被篡改。</p>
<p>HTTPS使用TLS传输层安全协议/SSL安全套接字层，S表示security。TLS/SSL可以对HTTP通信进行加密、验证和完整性保护，具体而言，HTTP不直接与TCP通信，而是先与TLS/SSL通信。</p>
<p>对称加密：双方使用同一个密钥进行加密解密，但安全传送密钥是个问题。</p>
<p>非对称加密：使用不公开的私钥和公开的公钥，用私钥加密可用公钥解密，反之用公钥加密可用私钥解密。加密解密操作开销较大。</p>
<p>HTTPS：使用混合加密，先用非对称加密传输对称加密的密钥，随后使用对称加密。</p>
<p>使用认证中心CA来验证公钥的正确性：用户的公钥由认证中心的私钥进行加密，得到认证证书。对方用户使用认证中心的公钥解密认证证书来验证用户公钥的真实性，并使用用户公钥对报文进行加密。</p>
<p>HTTP使用80端口，HTTPS使用443端口，HTTPS由于使用了加密手段，因此具有更高的安全性，但会产生更多资源消耗。</p>
<p>输入url到页面显示的过程：</p>
<ol>
<li>浏览器根据输入的URL查找域名对应的IP，该过程使用了DNS协议，DNS使用了缓存技术，会查找浏览器缓存、本地路由器缓存、本地DNS服务器缓存等。</li>
<li>应用层的DNS报文会使用传输层的UDP协议，再使用网络层的IP协议。</li>
<li>这期间会使用到ARP协议，根据网络层的IP地址来得到数据链路层的MAC地址。</li>
<li>如果DNS服务器与主机不在同一个子网，还可能会设计到OSPF开放最短路径优先等路由协议。</li>
<li>浏览器根据获得的IP地址，向该web服务器发起TCP连接请求，建立连接后发送HTTP请求。</li>
<li>web服务器响应HTTP请求，并返回一个HTML页面。</li>
<li>浏览器解析HTML，继续请求HTML页面中的其他资源，最终渲染。</li>
</ol>
</li>
<li><p>DNS:Domain Name System域名系统，将主机名解析为IP。使用UDP:53,</p>
<p>域名服务器分为根域名服务器、顶级域名服务器和权威域名服务器，每个ISP都有一台本地DNS服务器，</p>
<p>DNS查询分为递归查询（代替请求方进行查询）和迭代查询（返回给请求方下一个应该查询的DNS服务器，再由请求方进行查询），</p>
<p>DNS使用缓存技术提高查询效率，会缓存最近查询过的信息，下次遇到相同查询时直接返回。</p>
</li>
</ol>
</li>
<li><p>传输层协议：TCP、UDP。</p>
<p>TCP:传输控制协议</p>
<p>TCP中的确认号表示确认号之前的分组都已经正确接受，对方下一个发送的分组的序列号应该是这个确认号。</p>
<p>提供面向连接的、保证可靠交付的数据传输服务：应用程序进行通信前需要先建立连接，通信结束后需要断开连接。通过TCP传送的数据不会出现差错和丢失。</p>
<p>TCP只支持点对点通信，不支持广播和多播通信。</p>
<p>提供拥塞控制和流量控制机制，</p>
<p>首部开销大，处理开销大，适用于对数据可靠性要求较高的应用，例如文件传输、邮件传输、远程登陆等。</p>
<p>TCP是面向字节流的，会将应用交付的数据拆分或合并成大小合适的报文段。</p>
<p>建立连接：</p>
<p>发起连接请求的是客户端，接收连接请求的是服务端。</p>
<ol>
<li>开始时，客户端和服务端都处于CLOSED状态。</li>
<li>服务端先创建传输控制快TCB，进入LISTEN监听状态，准备接受客户端的连接请求。</li>
<li>客户端创建传输控制快TCB，向服务端发起连接请求，请求报文的同步标志位SYN=1，同时选择一个初始序列号seq=x，进入SYN-SENT同步已发送状态。</li>
<li>服务端接收到请求报文，如果同意连接则发送确认报文，报文中同步标志位SYN=1、确认标志位ACK=1，确认号ack=x+1，同时选择一个初始序列号seq=y，进入SYN-RCVD同步已接收状态。</li>
<li>客户端收到确认报文后，向服务端发送确认报文，确认标志位ACK=1，确认号ack=y+1，序列号seq=x+1，进入ESTABLISHED连接建立状态。</li>
<li>服务端收到确认报文后，进入ESTABLISHED连接建立状态。</li>
</ol>
<p>为什么需要三次握手？</p>
<p>​    因为IP协议的分组交换网络是尽力而为的，分组在传输过程中可能会丢失，因此通信双发都要知道双方连接请求的收发是否正常，然后才能确定建立了正确的连接。具体而言，第一次握手，即服务端接收到客户端的连接请求报文，服务端可以知道客户端发送正常，服务端接收正常。第二次握手，即客户端接收到服务端的确认报文，客户端可以知道客户端发送正常，接受正常，服务端接受正常，发送正常，因此可以进入连接状态。第三次握手，即服务端收到客户端的确认报文，服务端可以知道服务端发送正常，客户端接收正常，因此可以进入连接状态，</p>
<p>​    如果只进行两次握手，则会产生错误情况，例如客户端发送请求报文，但这个报文的分组在网络某处阻塞了，客户端没有收到服务端的确认报文，则会重新发送请求报文，经过两次握手后建立了连接，但先前的请求报文经过长时间阻塞后重新到达了服务端，服务端会认为是一次新的连接请求，会重新建立连接，这造成了不必要的错误和浪费。如果是三次握手的话，客户端不会回复确认报文，服务端就不会建立连接。</p>
<p>终止连接：</p>
<p>客户端和服务端都可以主动终止连接，以客户端主动终止连接为例。</p>
<ol>
<li>开始时，双方都是ESTABLISHED连接建立状态。</li>
<li>客户端发送连接终止报文，报文中终止标志位FIN=1，序列号seq=u，进入FIN-WAIT-1终止等待1状态。</li>
<li>服务端接收到接连终止报文，发出确认报文，报文中确认标志位ACK=1，确认号ack=u+1，序列号seq=u，进入CLOSE-WAIT终止等待状态。此时客户端已不会发送新的数据，但服务端还可以继续发送数据。</li>
<li>客户端收到确认报文后，进入FIN-WAIT-2终止等待2状态，等待服务器发送连接终止报文。</li>
<li>服务端发送完数据后，发送连接终止报文，报文中终止标志位FIN=1，确认标志位ACK=1，确认号ack=u+1，序列号seq=w（服务端在CLOSE-WAIT状态发送了数据），进入LAST-ACK最后确认状态。</li>
<li>客户端收到连接终止报文后，发出确认报文，报文中确认标志位ACK=1，确认号ack=w+1，序列号为u+1，进入TIME-WAIT时间等待状态。此时连接并没有释放，必须结果2*MAL（最长报文段寿命）时间后，客户端撤销TCB，才进入CLOSED状态。</li>
<li>服务器收到确认报文后，进入CLOSED状态。</li>
</ol>
<p>为什么客户端要等待2*MSL？</p>
<p>为了保证最后一个确认报文能正确达到服务器，使用IP协议的分组交换网是尽力而为的，分组在传输过程中可能会丢失。如果最后一个确认报文丢失，服务器超时未收到确认报文，则会重新发送连接终止报文，如果客户端发送完最后一个确认报文后，直接关闭连接，则服务器重发的连接终止报文不会被处理。因此客户端需要等待2倍的最长报文寿命，从而在这个时间内处理重传的连接终止报文。</p>
<p>为什么是2倍而不是1倍或3倍？<br>2倍的最长报文寿命，是因为服务端如果在客户端发送最后一个确认报文后的一个最长报文寿命时间内没有收到确认报文，则可认为该报文已丢失，然后会重传终止报文，这个报文最长经过一个最长报文寿命时间到达客户端，因此如果在两个最长报文寿命时间内没有受到重传的连接终止报文，则可认为服务端已经接收到了确认报文，并关闭了连接，因此客户端也可以关闭连接了。</p>
<p>为什么建立连接需要三次握手，终止连接需要四次挥手呢？</p>
<p>建立连接时，服务器处于LISTEN状态，收到连接建立请求的SYN报文后，可以将确认报文和连接建立请求合并成一个报文发送给客户端，即同时将SYN标志位和ACK标志位设置1。而终止连接时，收到FIN连接终止报文仅仅表示对方已经不再发送新的报文，但自己的报文可能还没有发送完毕，因此需要先回复一个ACK确认报文，当自己的报文发送完毕后再发送FIN连接终止报文，因此需要多发送一次报文。</p>
<p>如果已经建立连接，但是一方或者网络发生故障怎么办？</p>
<p>TCP协议为每个连接维护了一个计时器，每次收到报文后都会复位计时器，如果超时没有收到新的报文，则会发送探测报文，连续多次发送探测包后仍没有收到回复，则认为出现了故障，会关闭连接。</p>
<p>TCP可靠传输机制：</p>
<ol>
<li><p>编号：TCP发送分组时会给每个分组编号，TCP接收到分组后会根据编号进行排序，将有序的数据交付给上层应用。TCP是面向字节流的，编号是按字节大小增加的。</p>
</li>
<li><p>确认：接收方接收到报文后，会给发送方返回一个确认。TCP发送完报文段后会保留该报文段，直到收到确认信号，以便超时重传。</p>
</li>
<li><p>校验：TCP会对首部和数据进行校验，如果数据有差错，则丢弃，并不确认收到。</p>
</li>
<li><p>超时重传：TCP会为每个发送完的报文设置一个超时计时器，如果超时未收到确认报文，则认为报文丢失，会重传该报文。重传等待时间比分组的平均往返时间稍长一点。</p>
<p>如果确认报文丢失，则发送方会超时重传，接收方会丢弃重复报文，并重传该报文的确认报文。</p>
<p>如果确认报文迟到，则发送方会超时重传，接收方会丢弃重复报文，并重传该报文的确认报文。接收方会丢弃重复的确认报文。</p>
</li>
</ol>
<p>ARQ自动重传请求：使用了确认和超时机制，发送方超时未收到某个分组的确认，则会自动重传该分组，接收方不需要请求发送方重传某个出错的分组，而是不对该分组进行确认。从而在不可靠的基础上实现了可靠传输。</p>
<p>停止等待协议：发送方发送完一个分组后会停止发送，并等待接收方确认，收到确认后再发送下一个分组。实现简单，但信道利用率低。</p>
<p>连续ARQ协议：发送方维持一个发送窗口，位于窗口内的分组可以连续发出，而不需要等待接收方的确认。接收方采用累计确认的方式，即接收方不必对接收到的分组逐个发送确认，而是收到几个分组后，对按序到达的最后一个分组发送确认，表示该分组之前的分组都已经正确接收。发送方收到确认后，会将窗口向后移动，使其不包含已确认的分组。缺点：若窗口内的某个分组丢失，发送方需要重传窗口内该分组及后面的所有分组。</p>
<p>滑动窗口：</p>
<p>TCP头部有一个16位的字段是窗口，是指该分组的发送方的接收窗口大小，窗口值表示允许的对方发送窗口大小，即允许对方发送的数据量（以字节为单位），这是因为接收方的数据缓存空间有限，或网络承载能力有限。</p>
<p>发送窗口的大小不能大于对方接收窗口的大小。</p>
<p>发送缓存暂时存放：1. 目前尚未发送的数据， 2. 已经发送到未收到确认的数据。</p>
<p>接收缓存暂时存放：1. 按序到达到应用程序尚未读取的数据， 2. 未按序到达的数据。</p>
<p>流量控制：使用滑动窗口机制，控制发送方的发送速率，以使得接收方来得及接受。发送方的发送窗口大小不能超过接收方给定的接收窗口的大小，大小以字节为单位。</p>
<p>拥塞控制：</p>
<p>对某一网络资源的需求，例如链路带宽、交换节点的交换能力等，超出了可用的网络资源，就会产生拥塞。拥塞会使丢包率、延迟、吞吐量降低。</p>
<p>拥塞控制是指：防止过多的分组进入网络，超出网络的负载能力。</p>
<p>与流量控制的区别：流量控制是一个端到端的问题，目的是使发送方的发送速率与接收方的接收速率匹配，而拥塞控制是一个全局性的过程，因为网络中任意一个节点都可能产生拥塞。它们的相似之处在于，部分拥塞控制算法与流量控制一样，都是减小发送方的发送速率，以减小网络负载。</p>
<p>发送方维持一个拥塞窗口的状态变量，拥塞窗口的大小取决于当前网络的拥塞程度，并且在动态变化，发送方让发送窗口大小等于拥塞窗口大小。</p>
<p>拥塞控制有四种算法：</p>
<ol>
<li>慢开始：主机在发送分组时，不清楚网络状况，因此先将拥塞窗口设置为一个较小值，然后按照指数规律增大拥塞窗口。具体而言，每经过一个传输轮次，拥塞窗口就变为原来的2倍。传输轮次是至将拥塞窗口内的分组全部发送出去，并收到对窗口内最后一个分组的确认。</li>
<li>拥塞避免：为了避免拥塞窗口太大，造成网络拥塞，当拥塞窗口大于设定的慢开始门限时，开始使用拥塞避免算法，使拥塞窗口按线性规律增大。当网络出现了超时，即发送方超时未收到确认，则发送方认为网络出现了拥塞，于是将慢开始门限减小为原值的一半，并执行满开始。</li>
<li>快重传：接收方收到报文段后要立即进行确认，以让发送方尽早知道个别报文段发送了丢失。当发送方连续收到3个对同一报文段的重复确认，则立即进行重传，避免发送方因个别报文段丢失，而认为网络出现拥塞，而使用慢开始，导致传输效率降低。</li>
<li>快恢复：进行快重传时，发送方知道网络并没有拥塞，只是丢失了个别报文，于是执行快恢复算法，即将慢开始门限和拥塞窗口设定为当前拥塞窗口的一半，然后执行拥塞避免算法。</li>
</ol>
<p>接收方可以通过TCP头部中的接收窗口大小来控制发送方的发送窗口大小，因此考虑流量控制和拥塞控制后，发送方最终的发送窗口大小为拥塞窗口和接收窗口中的最小值。</p>
<p>UDP：用户数据报协议</p>
<p>提供无连接的、不保证可靠交付的数据传输服务，不提供拥塞控制和流量控制机制。适用于对数据可靠性要求不高的应用，例如视频和直播。</p>
<p>支持一对多、多对多的广播和多播通信，首部开销小，处理开销小，</p>
<p>UDP通信不需要建立连接，因此不使用套接字。</p>
<p>UDP是面向报文的，不会对应用交付的报文进行拆分或合并，如果报文太长，由IP层进行分片。</p>
<p>TCP/UDP的端口号是16位，共有65535个可用端口，0-1023是well-know端口，被一些通用的协议占用，例如使用80端口的http协议，使用443的https协议，使用21端口的ftp协议。同一个主机上的客户进程的占用的端口号是唯一的，用于在网络通信中标识通信进程。  </p>
</li>
</ol>
<ol start="3">
<li><p>网络层协议：IP、ICMP等。</p>
<p>网络层向上层提供尽最大努力交付服务，分组可能会丢失。</p>
<p>网络层提供的是网络中两台主机之间的通信，传输层提供的是应用进程之间的通信。</p>
<p>IP：网际协议</p>
<p>IP地址由网络号和主机号构成，共4个字节长，ABC类网络的网络号分别为1、2、3个字节长，主机号全为0的IP地址表示本网络，主机号全为1的IP地址表示该网络上的所有主机。</p>
<p>IP地址与MAC地址的区别：MAC地址是数据链路层和物理层使用的地址，与硬件绑定，IP地址是网络层及以上使用的地址，是用软件实现的逻辑地址。</p>
<p>IP协议只对首部进行检验，不对数据进行检验。</p>
<p>数据链层中一个数据帧的数据字段的最大长度，称为最大传输单元MTU，如果IP数据报封装成数据链路层的帧后的大小超过MTU，则需要进行分片。</p>
<p>TTL time to live，表示数据报可以经过的最大跳数。</p>
<p>IP地址与子网掩码进行与操作可以得到子网地址。</p>
<p>路由表中包含目的网络地址、子网掩码、下一跳端口，路由器收到分组后，将分组中的目的IP与路由表中的各项子网掩码进行与操作，如果结果与目的网络地址一致，则转发至响应的下一跳端口。如果有多个目的网络匹配，则选择子网掩码最长的，因为更长的子网掩码意味着对应网络中的主机数越少，这又称为最长前前缀匹配。</p>
<p>ARP：地址解析协议</p>
<p>根据IP地址得到MAC地址。</p>
<p>ICMP：网际控制报文协议</p>
<p>ping、traceroute命令使用了ICMP。</p>
<p>ping命令向目的主机回送请求报文，根据发送和接收报文的时间戳得到往返时间。</p>
<p>traceroute命令向目的主机发送一系列无使用非法端口而无法交付的UDP数据报，并且每个数据报的TTL从1开始依次递增，数据报每经过一个路由器时，ttl都会减一，当ttl为0时，路由器会返回一个ICMP时间超时的报文，或者到达主机，主机返回一个ICMP终点不可达报文，从而可以跟踪源主机到目的主机的路由信息。</p>
<p>MPLS：多协议标签交换，在MPLS的入口上打上标签，后续直接在数据链路层根据标签转发，而不用进行查找路由表。</p>
<p>路由协议：</p>
<p>内部网关协议：适用于自治系统（路由协议和网络布局等内部统一，但独立于外部，不与外部共享的系统，例如一个大型ISP的网络）内部的协议，例如OSPF最短路径优先。</p>
<p>外部网关协议：自治系统之间的路由选择协议，例如BGP边界网关协议。</p>
</li>
<li><p>数据链路层：ARP等。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/" data-id="ckmn1ijif000kn8a80jxibhr2" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据库笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.534Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>事务：一组操作的集合，满足ACID特性。</p>
<p>事务transaction的ACID：</p>
<p>Atomicity原子性：事务提交之后要么全部执行成功，要么失败回滚到提交之前的状态，不能出现部分执行成功，部分执行失败。使用undo log回滚日志实现，回滚日志记录事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<p>Consistency一致性：数据库在事务提交前后都保持一致性状态，满足所有数据完整性约束，通过原子性+隔离性+持久性来保持数据库的一致性。</p>
<p>Isolation隔离性：一个事务在提交之前对其他事务是不可见的，通过读写锁+MVCC实现。</p>
<p>Durability持久性：事务一旦提交，则其所做的所有修改都会永久保存到数据库中，即使系统崩溃，执行结果也不会丢失。使用redo log重做日志实现。</p>
<p>并发一致性问题：</p>
<ol>
<li>丢失修改，事务A对数据的修改覆盖了事务B的修改。</li>
<li>读脏数据，事务A读取了事务B修改的数据，但事务B随后撤销了这次修改。</li>
<li>不可重复读，事务B在事务A两次读取数据间隔中修改了数据，导致事务A两次读取的同一个数据不一致。</li>
<li>幻读，事务B在事务A两次读取数据间隔中删除或插入了数据，导致事务A两次读取的数据的个数不一致。</li>
</ol>
<p>产生并发不一致问题的原因在于破坏了事务的隔离性。</p>
<p>MySQL支持行级锁和表级锁，锁住的数据范围越小，即锁粒度越小，发生锁争用的可能性就越小，并发程度就越高，但是锁的的各种操作，例如获取锁、释放锁、检查锁状态都会增加系统开销，因此锁粒度越小，系统开销就越大。</p>
<p>锁分为排它锁（互斥锁、写锁）和共享锁（读锁），</p>
<p>三级锁协议：</p>
<ol>
<li><p>一个事务写数据前需要获取写锁，事务结束后再释放写锁。可以解决丢失修改问题，因为一个事务进行写操作时，另一个事务不能进行写操作。</p>
</li>
<li><p>一个事务读数据前需要获取读锁，读完数据后再释放读锁。可以解决读脏数据问题，因为一个事务获得写锁的情况下，另一个事务不能获得读锁，从而不能使另一个事务读取未提交的数据。</p>
</li>
<li><p>一个事务读数据前需要获取读锁，事务结束后再释放读锁。可以解决不可重复读问题，因为一个事务在获得读锁的情况下，另一个事务不能获得写锁，从而避免了在读数据期间，数据发生变化。</p>
<p>MySQL使用了二级锁协议，会在需要时自动加锁，也可以显示指定加锁：<code>SELECT ... LOCK IN SHARE MODE;</code>或者<code>SELECT ... FOR UPDATE</code>。</p>
</li>
</ol>
<p>隔离级别：</p>
<ol>
<li>读未提交：事务可以见到其他事务未提交的修改，即事务所做的修改，即使未提交，也对其他事务可见。存在脏读、不可重复读、幻影读问题。</li>
<li>读已提交：事务只能见到其他事务已提交的修改，即事务所做的修改在未提交时对其他事务可见。存在不可重复读、幻影读问题。</li>
<li>可重复读：同一个事务多次读取同样数据的结果是一致的。存在幻影读问题。</li>
<li>可串行化：强制事务串行执行，需要加锁。串行执行不存在并发一致性问题。</li>
</ol>
<p>MySQL默认隔离级别是可重复读</p>
<p>多版本并发控制MVCC：</p>
<p>MySQL中InnoDB存储引擎实现隔离级别的一种方式，可以实现读已提交和可重复读的隔离级别，读未提交隔离级别只需要每次读最新数据即可，不需要使用MVCC，可串行化隔离级别需要对所有操作的行进行加锁，单纯使用MVCC无法实现。</p>
<p>通过保存数据快照实现MVCC，</p>
<p>系统版本号：一个递增的数字，每次开始一个新事务，系统版本号就自动递增。</p>
<p>事务版本号：事务开始时的系统版本号。</p>
<p>为每一行添加两个隐藏的列</p>
<ol>
<li>创建版本号：创建或最后一次修改该快照时的系统版本号。</li>
<li>删除版本号：删除该快照时的系统版本号，如果系统版本号大于删除版本号，表示该快照已经删除。</li>
</ol>
<p>快照存储在undo log回滚日志中。</p>
<p>执行insert操作，会将当前事务版本号作为当前数据行快照的创建版本号。</p>
<p>执行delete操作，会将当前事务版本号作为当前数据行快照的删除版本号。</p>
<p>执行update操作，会将当前事务版本号作为更新前数据行快照的删除版本号和当前数据行快照的创建版本号，相当于先delete再insert。</p>
<p>执行select操作，读取的数据行快照的创建版本号应该小于当前事务版本号，删除版本号应该大于当前事务版本号。</p>
<p>快照读：读取的是MVCC快照中的数据，包括非可串行话隔离级别下不加锁的select操作，可以减少加锁带来的开销。</p>
<p>当前读：读取的最新数据，会对当前读取的数据进行加锁，防止其他事务修改数据，是一种悲观锁操作，包括select加共享锁（select … lock in share mode）或加排他锁锁（select … for update）、update（排他锁）、insert（排他锁）、delete（排他锁）、可串行化隔离级别。</p>
<p>MVCC不能解决幻读问题，使用MVCC和Next-key锁可解决幻读问题。</p>
<p>Record lock：记录锁，锁定索引，包括主键或唯一索引。如果表没有设置索引，InnoDB会自动在主键上创建索引，如果表没有设置主键，则InnoDB会自动创建一个自增的主键。</p>
<p>Gap lock：间隙锁，锁定两个索引之间的间隙，但不包括索引本身。可以防止其他事务删除记录或插入新纪录，避免幻读。</p>
<p>Next-key lock：是record lock和gap lock的结合，锁定记录的索引本身和索引之间的间隙。是InnoDB在可重复读的隔离级别下的加锁方式，防止出现幻读。</p>
<p>锁选择：</p>
<ol>
<li>如果更新条件没有走索引，则进行全表扫描。扫描时要避免其他任何更新操作，因此要使用表锁。</li>
<li>如果更新条件是索引，但并不是主键或唯一索引，则使用Next-key锁，保证符合条件的记录加锁，还保证锁定的区间不能插入新数据。</li>
<li>如果更新条件是唯一索引，则找到相应记录，使用记录锁。</li>
</ol>
<p>redo log和undo log都数据InnoDB的功能，是事务日志，bin log是MySQL的功能。</p>
<p>redo log：重做日志，是一种物理日志，记录了修改后的数据，用来实现事务的持久性。当数据库发生奔溃时，可根据重做日志恢复数据。事务提交时，重做日志先于数据持久化的磁盘。</p>
<p>undo log：回滚日志，是一种逻辑日志，记录了对数据修改的反向操作，例如执行delete时，undo log中记录对应的insert，反之亦然，用来实现事务回滚和MVCC的功能，保证事务原子性。如果用户事务执行失败了，或进行了回滚，则可利用undo log来执行反向操作，将数据回滚到修改之前的样子。回滚日志先于数据持久化到磁盘上。</p>
<p>关系数据库设计理论：</p>
<p>不合范式的关系会产生多种异常，包括</p>
<ol>
<li>冗余异常：部分信息在多个记录中出现。</li>
<li>修改异常：由于部分信息在多个记录中出现，因此可能出现仅修改了部分记录中的信息，</li>
<li>删除异常，删除一个信息，可能会导致其他信息丢失。</li>
<li>插入异常：插入一个信息时，可能会因为缺乏其他信息，而无法插入。</li>
</ol>
<p>第一范式1NF：属性不可分，</p>
<p>第二范式2NF：每个非主属性（非键码中的属性）完全依赖于键码（能够决定关系中的其他属性，并且是最小的），可通过分解实现，即将一个表拆分为两个表。</p>
<p>第三范式3NF：非主属性不传递函数依赖与键码（a-&gt;b，a决定b，则称b依赖于a。a-&gt;b且b-&gt;c，则a-&gt;c，称为传递函数依赖），可通过分解实现，</p>
<p>MySQL是开源的关系型数据库，默认端口是3306。可以通过TCP/IP套接字、命名管道、Unix域套接字连接MySQL Server。</p>
<p>InnoDB将记录按照页的方式存储在磁盘中，由于CPU与磁盘存在较大的速度差异，因此需要使用缓存。在数据库中进行读页操作时，将从磁盘读到的页存放在缓冲池中，下次再读相同的页，则直接从缓冲池中读取。在数据库中进行修改操作，则首先修改缓冲池中的页，然后再以一定的频率刷新到磁盘中。</p>
<p>缓冲池中的的数据有：索引页（B+树非叶节点）、数据页（B+树叶节点）、自适应哈希索引、undo页、锁信息、插入缓存等。使用LRU最近最少使用算法来管理缓冲页。被修改的页称为脏页，通过checkpoint机制将脏页刷新回磁盘。checkpoint机制主要是决定什么时候将哪些脏页刷新回硬盘。</p>
<p>InnoDB的内存区域除缓冲池外，还有重做日志缓冲池redo log buffer，InnoDB首先将重做日志信息放入这个缓冲区，再按一定频率刷新到磁盘上的重做日志文件。</p>
<p>当事务提交时，先写重做日志，再修改写，当由于发生宕机而导致数据丢失时，可以通过重做日志恢复数据。</p>
<p>自适应哈希：使用哈希索引进行查找的复杂度为O(1)，而是用B+树进行查找的复杂度取决于树的高度，通常是3-4层。InnoDB会监控对表上各索引的查询，自动根据访问的频率和模式为某些热点页建立哈希索引。访问模式是指查询条件。</p>
<p>MySQL的日志文件：</p>
<ol>
<li>错误日志，记录了MySQL启动、运行关闭过程中的信息。</li>
<li>二进制日志：记录了对MySQL进行更改的所有操作。</li>
<li>慢查询日志：记录了所有运行时间超过设定阈值的SQL语句，进行数据库优化的参考。</li>
<li>查询日志：记录了所有对MySQL数据库请求的消息。</li>
</ol>
<p>MySQL的逻辑存储结构：</p>
<ol>
<li>表空间，所有数据都存放在表空间中，可以将每张表单独放在一个表空间中。</li>
<li>段，包括数据段、索引段等，InnoDB存储引擎是按索引组织的，数据即索引，索引即数据，数据段就是B+树的叶子节点，索引段就是B+树的非叶节点。</li>
<li>区，又称为块，存储多个连续的页。</li>
<li>页，存储多个连续的记录行。</li>
</ol>
<p>视图：由一个查询定义的虚表，视图中的数据没有持久化到物理存储中。</p>
<p>存储引擎的作用：</p>
<p>数据库的存储引擎是数据库的底层软件组件，是数据库管理系存储数据、建立与维护索引、加锁与解锁、查询更新数据等操作的具体实现。</p>
<p>存储引擎：show engines</p>
<ol>
<li><p>InnoDB</p>
<p>支持行级锁和表级锁、事务和外键。主要面向OLTP，</p>
</li>
<li><p>MyISAM，索引顺序访问方法</p>
<p>只支持表级锁，不支持行级锁，不支持事务，不支持外键。批量插入速度块，占用的磁盘和内存空间小，主要面向OLAP，</p>
</li>
</ol>
<p>表级锁：对当前操作的整张表进行加锁，锁粒度最大，资源消耗较少，发生锁争用的可能性大，并发程度较低。</p>
<p>行级锁：对当前操作的行进行枷锁，锁粒度最小，资源消耗较大，发生锁争用的可能性小，并发程度较高。</p>
<p>MySQL中的索引：</p>
<ol>
<li><p>哈希索引：</p>
<p>能够以O(1)的复杂度进行查找，但失去了有序性，因此无法用于排序和分组，部分查找（字符串通配符查找）和范围查找，只适用于等值查询。</p>
<p>Hash索引不支持多列联合索引，因为Hash索引计算的是多个索引列合并在一起后的哈希值，而不是对每个索引列单独计算哈希值，因此使用联合索引中的部分列进行查找时，无法利用联合索引。</p>
<p>InnoDB会监控对索引的查询，自动根据访问频率和模式（相同的查询条件为一个模式）为某些热点数据页建立哈希索引，称之为自适应哈希索引。</p>
</li>
<li><p>B+树索引：</p>
</li>
</ol>
<p>  B+树是一种为磁盘或其他辅助存储设备设计的平衡查找树（平衡查找树是指树的任何节点的各个子树的高度差不超过1），B+树中的所有记录节点都是按键值大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。为了保持平衡，在插入数据时可能会对页进行拆分、合并或旋转。</p>
<p>  非聚簇索引：MyISAM中的B+树的叶节点存放的是数据记录的地址，即数据与索引分离，称为非聚簇索引。</p>
<p>  聚集索引：InnoDB的主索引文件本身就是数据文件，其B+树的叶节点存放了完整的行记录数据，表的存储按主键的顺序进行组织（称为索引组织表），并不是物理上连续，而是逻辑上连续，通过双向链表进行连接，主索引的key就是数据的主键，称为聚簇索引，或聚集索引。在根据主索引搜索时，直接找到主键所在的叶节点取出数据即可。好处是：能直接在叶节点中获得数据，进行范围查询时速度快。</p>
<p>  辅助索引：主键和唯一索引以外的其他索引是辅助索引，其B+树的叶节点存放存放的是相应记录的主键的值，而不是完整的行记录数据，在根据辅助索引搜索时，则需要先取出主索引的值，再根据主索引查找数据。</p>
<p>  B+树并不能直接查找到给定键值所在的行，只能定位到行所在的页（页是InnoDB最小存储管理单位），然后将整页读取到内存中，在内存中进行查找。</p>
<p>  最左前缀查找：联合索引则是根据定义联合索引时的顺序进行排序，如果按照索引列的顺序进行查找，即查询条件精确匹配联合索引的最左侧一列或连续几列时，则可以使用索引，称为最左前缀查找。</p>
<p>  为什么不使用红黑树？</p>
<ol>
<li><p>平衡树的查找复杂度与树高相关，红黑树的出度只有2，而B+树的出度非常大，因此红黑树的高度远大于B+树。</p>
</li>
<li><p>B+树中的记录节点是顺序存储的，使用B+树可以减少磁盘随机IO。</p>
</li>
<li><p>全文索引</p>
</li>
</ol>
<p>回表：辅助索引存储的是索引值和对应记录的主键，因此通过辅助索引进行查找时，如果索引没有包含正在查询的所有数据，即不能使用覆盖索引，则需要根据得到的主键值在主键索引（聚集索引）中查找记录信息，这就叫回表。</p>
<p>覆盖索引：</p>
<p>辅助索引中包含了正在查询的所有数据，即索引字段包含了查询语句（SELECT）与查询条件（WHERE\GROUP BY\ORDER BY)中所涉及的字段，因此进行查询时不必再通过主键索引进行二次查找（回表），并且索引是按顺序存放的，可以避免随机访问记录，减少了随机IO，能提高查询性能。</p>
<p>为什么使用索引？</p>
<p>索引的优点：</p>
<ol>
<li>使用索引可以避免全表扫描，提高查找速度。</li>
<li>由于InnoDB是索引组织表，即数据按照索引顺序存放，因此使用索引可以避免服务器进行排序和分组。</li>
<li>因为InnoDB是索引组织表，数据是有序存放，可以将随机IO变成顺序IO，减少了寻道时间。</li>
</ol>
<p>索引是不是越多越好：</p>
<p>不是，索引在大部分情况下可以提高查询效率，但是维护索引会带来额外的时间和空间开销，降低更新和插入效率。在某些情况下，还可能降低查询效率，这是由于MySQL优化器在选择优化时，会对每一个索引进行评估，以生成最好的执行计划，如果多个索引都可以用来查询的话，会增加MySQL优化器生成执行计划的时间，导致查询效率降低。</p>
<p>索引是怎么提高查询速度的？</p>
<p>使用树高较小的平衡查找树B+树将无序的数据变为有序，提高查找速度，并采用聚集索引，直接在索引文件中获得完整记录，减少了磁盘随机IO。</p>
<p>选择哪些字段作为索引：</p>
<ol>
<li>出现在SELECT、UPDATE、DELETE语句的WHERE从句中的字段，</li>
<li>出现在GROUP BY、ORDER BY、DISTINCT中的字段。</li>
<li>多个表进行JOIN时的关联列。</li>
</ol>
<p>如果选择联合索引的顺序？</p>
<p>选择性（区分性）越大的字段放在联合索引的越左边，选择性（区分度）是指不同的索引值占总记录数的比值。</p>
<p>索引优化：</p>
<ol>
<li>进行查询时，索引不能是表达式的一部分，也不能是函数的参数，否则不能使用索引。</li>
<li>使用多个条件进行查询时，使用联合索引比单个索引性能更好。</li>
<li>使用联合索引时，应使选择性更强的列放在前面，选择性是指不重复的索引值占总记录数的比值，这样可以使区分度更高，从而使查询效率更高。</li>
</ol>
<p>索引的使用条件：在数据表很小时，进行全表扫描比建立索引更高效。在数据表很大时，建立和维护索引所需要代价很大。因此索引适合于中等大小的表。</p>
<p>查询性能优化：</p>
<p>使用EXPLAIN命令分析select语句，重点关注</p>
<ol>
<li>select_type：查询类型，有简单查询、联合查询、子查询等。</li>
<li>key：使用的索引。</li>
<li>row：扫描的行数。</li>
</ol>
<p>大表优化：</p>
<ol>
<li>查询时限定查询范围和数量。</li>
<li>读写分离，对数据库进行拆分，主库负责写，从库负责读，可以缓解锁的争用，增加了冗余，常使用代理实现，。</li>
<li>垂直分区，根据数据库表列的相关性，对表进行拆分，即将一张列比较多的表拆分成多张表，优点是：可以使单个记录变小，在查询时减少读取的block数，减小IO次数。 缺点是：主键出现冗余，会额外多出join操作。</li>
<li>水平分区，保持表的结构不变，通过某种策略将存储的数据进行分片，即将数据行进行拆分，将数据分散存储到不同的表或库中，缺点是跨片的事务难以解决。</li>
</ol>
<p>池化设计：使用一个池子保存可能会要用到的资源，每次需要使用资源时直接从池子中获取，使用完后放回到池子中，常见的有线程池和数据库连接池。</p>
<p>池化的好处：</p>
<ol>
<li>减少资源消耗，线程的创建和销毁或连接的建立和释放等需要消耗资源，采用池化设计复用线程和连接，从而可以减少这部分消耗。</li>
<li>提高响应速度，当有新的任务或查询需要执行，可以立即从池中获取就绪的线程或连接，避免了线程创建或连接建立的等待时间。</li>
<li>减少管理难度，采用池化设计，可以统一管理线程或连接，避免将管理操作分散到各处。</li>
</ol>
<p>Redis是一个将数据存储在内存里的键值型数据库，它的数据都直接存放在内存中，因此读写速度非常快，常用来做分布式缓存和分布式锁。</p>
<p>一条SQL语句执行得很慢的原因有哪些：</p>
<p>分两种情况讨论，</p>
<ol>
<li><p>偶尔执行得很慢，可能是</p>
<ol>
<li><p>数据库正在刷新脏页，占用了磁盘IO和CPU资源。</p>
<p>数据库插入或更新数据时先在内存中进行，然后把更新记录写入重做日志，再通过重做日志将数据同步到磁盘中去。内存中与磁盘中数据不一致的页称为脏页。当</p>
<ol>
<li><p>重做日志缓冲写满， </p>
</li>
<li><p>内存不够用（查询的数据页不在缓冲中，需要将该数据页存入缓冲，如果缓冲池容量不够，则需要淘汰最近最少使用的数据页，如果是干净页则直接释放，如果是脏页，则需要刷新回内存）， </p>
</li>
<li><p>MySQL负载减轻， </p>
</li>
<li><p> MySQL正常关闭时，</p>
</li>
</ol>
<p>会将脏页刷新到磁盘中。</p>
</li>
<li><p>获取不到锁。</p>
</li>
</ol>
</li>
<li><p>一直很慢，可以使用EXPLAIN语句对查询语句进行分析，可能是：</p>
<ol>
<li>没有使用索引，可能是<ol>
<li>查询使用的字段没有建立索引。</li>
<li>索引是表达式的一部分，或者是函数的参数，这种情况下不会使用索引。</li>
</ol>
</li>
<li>数据库选错索引<ol>
<li>MySQL优化器在选择优化时，会对每一个索引进行评估，以生成最好的执行计划，但是这个执行计划不一定是最优的，有可能会走全表扫描，或者走另一个非最优的索引。可以使用FORCE INDEX(index)强制走指定索引。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>SQL操作</p>
<ol>
<li><p>创建表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table 表名  &#123;</span><br><span class="line">	列表 数据类型 列约束,</span><br><span class="line">	...</span><br><span class="line">	表约束，</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 根据表<span class="number">2</span>的结构创建表<span class="number">1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表<span class="number">1</span> <span class="keyword">LIKE</span> 表<span class="number">2</span></span><br><span class="line"></span><br><span class="line"># 根据表<span class="number">2</span>的结构创建表<span class="number">1</span>，并添加表<span class="number">2</span>的数据，即将表<span class="number">2</span>的数据插入到一个新表表<span class="number">1</span>中</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表<span class="number">1</span> <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>修改表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 添加列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> 表名 <span class="keyword">ADD</span> 列名 数据类型;</span><br><span class="line"># 删除列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> 表名 <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> 列名;</span><br><span class="line"># 删除表</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名</span><br></pre></td></tr></table></figure></li>
<li><p>插入Create</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 (col1, col2) <span class="keyword">VALUES</span>(val1, val2);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 (col1, col2) <span class="keyword">SELECT</span> col1, col2 <span class="keyword">FROM</span> 表;</span><br></pre></td></tr></table></figure></li>
<li><p>更新Update</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名 <span class="keyword">SET</span> col1<span class="operator">=</span>val1 <span class="keyword">WHERE</span> col2<span class="operator">=</span>val2; </span><br></pre></td></tr></table></figure></li>
<li><p>删除Delete</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> col<span class="operator">=</span>val;</span><br><span class="line"># 清空表中的数据</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure></li>
<li><p>查询Retrieve</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 去除重复行</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1, col2 <span class="keyword">FROM</span> 表名</span><br><span class="line"># 限制返回的行数，第一个参数为起始行，默认为<span class="number">0</span>，起始行不在返回结果内，第二参数为返回的行数，LIMIT arg1, arg2返回第arg1<span class="operator">+</span><span class="number">1</span>至第arg1<span class="operator">+</span>arg2行。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">DESC</span>降序，<span class="keyword">ASC</span>升序（默认），可以为多个列指定不同的排序方式</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>，col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>过滤</p>
<p>等于=，不等于&lt;&gt;或!=，大于等于&gt;=或!&lt;， 小于等于&lt;=或!&gt;，</p>
<p>在两个值之间BETWEEN a AND b，</p>
<p>为NULL值is null，</p>
<p>用AND和OR链接多个过滤条件，</p>
<p>IN操作符用于匹配一组值，例如<code>WHERE col IN (V1,V2,…,VN)</code>，或后接一个子查询<code>WHERE col IN SELECT * FROM table</code>。</p>
<p>字符查找用LIKE，可用通配符_匹配一个字符，%匹配0个或任意个字符，[]匹配集合内的内容，例如[ab]可以匹配a或b，也可以使用^对其进行否定，即不匹配集合内的内容，例如[^ab]不匹配a和b，例如<code>WHERE col LIKE &#39;[^ab]%&#39;</code>匹配不以ab开头的任意文本，通配符匹配速度很慢。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> col<span class="operator">=</span><span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>使用AS为字段或表取别名，使用CONCAT连接两个字段，使用TRIM去除首尾空格。</p>
</li>
<li><p>汇总函数AVG\MAX\MIN\COUNT\SUM。</p>
</li>
<li><p>分组</p>
<p>将相同数据值的行汇总为一行，可以使用汇总函数对同一分组的数据进行处理，例如求个数或求平均值等。</p>
<p>可以使用HAVING过滤分组，顺序是WHERE、GROUB BY、HAVING、ORDER BY，即先过滤行再分组，再过滤分组，再对结果进行排序。</p>
<p>除汇总字段外，SELECT中的字段必须在GROUP BY中出现，即只能汇总了的字段。</p>
<p>NULL行会单独成为一个分组。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col</span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>子查询</p>
<p>子查询只能返回一个字段的值</p>
</li>
<li><p>连接</p>
<p>使用JOIN连接多个表，条件语句使用ON。</p>
<ol>
<li><p>内连接</p>
<p>又称等值连接，使用INNER JOIN，等价于在普通查询中使用WHERE连接两个表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tableA <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableB <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">on</span> A.key <span class="operator">=</span> B.key;</span><br><span class="line"># 等价于</span><br><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tableA <span class="keyword">AS</span> A, tableB <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure></li>
<li><p>自然连接</p>
<p>将所有同名列通过等值连接连接起来，同名列可以有多个。</p>
<p>内连接提供连接的列，自然连接自动连接所有同名列。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tableA <span class="keyword">AS</span> A <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> tableB <span class="keyword">AS</span> B;</span><br></pre></td></tr></table></figure></li>
<li><p>外连接</p>
<p>保留没有关联的列，分为左外连接、右外连接和全外连接，分别是保留左边、右边和左右两边没有关联的列。</p>
<p>左外连接：<code>FROM A LEFT OUTER JOIN B ON A.key=B.key;</code></p>
<p>左外连接：<code>FROM A RIGHT OUTER JOIN B ON A.key=B.key;</code></p>
<p>左外连接：<code>FROM A OUTER JOIN B ON A.key=B.key;</code></p>
</li>
</ol>
</li>
<li><p>组合查询</p>
</li>
</ol>
<p>  使用UNION组合两个查询，要求两个查询使用相同的列，默认去除相同行，如要保留则使用UNION ALL，只能在最后使用一个ORDER BY。</p>
<ol start="15">
<li><p>视图</p>
<p>由查询定义的虚拟表，视图中的数据没有持久化到存储设备中，可以简化复杂的SQL操作，可以通过只给用户访问试图的权限，来保证数据的安全性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>存储过程</p>
<p>存储过程相当于一组SQL操作的批处理，可以将代码进行封装，保证安全性，可以复用代码，由于存储过程是预编译的，可以提高性能。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 过程中每条命令以分号结束，因此在命令行创建过程时需要自定义分隔符。</span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"># 使用<span class="keyword">in</span>、<span class="keyword">out</span>、<span class="keyword">inout</span>来表示参数</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure( <span class="keyword">out</span> ret <span class="type">int</span> )</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		# 使用<span class="keyword">declare</span>声明变量。</span><br><span class="line">		<span class="keyword">declare</span> y <span class="type">int</span>;</span><br><span class="line">		# 使用<span class="keyword">select</span> ... <span class="keyword">into</span> 对变量进行赋值</span><br><span class="line">		<span class="keyword">select</span> <span class="built_in">sum</span>(col1)</span><br><span class="line">		<span class="keyword">from</span> mytable</span><br><span class="line">		<span class="keyword">into</span> y;</span><br><span class="line">		<span class="keyword">select</span> y<span class="operator">*</span>y <span class="keyword">into</span> ret;</span><br><span class="line">	<span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter;</span><br><span class="line"># 调用存储过程</span><br><span class="line"><span class="keyword">call</span> myprocedure(<span class="variable">@ret</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@ret</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>触发器</p>
<p>触发器会在表执行INSERT、DELETE、UPDATE操作时执行，可以使用BEFORE或AFTER指定触发器在操作之前或是之后执行。触发器中不能调用存储过程。</p>
<p>INSERT触发器包含一张名为NEW的虚拟表，DELETE触发器包含一张OLD的虚拟表，是只读的。UPDATE触发器包含一张NEW和OLD的虚拟表，NEW表可以修改，OLD是只读的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> mytrigger AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> mytable</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">SELECT</span> NEW.col <span class="keyword">INTO</span> <span class="variable">@result</span>;</span><br><span class="line"></span><br><span class="line"># 获取结果</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@result</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>事务管理</p>
<p>MySQL中的事务默认是隐式提交，每执行一条语句就把这条语句当成一个事务进行提交。可以使用<code>START TRANSACTION</code>关闭隐式提交，显式开启一个事务。当执行<code>COMMIT</code>或<code>ROLLBACK</code>语句后，重新恢复隐式提交。可以使用<code>set autocommit=0</code>关闭当前会话的隐式自动提交。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 开始一个事务</span><br><span class="line"><span class="keyword">START</span> TRANSACTION</span><br><span class="line"># 设置保留点</span><br><span class="line"><span class="keyword">SAVEPOINT</span> point1</span><br><span class="line"># 回退到保留点</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> point1</span><br><span class="line"># 回退到事务开始处</span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br><span class="line"># 提交事务</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure></li>
<li><p>授权</p>
<p>MySQL的用户信息保存在mysql数据库的user表中，可以使用<code>SELECT * FROM mysql.user</code>查看所有用户。</p>
<ol>
<li><p>创建账户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>修改用户名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">USER</span> myuser <span class="keyword">TO</span> newuser</span><br></pre></td></tr></table></figure></li>
<li><p>删除账户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser</span><br></pre></td></tr></table></figure></li>
<li><p>查看权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> myuser</span><br></pre></td></tr></table></figure></li>
<li><p>授予权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.table <span class="keyword">to</span> myuser;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">on</span> mydatabase.<span class="operator">*</span> <span class="keyword">to</span> ‘usertname’@‘localhost’</span><br><span class="line"># 刷新权限</span><br><span class="line">FLUSH PRIVILEGES</span><br></pre></td></tr></table></figure></li>
<li><p>撤销权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> mydatabase.table <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" data-id="ckmn1ijie000jn8a8392fcx0c" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java虚拟机笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.529Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>jvm运行时数据区：</p>
<ul>
<li><p>程序计数器（Program Counter Register）：</p>
<p>线程私有，存储当前线程正在执行的字节码指令地址，如果执行的是本地（Native）方法，则计数器值为空（Undefined）。</p>
</li>
<li><p>虚拟机栈（VM Stack）：</p>
<p>线程私有，生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：线程的每个方法被执行时，jvm会同步创建栈内一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法执行完毕后栈帧出栈。</p>
<p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用（非对象本身）和返回地址（指向一条字节码指令地址）</p>
<p>两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p>
</li>
<li><p>本地方法栈（Native Method Stacks）：</p>
<p>线程私有，与虚拟机栈所发挥的作用非常相似，其区别在于虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
</li>
<li><p>堆Heap：</p>
<p>所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，</p>
<p>Java堆是垃圾收集器管理的内存区域，</p>
<p>Java堆既可以被实现成固定大小或可扩展的，当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再<br>扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p>
</li>
<li><p>方法区（Method Area）：</p>
<p>所有线程共享的一块内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</p>
<ul>
<li><p>运行时常量池（Runtime Constant Pool）：方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>运行时常量池具备动态性，Java语言并不要求常量一定只有编译期才能产生，因此池中除了预置入Class文件中常量池的内容，还可以加入运行期间产生的新的常量，例如String类的intern()方法。（“ab”.intern()首先检查字符串池中是否有”ab”这个字符串，如果存在则返回这个字符串的引用，否则就将这个字符串添加到字符串池中，然会返回这个字符串的引用。)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">s1 == s2 ; <span class="comment">// false, 两个变量的地址不相等</span></span><br><span class="line">s1.intern() == s2; <span class="comment">// true，s1.inter()会检查字符串池中是否含有&quot;ab&quot;字符串。由于之前定义的s2已经进入字符串池中，所以会得到相同的引用。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
</li>
</ul>
</li>
</ul>
<p>直接内存区（Direct Memory）：NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样避免了在Java堆和Native堆中来回复制数据，能在一些场景中显著提高性能。</p>
<h1 id="Annotation-Summary-of-深入理解Java虚拟机-JVM高级特性与最佳实践-第3版-xbo-MBP-pdf"><a href="#Annotation-Summary-of-深入理解Java虚拟机-JVM高级特性与最佳实践-第3版-xbo-MBP-pdf" class="headerlink" title="Annotation Summary of 深入理解Java虚拟机_JVM高级特性与最佳实践_第3版-xbo-MBP.pdf."></a>Annotation Summary of 深入理解Java虚拟机_JVM高级特性与最佳实践_第3版-xbo-MBP.pdf.</h1><h4 id="2-2-2-Java虚拟机栈"><a href="#2-2-2-Java虚拟机栈" class="headerlink" title="2.2.2 Java虚拟机栈"></a>2.2.2 Java虚拟机栈</h4><p> [page 73] 每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信 息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</p>
<h4 id="2-2-5-方法区"><a href="#2-2-5-方法区" class="headerlink" title="2.2.5 方法区"></a>2.2.5 方法区</h4><p> [page 77] 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据</p>
<h4 id="2-2-6-运行时常量池"><a href="#2-2-6-运行时常量池" class="headerlink" title="2.2.6 运行时常量池"></a>2.2.6 运行时常量池</h4><p> [page 78] 运行时常量池（Runtime Constant Pool）</p>
<p> [page 78] 常量池表（Constant Pool Table），用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</p>
<h4 id="2-3-2-对象的内存布局"><a href="#2-3-2-对象的内存布局" class="headerlink" title="2.3.2 对象的内存布局"></a>2.3.2 对象的内存布局</h4><p> [page 84] 对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例 数据（Instance Data）和对齐填充（Padding）</p>
<p> [page 84] 第一类是用于存储对象自身的运行时数据，如哈 希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，</p>
<p> [page 84] 对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针 来确定该对象是哪个类的实例。</p>
<h4 id="2-3-3-对象的访问定位"><a href="#2-3-3-对象的访问定位" class="headerlink" title="2.3.3 对象的访问定位"></a>2.3.3 对象的访问定位</h4><p> [page 86] 访问方式主要有使用句柄和直接指针</p>
<h4 id="2-4-1-Java堆溢出"><a href="#2-4-1-Java堆溢出" class="headerlink" title="2.4.1 Java堆溢出"></a>2.4.1 Java堆溢出</h4><p> [page 90] 参数-XX：+HeapDumpOnOutOf-MemoryError可以让虚拟机 [1] 在出现内存溢出异常的时候Dump出当前的内存堆转储快照</p>
<p> *Note [page 90] 内存泄漏是指：不再需要的对象没有被gc回收。<br>内存溢出是指：无法申请更多内存。</p>
<p> [page 90] 内存溢出（Memory Overflow）</p>
<p> [page 90] 内存泄漏（Memory Leak）</p>
<h4 id="2-4-3-方法区和运行时常量池溢出"><a href="#2-4-3-方法区和运行时常量池溢出" class="headerlink" title="2.4.3 方法区和运行时常量池溢出"></a>2.4.3 方法区和运行时常量池溢出</h4><p> [page 97] String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的 字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加 到常量池中，并且返回此String对象的引用</p>
<p> [page 97] 自JDK 7起，原本存放在永久代的字符串常量池被移至Java堆之中</p>
<h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p> [page 104] 内存动态分配与内存回收技术</p>
<h4 id="3-2-1-引用计数算法"><a href="#3-2-1-引用计数算法" class="headerlink" title="3.2.1 引用计数算法"></a>3.2.1 引用计数算法</h4><p> [page 106] 引用计数算法（Reference Counting）</p>
<h4 id="3-2-2-可达性分析算法"><a href="#3-2-2-可达性分析算法" class="headerlink" title="3.2.2 可达性分析算法"></a>3.2.2 可达性分析算法</h4><p> [page 108] 基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p> [page 108] 可达性分析（Reachability Analysis）算法来判定对象是否存活</p>
<p> [page 108] 固定可作为GC Roots的对象包括以下几种： ·在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。 ·在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 ·在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</p>
<p> [page 109] ·在本地方法栈中JNI（即通常所说的Native方法）引用的对象。 ·Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。 ·所有被同步锁（synchronized关键字）持有的对象。 ·反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p>
<h4 id="3-2-3-再谈引用"><a href="#3-2-3-再谈引用" class="headerlink" title="3.2.3 再谈引用"></a>3.2.3 再谈引用</h4><p> [page 110] 强引用（Strongly Re-ference）、软 引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）</p>
<p> [page 110] 只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象</p>
<p> [page 110] 只被软引用关联着的对象，在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常</p>
<p> [page 110] 被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。</p>
<p> [page 110] 一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知</p>
<h4 id="3-2-4-生存还是死亡？"><a href="#3-2-4-生存还是死亡？" class="headerlink" title="3.2.4 生存还是死亡？"></a>3.2.4 生存还是死亡？</h4><p> [page 111] 要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没 有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是 否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用 过，那么虚拟机将这两种情况都视为“没有必要执行”</p>
<p> [page 111] 收集器将对F-Queue中的对象进行第二次小规模的标记，如果对 象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集 合</p>
<p> [page 112] 任何一个对象的finalize()方法都只会被系统自动调用一次</p>
<h4 id="3-2-5-回收方法区"><a href="#3-2-5-回收方法区" class="headerlink" title="3.2.5 回收方法区"></a>3.2.5 回收方法区</h4><p> [page 113] 方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型</p>
<p> [page 113] 判定一个类型是否属于“不再被使用的类”的条件就 比较苛刻了。需要同时满足下面三个条件： ·该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 ·加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。 ·该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方 法。</p>
<h4 id="3-3-垃圾收集算法"><a href="#3-3-垃圾收集算法" class="headerlink" title="3.3 垃圾收集算法"></a>3.3 垃圾收集算法</h4><p> [page 114] 从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接 垃圾收集”</p>
<h4 id="3-3-1-分代收集理论"><a href="#3-3-1-分代收集理论" class="headerlink" title="3.3.1 分代收集理论"></a>3.3.1 分代收集理论</h4><p> [page 115] “分代收集”（Generational Collection）</p>
<p> [page 115] 两个分 代假说之上： 1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。 2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消 亡。</p>
<p> [page 115] 常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分 出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区 域之中存储</p>
<p> [page 115] 至少会把Java堆划分为新生代 （Young Generation）和老年代（Old Generation）两个区域</p>
<p> [page 115] 在新生代中，每次垃圾收集 时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放</p>
<p> [page 116] 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极 少数。</p>
<p> [page 116] 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集</p>
<p> [page 116] 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集</p>
<p> [page 116] 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集</p>
<p> [page 116] 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集</p>
<p> [page 116] 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集</p>
<h4 id="3-3-2-标记-清除算法"><a href="#3-3-2-标记-清除算法" class="headerlink" title="3.3.2 标记-清除算法"></a>3.3.2 标记-清除算法</h4><p> [page 117] “标记-清除”（Mark-Sweep）算法</p>
<p> [page 117] 算法分为“标记”和“清除”两个阶段：首先标记出所有需要回 收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回 收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程</p>
<p> [page 117] 执行效率不稳定</p>
<p> [page 117] 内存空间的碎片化问题</p>
<h4 id="3-3-3-标记-复制算法"><a href="#3-3-3-标记-复制算法" class="headerlink" title="3.3.3 标记-复制算法"></a>3.3.3 标记-复制算法</h4><p> [page 118] 标记-复制算法</p>
<p> [page 118] 将可用 内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p> [page 118] “Appel式回收”。HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设 计新生代的内存布局</p>
<p> [page 118] 把新生代分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍 然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空 更多书籍请关注我爱电子书：<a target="_blank" rel="noopener" href="http://www.52doc.com/">www.52doc.com</a></p>
<p> [page 118] Appel式回收</p>
<p> [page 119] 间。</p>
<p> [page 119] 分配担保（Handle Promotion）</p>
<p> [page 119] 如果另外一块 Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直 接进入老年代</p>
<h4 id="3-3-4-标记-整理算法"><a href="#3-3-4-标记-整理算法" class="headerlink" title="3.3.4 标记-整理算法"></a>3.3.4 标记-整理算法</h4><p> [page 120] “标记-整 理”（Mark-Compact）算法</p>
<p> [page 120] 让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内 存</p>
<p> [page 120] 弥散于堆中的存活对象导致的 空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决</p>
<p> [page 121] 内存分配和访问相比垃圾收集频率要 高得多</p>
<p> [page 121] 关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的</p>
<p> [page 121] 关注延迟的CMS收集器则是基于标记-清除算法的</p>
<p> [page 121] 虚 拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经 大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间</p>
<h4 id="3-4-1-根节点枚举"><a href="#3-4-1-根节点枚举" class="headerlink" title="3.4.1 根节点枚举"></a>3.4.1 根节点枚举</h4><p> [page 123] 固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如 栈帧中的本地变量表）中</p>
<p> [page 123] 所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</p>
<p> [page 123] 根节点枚举始终还 是必须在一个能保障一致性的快照中才得以进行</p>
<p> [page 123] 一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译（见第11章）过程中，也 会在特定的位置记录下栈里和寄存器里哪些位置是引用</p>
<p> [page 123] OopMap</p>
<p> [page 123] 个普通对象指针（Ordinary Object Pointer，OOP）</p>
<h4 id="3-4-2-安全点"><a href="#3-4-2-安全点" class="headerlink" title="3.4.2 安全点"></a>3.4.2 安全点</h4><p> [page 124] 安全点（Safepoint）</p>
<p> [page 124] 强制要求必须执行到达安全点后才 能够暂停</p>
<p> [page 124] 安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准 进行选定的</p>
<p> [page 124] 抢先式中断 （Preemptive Suspension）和主动式中断（Voluntary Suspension）</p>
<h4 id="3-4-3-安全区域"><a href="#3-4-3-安全区域" class="headerlink" title="3.4.3 安全区域"></a>3.4.3 安全区域</h4><p> [page 126] 安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任 意地方开始垃圾收集都是安全的</p>
<h4 id="3-4-4-记忆集与卡表"><a href="#3-4-4-记忆集与卡表" class="headerlink" title="3.4.4 记忆集与卡表"></a>3.4.4 记忆集与卡表</h4><p> [page 127] 记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</p>
<p> [page 127] 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针</p>
<p> [page 127] “卡表”（Card Table） </p>
<p> [page 128] 字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个 内存块被称作“卡页”（Card Page）</p>
<p> [page 128] 一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代 指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0</p>
<h4 id="3-4-5-写屏障"><a href="#3-4-5-写屏障" class="headerlink" title="3.4.5 写屏障"></a>3.4.5 写屏障</h4><p> [page 130] 在HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态</p>
<p> [page 130] 写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切 面[2]，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的 前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值 后的则叫作写后屏障（Post-Write Barrier）</p>
<p> [page 130] “伪共享”（False Sharing）</p>
<p> [page 130] 现代中央处理器的缓存系统中是以缓存行（Cache Line） 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响（写回、无效化或者同步）而导致性能降低</p>
<h4 id="3-4-6-并发的可达性分析"><a href="#3-4-6-并发的可达性分析" class="headerlink" title="3.4.6 并发的可达性分析"></a>3.4.6 并发的可达性分析</h4><p> [page 134] 原始快照（Snapshot At The Beginning， SATB）</p>
<p> [page 134] 增量更新（Incremental Update）</p>
<h4 id="3-5-1-Serial收集器"><a href="#3-5-1-Serial收集器" class="headerlink" title="3.5.1 Serial收集器"></a>3.5.1 Serial收集器</h4><p> [page 138] Serial收集器</p>
<p> [page 138] 它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束</p>
<p> [page 138] HotSpot虚拟机运行在客户端模式下的默认新生 代收集器</p>
<p> [page 138] 简单而高效</p>
<p> [page 138] 于没有线程交互的开销</p>
<p> [page 138] ，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的 内存，桌面应用甚少超过这个容量），垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一 百多毫秒以内</p>
<h4 id="3-5-2-ParNew收集器"><a href="#3-5-2-ParNew收集器" class="headerlink" title="3.5.2 ParNew收集器"></a>3.5.2 ParNew收集器</h4><p> [page 140] ParNew收集器实质上是Serial收集器的多线程并行版本</p>
<h4 id="3-5-3-Parallel-Scavenge收集器"><a href="#3-5-3-Parallel-Scavenge收集器" class="headerlink" title="3.5.3 Parallel Scavenge收集器"></a>3.5.3 Parallel Scavenge收集器</h4><p> [page 142] Parallel Scavenge收集器</p>
<p> [page 142] CMS等收集器的关注点是尽可能 地缩短垃圾收集时用户线程的停顿时间</p>
<p> [page 142] Parallel Scavenge收集器的目标则是达到一个可控制的吞吐 量（Throughput）</p>
<p> [page 142] 吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值</p>
<p> [page 142] 。停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良 好的响应速度能提升用户体验</p>
<p> [page 142] 高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算 任务，主要适合在后台运算而不需要太多交互的分析任务</p>
<p> [page 142] 垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的</p>
<p> [page 142] 由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。</p>
<p> [page 142] 垃圾收集的自适应的调节策略（GC Ergonomics）</p>
<h4 id="3-5-4-Serial-Old收集器"><a href="#3-5-4-Serial-Old收集器" class="headerlink" title="3.5.4 Serial Old收集器"></a>3.5.4 Serial Old收集器</h4><p> [page 144] Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法</p>
<h4 id="3-5-5-Parallel-Old收集器"><a href="#3-5-5-Parallel-Old收集器" class="headerlink" title="3.5.5 Parallel Old收集器"></a>3.5.5 Parallel Old收集器</h4><p> [page 145] Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实 现</p>
<p> [page 145] 在注重 吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组 合</p>
<h4 id="3-5-6-CMS收集器"><a href="#3-5-6-CMS收集器" class="headerlink" title="3.5.6 CMS收集器"></a>3.5.6 CMS收集器</h4><p> [page 146] CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器</p>
<p> [page 146] 基于标记-清除算法</p>
<p> [page 146] 1）初始标记（CMS initial mark） 2）并发标记（CMS concurrent mark） 3）重新标记（CMS remark） 4）并发清除（CMS concurrent sweep）</p>
<p> [page 146] 初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对 象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而重 新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的 标记记录（详见3.4.6节中关于增量更新的讲解），这个阶段的停顿时间通常会比初始标记阶段稍长一 些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的 对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p>
<p> [page 146] 并发低停顿收集器</p>
<p> [page 147] CMS收集器对处理器资源非常敏感</p>
<p> [page 147] 由于CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生</p>
<p> [page 147] CMS运行期间预留的内存无法满 足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不 得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集</p>
<p> [page 147] 收集结束时会有大量空间碎片产生</p>
<h4 id="3-5-7-Garbage-First收集器"><a href="#3-5-7-Garbage-First收集器" class="headerlink" title="3.5.7 Garbage First收集器"></a>3.5.7 Garbage First收集器</h4><p> [page 148] 面向局部收集的设计思路</p>
<p> [page 148] 基于Region的内存布局形式</p>
<p> [page 148] 主要面向服务端应用</p>
<p> [page 148] “停顿时间模型”（Pause Prediction Model）的收集器，停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段 内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标</p>
<p> [page 148] 整个老 年代（Major GC）</p>
<p> [page 148] 整个新生代（Minor GC）</p>
<p> [page 148] 面向堆内存任 何部分来组成回收集（Collection Set，一般简称CSet）进行回收</p>
<p> [page 148] 整个Java堆（Full GC）</p>
<p> [page 148] Mixed GC模式</p>
<p> [page 148] 基于Region的堆内存布局</p>
<p> [page 148] G1不再坚持固定大小以及固定数量的 分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以</p>
<p> [page 149] 根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理</p>
<p> [page 149] Humongous区域，专门用来存储大对象</p>
<p> [page 149] G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区 域（不需要连续）的动态集合</p>
<p> [page 149] G1收集器去跟踪各个Region里面的垃 圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一 个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默 认值是200毫秒），优先处理回收价值收益最大的那些Region</p>
<p> [page 149] 使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获 取尽可能高的收集效率</p>
<p> [page 150] 跨Region引用对象</p>
<p> [page 150] 使用记忆集避免全堆作为GC Roots扫描</p>
<p> [page 151] 原始快照（SATB）算法</p>
<p> [page 151] 两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过 程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在 这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围</p>
<p> [page 151] 衰减均值（Decaying Average）</p>
<p> [page 151] 初始标记（Initial Marking）</p>
<p> [page 151] 并发标记（Concurrent Marking）</p>
<p> [page 151] 最终标记（Final Marking）</p>
<p> [page 151] 筛选回收（Live Data Counting and Evacuation）</p>
<p> [page 152] 把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的</p>
<p> [page 152] 最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率 （Allocation Rate），而不追求一次把整个Java堆全部清理干净</p>
<p> [page 152] G1运作期间不会产生内存 空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大 对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集</p>
<p> [page 153] G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载 （Overload）都要比CMS要高</p>
<p> [page 153] 在小内存应用上CMS的表现大概率仍然要会优于G1</p>
<p> [page 153] 当CMS发生Old GC时（所有收集器中只有CMS有针对老年代的Old GC），要把整个新生 代作为GC Roots来进行扫描</p>
<h4 id="3-6-低延迟垃圾收集器"><a href="#3-6-低延迟垃圾收集器" class="headerlink" title="3.6 低延迟垃圾收集器"></a>3.6 低延迟垃圾收集器</h4><p> [page 154] 衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟 （Latency）</p>
<p> [page 154] 内存的扩 大，对延迟反而会带来负面的效果</p>
<p> [page 154] CMS和G1分别使用增量更新和原始快照（见3.4.6节）技术，实现了标记阶段的并发，不会因管理的堆 内存变大，要标记的对象变多而导致停顿时间随之增长</p>
<p> [page 154] CMS使用标记-清除算法，虽然避免了整理阶段收集器带来的停顿，但是清除算法不论如何优 化改进，在设计原理上避免不了空间碎片的产生</p>
<h4 id="3-6-1-Shenandoah收集器"><a href="#3-6-1-Shenandoah收集器" class="headerlink" title="3.6.1 Shenandoah收集器"></a>3.6.1 Shenandoah收集器</h4><p> [page 156] 它成为OpenJDK 12的正式特性之一</p>
<p> [page 156] 支持并发的整 理算法</p>
<p> [page 156] 默认不使用分代收集</p>
<p> [page 156] 用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降 低了伪共享问题（见3.4.4节）的发生概率</p>
<p> [page 157] 初始标记（Initial Marking）</p>
<p> [page 157] 并发标记（Concurrent Marking）</p>
<p> [page 157] 最终标记（Final Marking）</p>
<p> [page 157] 并发清理（Concurrent Cleanup）</p>
<p> [page 157] 并发回收（Concurrent Evacuation）</p>
<p> [page 157] Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之 中</p>
<p> [page 157] 在移动对象的同时，用户线程仍然可能不停对被移动的对象 进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对</p>
<p> [page 158] 象的地址，这是很难一瞬间全部改变过来的。对于并发回收阶段遇到的这些困难，Shenandoah将会通 过读屏障和被称为“Brooks Pointers”的转发指针来解决</p>
<p> [page 158] ·初始引用更新（Initial Update Reference）</p>
<p> [page 158] 并发引用更新（Concurrent Update Reference）</p>
<p> [page 158] 按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为 新值即可</p>
<p> [page 158] 最终引用更新（Final Update Reference）</p>
<p> [page 158] 并发清理（Concurrent Cleanup）</p>
<p> [page 158] 并发标记、并发回收、并发引用更新</p>
<p> [page 159] 使用转发 指针（Forwarding Pointer，也常被称为Indirection Pointer）来实现对象移动与用户程序并发</p>
<p> [page 160] Brooks形式的转发指针在设计上决定了它是必然会出现多线程竞争问题</p>
<p> [page 161] Shenandoah收集器是通过比较并交换（Compare And Swap，CAS）操作 确性的。 来保证并发时对象的访问正</p>
<p> [page 161] 为了实现Brooks Pointer，Shenandoah在读、写屏障中都加入了额外的转发处理</p>
<p> [page 161] 代码里对象读取的出现频率要比对象写入的频率高出很多，读 屏障数量自然也要比写屏障多得多</p>
<p> [page 161] “引用访问屏障”是指内存屏障只拦 截对象中数据类型为引用类型的读写操作，而不去管原生数据类型等其他非引用字段的读写</p>
<p> [page 161] 基于引用访问屏障（Load Reference Barrier）</p>
<h4 id="3-6-2-ZGC收集器"><a href="#3-6-2-ZGC收集器" class="headerlink" title="3.6.2 ZGC收集器"></a>3.6.2 ZGC收集器</h4><p> [page 163] 在 JDK 11中新加入的具有实验性质 [1] 的低延迟垃圾收集器</p>
<p> [page 163] Z Garbage Collector</p>
<p> [page 163] 在尽可能对吞吐量影响不太大的前提下 [2] ，实现 在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</p>
<p> [page 163] ZGC收集器是一款基于Region内存布局的，（暂时） 不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低 延迟为首要目标的一款垃圾收集器。</p>
<p> [page 163] 动态创建和销毁，以及动态的区域容量大小</p>
<p> [page 164] 染色指针技术（Colored Pointer</p>
<p> [page 164] 把标记直接记录在 对象头上（如Serial收集器）</p>
<p> [page 164] 把标记记录在与对象相互独立的数据结构上（如G1、Shenandoah使 用了一种相当于堆内存的1/64大小的，称为BitMap的结构来记录标记信息）</p>
<p> [page 164] ZGC的染色指针是最 直接的、最纯粹的，它直接把标记信息记在引用对象的指针上</p>
<p> [page 165] 基于需求 （用不到那么多内存）、性能（地址越宽在做地址转换时需要的页表级数越多）和成本（消耗更多晶 体管）的考虑，在AMD64架构[4]中只支持到52位（4PB）的地址总线和48位（256TB）的虚拟地址空 间</p>
<p> [page 165] 在64位系统中，理论可以访问的内存高达16EB（2的64次幂）字节</p>
<p> [page 165] Linux下64位指针的高18位不能用来寻址</p>
<p> [page 165] 将其高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对 象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问 到</p>
<p> [page 165] ZGC能够管理的内存不可以超过4TB</p>
<p> [page 165] 染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用 掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理</p>
<p> [page 165] 染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量</p>
<p> [page 166] 染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据</p>
<p> [page 166] 虚拟内存映射 技术</p>
<p> [page 166] 不同层次的虚拟内存到物理内存的转换关系可以在硬件层面、操作系统层面或者软件进程层面实 现</p>
<p> [page 166] Linux/x86-64平台上的ZGC使用了多重映射（Multi-Mapping）将多个不同的虚拟内存地址映射到同一 个物理内存地址上</p>
<p> [page 167] 并发标记（Concurrent Mark）</p>
<p> [page 167] 与G1、Shenandoah不同的是，ZGC 的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志 位</p>
<p> [page 167] 并发预备重分配（Concurrent Prepare for Relocate）</p>
<p> [page 168] ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的 维护成本</p>
<p> [page 168] 标记过程是针对 全堆的</p>
<p> [page 168] 把重分 配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系</p>
<p> [page 168] 并发重分配（Concurrent Relocate）</p>
<p> [page 168] 得益于染色指针的支持，ZGC收集器能仅从引用上就明 确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次 访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象 上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（SelfHealing）能力</p>
<p> [page 168] 由于染 色指针的存在，一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于 新对象的分配（但是转发表还得留着不能释放掉），哪怕堆中还有很多指向这个对象的未更新指针也 没有关系，这些旧指针一旦被使用，它们都是可以自愈的</p>
<p> [page 168] 修正整个堆中指向重分配集中旧对象的所 有引用</p>
<p> [page 168] 并发重映射（Concurrent Remap）</p>
<p> [page 168] 并发重映射并不 是一个必须要“迫切”去完成的任务</p>
<p> [page 168] 即使是旧引用，它也是可以自愈的</p>
<p> [page 168] ZGC很巧妙地把并发重映射 阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所 [9] 有对象的，这样合并就节省了一次遍历对象图 对象关系的转发表就可以释放掉了。 的开销。一旦所有指针都被修正之后，原来记录新旧</p>
<p> [page 168] ZGC就完全没有使 用记忆集，它甚至连分代都没有</p>
<p> [page 168] 限制了它能承受的对象分配速率不会太高</p>
<p> [page 169] 若要从根本上提升ZGC能够应对 的对象分配速率，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这 个区域进行更频繁、更快的收集</p>
<p> [page 169] NUMA（NonUniform Memory Access，非统一内存访问架构）</p>
<p> [page 169] 支持“NUMA-Aware”的内存分配</p>
<p> [page 169] 原本在北 桥芯片中的内存控制器也被集成到了处理器内核中，这样每个处理器核心所在的裸晶（DIE）[12]都有 属于自己内存管理器所管理的内存，如果要访问被其他处理器核心管理的内存，就必须通过InterConnect通道来完成，这要比访问处理器的本地内存慢得多</p>
<p> [page 169] 在NUMA架构下，ZGC收集器会优先尝 试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问</p>
<p> [page 169] Parallel Scavenge支持NUMA内存分配</p>
<h4 id="3-7-1-Epsilon收集器"><a href="#3-7-1-Epsilon收集器" class="headerlink" title="3.7.1 Epsilon收集器"></a>3.7.1 Epsilon收集器</h4><p> [page 173] Epsilon收集器</p>
<p> [page 173] A No-Op Garbage Collector</p>
<p> [page 173] 一个垃圾收集器除了垃圾收集这个本职工作之外，它还要负 责堆的管理与布局、对象的分配、与解释器的协作、与编译器的协作、与监控子系统协作等职责</p>
<p> [page 173] 自动内存管理子系统</p>
<p> [page 173] 至少堆的管理和对象的分配</p>
<p> [page 173] 只要运行数分钟甚至数秒， 只要Java虚拟机能正确分配内存，在堆耗尽之前就会退出，那显然运行负载极小、没有任何回收行为 的Epsilon便是很恰当的选择</p>
<h4 id="3-7-2-收集器的权衡"><a href="#3-7-2-收集器的权衡" class="headerlink" title="3.7.2 收集器的权衡"></a>3.7.2 收集器的权衡</h4><p> [page 174] 应用程序的主要关注点</p>
<p> [page 174] 吞吐量</p>
<p> [page 174] 延迟</p>
<p> [page 174] 垃圾收集的内存占用</p>
<p> [page 174] 运行应用的基础设施</p>
<p> [page 174] 硬件规格</p>
<p> [page 174] 处理器的数量多少</p>
<p> [page 174] 分配内存的大小</p>
<p> [page 174] JDK的发行商是什么？版本号是多少？</p>
<h4 id="3-8-实战：内存分配与回收策略"><a href="#3-8-实战：内存分配与回收策略" class="headerlink" title="3.8 实战：内存分配与回收策略"></a>3.8 实战：内存分配与回收策略</h4><p> [page 183] Serial加Serial Old客户端默认收集器组合</p>
<h4 id="3-8-1-对象优先在Eden分配"><a href="#3-8-1-对象优先在Eden分配" class="headerlink" title="3.8.1 对象优先在Eden分配"></a>3.8.1 对象优先在Eden分配</h4><p> [page 184] 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起 一次Minor GC</p>
<p> [page 184] -XX：+PrintGCDetails这个收集器日志参数</p>
<p> [page 184] 通过分配担保机制提前转移到老年代去</p>
<h4 id="3-8-2-大对象直接进入老年代"><a href="#3-8-2-大对象直接进入老年代" class="headerlink" title="3.8.2 大对象直接进入老年代"></a>3.8.2 大对象直接进入老年代</h4><p> [page 186] 大对象直接进入老年代</p>
<p> [page 186] 大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者 元素数量很庞大的数组</p>
<p> [page 186] 在分配空间时，它容易 导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复 制对象时，大对象就意味着高额的内存复制开销</p>
<h4 id="3-8-3-长期存活的对象将进入老年代"><a href="#3-8-3-长期存活的对象将进入老年代" class="headerlink" title="3.8.3 长期存活的对象将进入老年代"></a>3.8.3 长期存活的对象将进入老年代</h4><p> [page 187] 虚拟机给每个对象定义了一个对 象年龄（Age）计数器，存储在对象头中</p>
<p> [page 187] 对象通常在Eden区里诞生，如果经过第一次 Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象 年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程 度（默认为15），就会被晋升到老年代中</p>
<p> [page 187] 对象晋升老年代的年龄阈值，可以通过参数-XX： MaxTenuringThreshold设置。</p>
<h4 id="3-8-4-动态对象年龄判定"><a href="#3-8-4-动态对象年龄判定" class="headerlink" title="3.8.4 动态对象年龄判定"></a>3.8.4 动态对象年龄判定</h4><p> [page 189] HotSpot虚拟机并不是永远要求对象的年龄必须达到XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于 Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</p>
<h4 id="3-8-5-空间分配担保"><a href="#3-8-5-空间分配担保" class="headerlink" title="3.8.5 空间分配担保"></a>3.8.5 空间分配担保</h4><p> [page 191] 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行Full GC</p>
<h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p> [page 194] 异常堆栈、虚拟机运行日志、垃圾收集器日志、线程快照 （threaddump/javacore文件）、堆转储快照（heapdump/hprof文件）</p>
<h4 id="4-2-1-jps：虚拟机进程状况工具"><a href="#4-2-1-jps：虚拟机进程状况工具" class="headerlink" title="4.2.1 jps：虚拟机进程状况工具"></a>4.2.1 jps：虚拟机进程状况工具</h4><p> [page 198] jps（JVM Process Status Tool）</p>
<p> [page 198] 列出正在运行的虚拟机进 程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一 ID（LVMID，Local Virtual Machine Identifier）</p>
<h4 id="4-2-2-jstat：虚拟机统计信息监视工具"><a href="#4-2-2-jstat：虚拟机统计信息监视工具" class="headerlink" title="4.2.2 jstat：虚拟机统计信息监视工具"></a>4.2.2 jstat：虚拟机统计信息监视工具</h4><p> [page 199] jstat（JVM Statistics Monitoring Tool）</p>
<p> [page 199] 用于监视虚拟机各种运行状态信息</p>
<p> [page 199] 显示本地或者远程 [1] 虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据</p>
<h4 id="4-2-3-jinfo：Java配置信息工具"><a href="#4-2-3-jinfo：Java配置信息工具" class="headerlink" title="4.2.3 jinfo：Java配置信息工具"></a>4.2.3 jinfo：Java配置信息工具</h4><p> [page 201] jinfo（Configuration Info for Java）</p>
<p> [page 201] 实时查看和调整虚拟机各项参数</p>
<h4 id="4-2-4-jmap：Java内存映像工具"><a href="#4-2-4-jmap：Java内存映像工具" class="headerlink" title="4.2.4 jmap：Java内存映像工具"></a>4.2.4 jmap：Java内存映像工具</h4><p> [page 202] jmap（Memory Map for Java）</p>
<p> [page 202] 用于生成堆转储快照（一般称为heapdump或dump文件）</p>
<p> [page 202] 查询finalize执行队列、Java堆和方法区的 详细信息，如空间使用率、当前用的是哪种收集器</p>
<h4 id="4-2-6-jstack：Java堆栈跟踪工具"><a href="#4-2-6-jstack：Java堆栈跟踪工具" class="headerlink" title="4.2.6 jstack：Java堆栈跟踪工具"></a>4.2.6 jstack：Java堆栈跟踪工具</h4><p> [page 206] 用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者 javacore文件）</p>
<p> [page 206] jstack（Stack Trace for Java）</p>
<p> [page 206] 线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合</p>
<p> [page 206] 目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂 起等</p>
<h4 id="4-3-1-JHSDB：基于服务性代理的调试工具"><a href="#4-3-1-JHSDB：基于服务性代理的调试工具" class="headerlink" title="4.3.1 JHSDB：基于服务性代理的调试工具"></a>4.3.1 JHSDB：基于服务性代理的调试工具</h4><p> [page 214] JHSDB：基于服务性代理的调试工具</p>
<p> [page 214] JCMD</p>
<p> [page 214] JHSDB</p>
<p> [page 214] 服务性代理以HotSpot内部的数据结构为参照物进行设计，把这些C++的数据抽象出Java模 型对象，相当于HotSpot的C++代码的一个镜像。通过服务性代理的API，可以在一个独立的Java虚拟 机的进程里分析其他HotSpot虚拟机的内部数据，或者从HotSpot虚拟机进程内存中dump出来的转储快 照里还原出它的运行状态细节。</p>
<p> [page 218] HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对 [3] 象存放在一起，存储于Java堆之中</p>
<h4 id="4-3-2-JConsole：Java监视与管理控制台"><a href="#4-3-2-JConsole：Java监视与管理控制台" class="headerlink" title="4.3.2 JConsole：Java监视与管理控制台"></a>4.3.2 JConsole：Java监视与管理控制台</h4><p> [page 221] 于JMX（Java Manage-ment Extensions）</p>
<p> [page 221] JConsole（Java Monitoring and Management Console）</p>
<p> [page 221] 通过JMX的MBean（Managed Bean）对系统进 行信息收集和参数动态调整</p>
<p> [page 222] “概述”“内存”“线程”“类”“VM摘要”“MBean”</p>
<p> [page 224] Eden 与Survivor空间比例的默认值为8∶1</p>
<h4 id="4-3-3-VisualVM：多合-故障处理工具"><a href="#4-3-3-VisualVM：多合-故障处理工具" class="headerlink" title="4.3.3 VisualVM：多合-故障处理工具"></a>4.3.3 VisualVM：多合-故障处理工具</h4><p> [page 229] VisualVM：多合-故障处理工具</p>
<h4 id="4-3-4-Java-Mission-Control：可持续在线的监控工具"><a href="#4-3-4-Java-Mission-Control：可持续在线的监控工具" class="headerlink" title="4.3.4 Java Mission Control：可持续在线的监控工具"></a>4.3.4 Java Mission Control：可持续在线的监控工具</h4><p> [page 239] Java Mission Control：可持续在线的监控工具</p>
<p> [page 239] 用 于监控Java虚拟机的JMC（Java Mission Control）</p>
<p> [page 239] 用于持续收集数据的JFR（Java Flight Recorder）飞行记录仪</p>
<p> [page 239] JFR是一套内建在HotSpot虚拟机里面的监控和基于事件的信息搜集框架</p>
<p> [page 239] JMC与虚拟机之间同样采取JMX协议进行通信</p>
<p> [page 244] 飞行记录报告里包含以下几类信息： ·一般信息：关于虚拟机、操作系统和记录的一般信息。 ·内存：关于内存管理和垃圾收集的信息。 ·代码：关于方法、异常错误、编译和类加载的信息。 ·线程：关于应用程序中线程和锁的信息。 ·I/O：关于文件和套接字输入、输出的信息。 ·系统：关于正在运行Java虚拟机的系统、进程和环境变量的信息。 ·事件：关于记录中的事件类型的信息，可以根据线程或堆栈跟踪，按照日志或图形的格式查看。</p>
<h4 id="5-2-1-大内存硬件上的程序部署策略"><a href="#5-2-1-大内存硬件上的程序部署策略" class="headerlink" title="5.2.1 大内存硬件上的程序部署策略"></a>5.2.1 大内存硬件上的程序部署策略</h4><p> [page 256] 单体应用在较大内存的硬件上主要的 部署方式有两种： 1）通过一个单独的Java虚拟机实例来管理大量的Java堆内存。 2）同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源。</p>
<p> [page 256] 控制Full GC频率的关键是老年代的相对稳定，这主要取决于应用中绝大多数对象能否符合“朝生 夕灭”的原则，即大多数对象的生存时间不应当太长，尤其是不能有成批量的、长生存时间的大对象产 生，这样才能保障老年代空间的稳定。</p>
<p> [page 257] ·回收大块堆内存而导致的长时间停顿</p>
<p> [page 257] 数据类 型对齐补白</p>
<p> [page 257] 相同的程序在64位虚拟机中消耗的内存一般比32位虚拟机要大</p>
<p> [page 257] 指针膨胀</p>
<p> [page 257] 压缩指针</p>
<p> [page 257] 在一台物理机器上启动多个应用服务器进程，为每个服 务器进程分配不同端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求</p>
<h4 id="5-2-3-堆外内存导致的溢出错误"><a href="#5-2-3-堆外内存导致的溢出错误" class="headerlink" title="5.2.3 堆外内存导致的溢出错误"></a>5.2.3 堆外内存导致的溢出错误</h4><p> [page 261] Java堆</p>
<p> [page 261] 方法区</p>
<p> [page 261] 直接内存</p>
<p> [page 261] StackOverflowError（如果线程请求的栈深度大 于虚拟机所允许的深度）</p>
<p> [page 261] 线程堆栈</p>
<p> [page 261] OutOfMemoryError（如果Java虚拟机栈容量可以动态扩展，当栈扩展时 无法申请到足够的内存）</p>
<p> [page 262] Socket缓存区</p>
<p> [page 262] 每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存</p>
<p> [page 262] 虚拟机和垃圾收集器</p>
<h4 id="5-2-7-由Windows虚拟内存导致的长时间停顿"><a href="#5-2-7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="5.2.7 由Windows虚拟内存导致的长时间停顿"></a>5.2.7 由Windows虚拟内存导致的长时间停顿</h4><p> [page 266] 工作内存被 自动交换到磁盘的页面文件之中了，这样发生垃圾收集时就有可能因为恢复页面文件的操作导致不正 常的垃圾收集停顿</p>
<h4 id="5-2-8-由安全点导致长时间停顿"><a href="#5-2-8-由安全点导致长时间停顿" class="headerlink" title="5.2.8 由安全点导致长时间停顿"></a>5.2.8 由安全点导致长时间停顿</h4><p> [page 267] 处理器时间代表的是线 程占用处理器一个核心的耗时计数，而时钟时间就是现实世界中的时间计数。如果是单核单线程的场 景下，这两者可以认为是等价的，但如果是多核环境下，同一个时钟时间内有多少处理器核心正在工 作，就会有多少倍的处理器时间被消耗和记录下来。</p>
<p> [page 268] 安 全点是以“是否具有让程序长时间执行的特征”为原则进行选定的，所以方法调用、循环跳转、异常跳 转这些位置都可能会设置有安全点</p>
<p> [page 268] 认为循环次数较少的话，执行时间应该也不会太长，所以使用int类型或范围更小 的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为可数循环（Counted Loop），相对应地，使用long或者范围更大的数据类型作为索引值的循环就被称为不可数循环 （Uncounted Loop），将会被放置安全点。</p>
<h4 id="5-3-3-编译时间和类加载时间的优化"><a href="#5-3-3-编译时间和类加载时间的优化" class="headerlink" title="5.3.3 编译时间和类加载时间的优化"></a>5.3.3 编译时间和类加载时间的优化</h4><p> [page 281] 类加载时间</p>
<p> [page 281] 编译时间</p>
<p> [page 281] 垃圾收集时间</p>
<p> [page 281] 如果一段Java方法被调用次数到达一定程度，就会被判定为热代码交给即时编译器即 时编译为本地代码，提高运行速度（这就是HotSpot虚拟机名字的来由）</p>
<h4 id="6-2-无关性的基石"><a href="#6-2-无关性的基石" class="headerlink" title="6.2 无关性的基石"></a>6.2 无关性的基石</h4><p> [page 295] 运行在各 种不同硬件平台和操作系统上的Java虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节 码，从而实现了程序的“一次编写，到处运行”。</p>
<p> [page 295] 字节码（Byte Code）</p>
<p> [page 295] Java虚拟机不与包括Java语言在内的任何 程序语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机 指令集、符号表以及若干其他辅助信息</p>
<p> [page 295] 实现语言无关性的基础仍然是虚拟机和字节码存储格式</p>
<p> [page 295] 图灵完备的字节码格式，保证了任意一门功能性语言 都可以表示为一个能被Java虚拟机所接受的有效的Class文件</p>
<h4 id="6-3-Class类文件的结构"><a href="#6-3-Class类文件的结构" class="headerlink" title="6.3 Class类文件的结构"></a>6.3 Class类文件的结构</h4><p> [page 297] 类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）</p>
<p> [page 297] 任何一个Class文件都对应着唯一的一个类或接口的定义信息</p>
<p> [page 297] Class文件是一组以8个字节为基础单位的二进制流</p>
<p> [page 297] 中间没有添加任何分隔符</p>
<p> [page 297] 高位在前</p>
<p> [page 297] 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个 字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串 值</p>
<p> [page 297] 表是由多个无符号数或者其他表作为数据项构成的复合数据类型</p>
<p> [page 299] 描述同一类型但数量不定的多个数据时，经常会使用一个前置的 容量计数器加若干个连续的数据项的形式</p>
<p> [page 299] 称这一系列连续的某一类型的数据为某一类型的“集 合”</p>
<p> [page 299] “Big-Endian”，具体顺序是指按高位字节在地址最低位，最低字节在地址最高位来存 储数据，它是SPARC、PowerPC等处理器的默认多字节存储顺序，而x86等处理器则是使用了相反 的“Little-Endian”顺序来存储数据</p>
<h4 id="6-3-1-魔数与Class文件的版本"><a href="#6-3-1-魔数与Class文件的版本" class="headerlink" title="6.3.1 魔数与Class文件的版本"></a>6.3.1 魔数与Class文件的版本</h4><p> [page 300] 魔数与Class文件的版本</p>
<p> [page 300] 确定这个文件是否为 一个能被虚拟机接受的Class文件</p>
<p> [page 300] 魔数（Magic Number）</p>
<p> [page 300] 使用魔数而不是扩展名来进行 识别主要是基于安全考虑，因为文件扩展名可以随意改动</p>
<p> [page 300] 0xCAFEBABE</p>
<h4 id="6-3-2-常量池"><a href="#6-3-2-常量池" class="headerlink" title="6.3.2 常量池"></a>6.3.2 常量池</h4><p> [page 303] 常量池</p>
<p> [page 303] 容量计数是从1而不是0开始</p>
<p> [page 303] 如果后面某些指向常量池的索引值的数据在特定情况下 需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示</p>
<p> [page 303] 字面量比 较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等</p>
<p> [page 303] 常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）</p>
<p> [page 303] 符号引用则属于编译 原理方面的概念，主要包括下面几类常量： ·被模块导出或者开放的包（Package） ·类和接口的全限定名（Fully Qualified Name） ·字段的名称和描述符（Descriptor） ·方法的名称和描述符 ·方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic） ·动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</p>
<p> [page 304] 当虚拟机做类加载时，将会从常量池获得对应的符号 引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</p>
<p> [page 306] 专门用于分析Class文件字节码的工具：javap</p>
<h4 id="6-3-3-访问标志"><a href="#6-3-3-访问标志" class="headerlink" title="6.3.3 访问标志"></a>6.3.3 访问标志</h4><p> [page 310] 访问标志</p>
<p> [page 310] 用于识别一些类或 者接口层次的访问信息</p>
<p> [page 310] 访问标志（access_flags）</p>
<h4 id="6-3-4-类索引、父类索引与接口索引集合"><a href="#6-3-4-类索引、父类索引与接口索引集合" class="headerlink" title="6.3.4 类索引、父类索引与接口索引集合"></a>6.3.4 类索引、父类索引与接口索引集合</h4><p> [page 311] 类索引、父类索引与接口索引集合</p>
<p> [page 311] 类索引（this_class）</p>
<p> [page 311] 父类索引（super_class）</p>
<p> [page 311] 接口索引</p>
<p> [page 311] 类索 引用于确定这个类的全限定名</p>
<p> [page 311] 父类索引用于确定这个类的父类的全限定名</p>
<p> [page 311] 接口索引集合就用来描述这个类实现了哪些接 口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是 extends关键字）后的接口顺序从左到右排列在接口索引集合中</p>
<h4 id="6-3-5-字段表集合"><a href="#6-3-5-字段表集合" class="headerlink" title="6.3.5 字段表集合"></a>6.3.5 字段表集合</h4><p> [page 313] 字段表集合</p>
<p> [page 313] “字段”（Field）包括类级变 量以及实例级变量，但不包括在方法内部声明的局部变量</p>
<p> [page 313] 字段表（field_info）用于描述接口或者类中声明的变量</p>
<p> [page 313] 字段可以包括的修饰符有字段的作用域（public、private、protected修饰 符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否 强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、 字段名称</p>
<p> [page 313] 简单名称</p>
<p> [page 313] 描述符</p>
<p> [page 313] 全限定名</p>
<p> [page 314] 描述符的作用是用来描述字段 的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</p>
<p> [page 315] 字段表集合中不会列出从父类或者父接口中继承而来的字段</p>
<h4 id="6-3-6-方法表集合"><a href="#6-3-6-方法表集合" class="headerlink" title="6.3.6 方法表集合"></a>6.3.6 方法表集合</h4><p> [page 316] 方法表集合</p>
<p> [page 317] 方法里的Java代码，经过Javac编译器编译成字节码指令之 后，存放在方法属性表集合中一个名为“Code”的属性里面</p>
<p> [page 317] 如果父类方法在子类中没有被重写（Override），方法表集合中就不会出 现来自父类的方法信息</p>
<h4 id="6-3-7-属性表集合"><a href="#6-3-7-属性表集合" class="headerlink" title="6.3.7 属性表集合"></a>6.3.7 属性表集合</h4><p> [page 318] 属性表集合</p>
<p> [page 318] Class文件、字段表、方法表都可以 携带自己的属性表集合，以描述某些场景专有的信息</p>
<p> [page 321] Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内</p>
<p> [page 321] 操作数栈（Operand Stack）</p>
<p> [page 322] 变量 槽是虚拟机为局部变量分配内存所使用的最小单位</p>
<p> [page 322] 变量槽（Slot）</p>
<p> [page 322] 将局 部变量表中的变量槽进行重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量 槽可以被其他局部变量所使用</p>
<p> [page 322] 《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令</p>
<p> [page 323] 执行过程中的数据交换、方法调用等操作都是基于 栈（操作数栈）</p>
<p> [page 324] 在Javac编 译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法 时自动传入此参数而已。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变 量，局部变量表中也会预留出第一个变量槽位来存放对象实例的引用</p>
<p> [page 324] 显式异常处理表</p>
<p> [page 326] Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也 就是方法描述时在throws关键字后面列举的异常</p>
<p> [page 326] LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系</p>
<p> [page 327] LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系</p>
<h4 id="6-4-字节码指令简介"><a href="#6-4-字节码指令简介" class="headerlink" title="6.4 字节码指令简介"></a>6.4 字节码指令简介</h4><p> [page 339] Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode） 以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成</p>
<p> [page 339] Java虚拟机采用 面向操作数栈而不是面向寄存器的架构</p>
<h4 id="6-4-1-字节码与数据类型"><a href="#6-4-1-字节码与数据类型" class="headerlink" title="6.4.1 字节码与数据类型"></a>6.4.1 字节码与数据类型</h4><p> [page 341] 编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为 相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据</p>
<h4 id="6-4-2-加载和存储指令"><a href="#6-4-2-加载和存储指令" class="headerlink" title="6.4.2 加载和存储指令"></a>6.4.2 加载和存储指令</h4><p> [page 343] 加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈（见第2章关于内存区域的介绍）之 间来回传输</p>
<h4 id="6-4-3-运算指令"><a href="#6-4-3-运算指令" class="headerlink" title="6.4.3 运算指令"></a>6.4.3 运算指令</h4><p> [page 344] 算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶</p>
<h4 id="6-4-4-类型转换指令"><a href="#6-4-4-类型转换指令" class="headerlink" title="6.4.4 类型转换指令"></a>6.4.4 类型转换指令</h4><p> [page 346] 类型转换指令可以将两种不同的数值类型相互转换</p>
<p> [page 346] 宽化类型转换（Widening Numeric Conversion，即小范围类型向大范围类型的安全转换）</p>
<p> [page 346] 处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指 令来完成</p>
<p> [page 346] 在将int或long类型窄化转换为整数类型T的时候，转换过程仅仅是简单丢弃除最低位N字节以外的 内容，N是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。</p>
<h4 id="6-4-5-对象创建与访问指令"><a href="#6-4-5-对象创建与访问指令" class="headerlink" title="6.4.5 对象创建与访问指令"></a>6.4.5 对象创建与访问指令</h4><p> [page 347] 对象创建与访问指令</p>
<h4 id="6-4-6-操作数栈管理指令"><a href="#6-4-6-操作数栈管理指令" class="headerlink" title="6.4.6 操作数栈管理指令"></a>6.4.6 操作数栈管理指令</h4><p> [page 348] 操作数栈管理指令</p>
<h4 id="6-4-7-控制转移指令"><a href="#6-4-7-控制转移指令" class="headerlink" title="6.4.7 控制转移指令"></a>6.4.7 控制转移指令</h4><p> [page 349] 控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下 一条指令继续执行程序</p>
<h4 id="6-4-8-方法调用和返回指令"><a href="#6-4-8-方法调用和返回指令" class="headerlink" title="6.4.8 方法调用和返回指令"></a>6.4.8 方法调用和返回指令</h4><p> [page 350] 方法调用和返回指令</p>
<h4 id="6-4-9-异常处理指令"><a href="#6-4-9-异常处理指令" class="headerlink" title="6.4.9 异常处理指令"></a>6.4.9 异常处理指令</h4><p> [page 351] 异常处理指令</p>
<h4 id="6-4-10-同步指令"><a href="#6-4-10-同步指令" class="headerlink" title="6.4.10 同步指令"></a>6.4.10 同步指令</h4><p> [page 352] Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管 程（Monitor，更常见的是直接将它称为“锁”）来实现的</p>
<h4 id="6-5-公有设计，私有实现"><a href="#6-5-公有设计，私有实现" class="headerlink" title="6.5 公有设计，私有实现"></a>6.5 公有设计，私有实现</h4><p> [page 354] 即时编译器 （Just-In-Time Code Generator）</p>
<h4 id="6-6-Class文件结构的发展"><a href="#6-6-Class文件结构的发展" class="headerlink" title="6.6 Class文件结构的发展"></a>6.6 Class文件结构的发展</h4><p> [page 355] Class文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩展的特 点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱</p>
<h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h4><p> [page 358] Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最 终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制</p>
<p> [page 358] Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成</p>
<p> [page 358] 动态扩展的语言特性就是依赖运行期动 态加载和动态连接这个特点实现的</p>
<p> [page 358] “Class文件”也并非特指某个存在于 具体磁盘中的文件，而应当是一串二进制字节流，无论其以何种形式存在，包括但不限于磁盘文件、 网络、数据库、内存或者动态产生等</p>
<h4 id="7-2-类加载的时机"><a href="#7-2-类加载的时机" class="headerlink" title="7.2 类加载的时机"></a>7.2 类加载的时机</h4><p> [page 359] 加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）</p>
<p> [page 359] 中验证、准备、解析三个部分统称 为连接（Linking）</p>
<p> [page 359] 这些阶段通常都 是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段</p>
<p> [page 359] 有且只有六种情况必须立即对类进行“初始化”（</p>
<p> [page 359] 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始 化，则需要先触发其初始化阶段</p>
<p> [page 359] 使用new关键字实例化对象的时候</p>
<p> [page 359] 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外） 的时候</p>
<p> [page 359] 调用一个类型的静态方法的时候</p>
<p> [page 359] 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化</p>
<p> [page 360] 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</p>
<p> [page 360] 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类</p>
<p> [page 360] 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</p>
<p> [page 360] 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化</p>
<p> [page 360] 这六种场景中的行为称为对一个类型进行主动引用</p>
<p> [page 360] 被动引用</p>
<p> [page 360] 通过子类引用父类的静态字段，不会导致子类初始化</p>
<p> [page 360] 通过其子类来引用父类中定义的静态字段，只会触发 父类的初始化而不会触发子类的初始化</p>
<p> [page 361] 通过数组定义来引用类，不会触发此类的初始化</p>
<p> [page 361] 一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类</p>
<p> [page 361] 它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由 字节码指令newarray触发</p>
<p> [page 361] 这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组，数组中应有的属性 和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类里</p>
<p> [page 361] 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的 类的初始化</p>
<p> [page 362] 接口中不能使 用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器[2]，用于初始化接口中所定义的 成员变量。</p>
<p> [page 362] 一个接口在初始化时，并不要求其父 接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始 化</p>
<h4 id="7-3-1-加载"><a href="#7-3-1-加载" class="headerlink" title="7.3.1 加载"></a>7.3.1 加载</h4><p> [page 364] “加载”（Loading）阶段</p>
<p> [page 364] 通过一个类的全限定名来获取定义此类的二进制字节流</p>
<p> [page 364] 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p> [page 364] 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入 口</p>
<p> [page 364] 从ZIP压缩包中读取</p>
<p> [page 364] JAR、EAR、WAR格式</p>
<p> [page 364] 从网络中获取</p>
<p> [page 364] Web Applet</p>
<p> [page 364] 运行时计算生成</p>
<p> [page 364] 动态代理技术</p>
<p> [page 364] 由其他文件生成</p>
<p> [page 364] 是JSP应用</p>
<p> [page 364] 从数据库中读取</p>
<p> [page 364] 从加密文件中获取</p>
<p> [page 364] 防Class文件被反编译</p>
<p> [page 364] 加载阶段既可以使用Java虚拟机里内置的引导类加 载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节 流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用 程序获取运行代码的动态性</p>
<p> [page 364] 数组类本身不通过类加载器创建，它是由Java虚拟机直接在 内存中动态构造出来的</p>
<p> [page 365] 类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口</p>
<h4 id="7-3-2-验证"><a href="#7-3-2-验证" class="headerlink" title="7.3.2 验证"></a>7.3.2 验证</h4><p> [page 366] 确保Class文件的字节流中包含的信息符合《Java虚 拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</p>
<p> [page 366] 验证</p>
<p> [page 366] 文件格式验证</p>
<p> [page 366] 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</p>
<p> [page 367] 要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符 合描述一个Java类型信息的要求</p>
<p> [page 367] 这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的 验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，</p>
<p> [page 367] 元数据验证</p>
<p> [page 367] 对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要 求</p>
<p> [page 367] 目的是对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相 悖的元数据信息</p>
<p> [page 367] 字节码验证</p>
<p> [page 367] 目的是通过数据流分析和控制流分析，确定 程序语义是合法的、符合逻辑的</p>
<p> [page 367] 对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害 虚拟机安全的行为</p>
<p> [page 368] 符号引用验证</p>
<p> [page 368] 发生在虚拟机将符号引用转化为直接引用 [3] 的时候，这个转化动作将在 连接的第三阶段——解析阶段中发生</p>
<p> [page 368] 符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验</p>
<p> [page 368] 该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源</p>
<p> [page 368] 主要目的是确保解析行为能正常执行</p>
<p> [page 368] 验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段</p>
<h4 id="7-3-3-准备"><a href="#7-3-3-准备" class="headerlink" title="7.3.3 准备"></a>7.3.3 准备</h4><p> [page 370] 准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初 始值的阶段</p>
<p> [page 370] 这些变量所使用的内存都应当在方法区中进行分配</p>
<p> [page 370] 在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中</p>
<p> [page 370] 这时候进行内存分配的 仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中</p>
<p> [page 370] 这里所说的初始值“通常情况”下是数据类型的零值</p>
<p> [page 370] 因为这时尚未开始执行任何Java方法，而把 value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值 为123的动作要到类的初始化阶段才会被执行</p>
<p> [page 370] 如果类字段 的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定 的初始值</p>
<h4 id="7-3-4-解析"><a href="#7-3-4-解析" class="headerlink" title="7.3.4 解析"></a>7.3.4 解析</h4><p> [page 371] 解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<p> [page 371] 符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可</p>
<p> [page 371] 符号引用（Symbolic References）</p>
<p> [page 371] 符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容</p>
<p> [page 371] 直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄</p>
<p> [page 371] 直接引用（Direct References）</p>
<p> [page 371] 直接引用是和虚拟机实现的内存布局直接相关的</p>
<p> [page 371] 引用的目标必定已经在虚拟机 的内存中存在</p>
<p> [page 371] 到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引 用将要被使用前才去解析它</p>
<p> [page 371] 对方法或者字段的访问，也会在解析阶段中对它们的可访问性（public、protected、 private、<package>）进行检查</p>
<p> [page 372] 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7 类符号引用进行</p>
<h4 id="7-3-5-初始化"><a href="#7-3-5-初始化" class="headerlink" title="7.3.5 初始化"></a>7.3.5 初始化</h4><p> [page 376] 除了在加载阶 段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控 制。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程 序。</p>
<p> [page 376] 在初始化阶段，则会根据程序员通 过程序编码制定的主观计划去初始化类变量和其他资源。</p>
<p> [page 376] 初始化阶段就是执行类构造器<clinit>()方法的过程</p>
<p> [page 376] <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的 语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问 到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访 问</p>
<p> [page 376] 不需要显 式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行 完毕</p>
<p> [page 376] 父类中定义的静态语句块要优先于子类的变量赋值 操作</p>
<p> [page 377] 接口与类一样都会生成 <clinit>()方法</p>
<p> [page 377] 接口中不能使用静态语句块</p>
<p> [page 377] 执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法， 因为只有当父接口中定义的变量被使用时，父接口才会被初始化</p>
<p> [page 377] 接口的实现类在初始化时也 一样不会执行接口的<clinit>()方法</p>
<p> [page 377] Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步</p>
<h4 id="7-4-类加载器"><a href="#7-4-类加载器" class="headerlink" title="7.4 类加载器"></a>7.4 类加载器</h4><p> [page 379] 通过一个类的全限定名来获取描述该类的二进制字节 流</p>
<p> [page 379] 实现这个动 作的代码被称为“类加载器”（Class Loader）</p>
<p> [page 379] 让应用程序自己决定如何去获取所需的类</p>
<h4 id="7-4-1-类与类加载器"><a href="#7-4-1-类与类加载器" class="headerlink" title="7.4.1 类与类加载器"></a>7.4.1 类与类加载器</h4><p> [page 380] 任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性</p>
<p> [page 380] 每 一个类加载器，都拥有一个独立的类名称空间</p>
<p> [page 380] 比较两个类是否“相 等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</p>
<p> [page 380] 只要加载它们的类加载器不同，那这两个类就必定不相等</p>
<p> [page 380] “相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance() 方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况</p>
<h4 id="7-4-2-双亲委派模型"><a href="#7-4-2-双亲委派模型" class="headerlink" title="7.4.2 双亲委派模型"></a>7.4.2 双亲委派模型</h4><p> [page 382] 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现 [1] ，是虚拟机自身的一部分</p>
<p> [page 382] 另外一种就是其他所有 的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader</p>
<p> [page 382] 三层类加载器、双亲委派的类加载架构</p>
<p> [page 382] 负责加载存放在 <JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够 识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类 库加载到虚拟机的内存中</p>
<p> [page 382] 启动类加载器（Bootstrap Class Loader）</p>
<p> [page 382] 扩展类加载器（Extension Class Loader）</p>
<p> [page 382] 负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所 指定的路径中所有的类库</p>
<p> [page 383] 应用程序类加载器（Application Class Loader）</p>
<p> [page 383] 负责加载用户类路径 （ClassPath）上所有的类库</p>
<p> [page 383] 也称它为“系统类加载器”</p>
<p> [page 384] 各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents Delegation Model）</p>
<p> [page 384] 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载 器</p>
<p> [page 384] 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加 载这个类，而是把这个请求委派给父类加载器去完成</p>
<p> [page 384] 只有当父加载器反馈自己无法完成这个加载请 求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载</p>
<p> [page 384] Java中的类随着它的类 加载器一起具备了一种带有优先级的层次关系</p>
<h4 id="7-4-3-破坏双亲委派模型"><a href="#7-4-3-破坏双亲委派模型" class="headerlink" title="7.4.3 破坏双亲委派模型"></a>7.4.3 破坏双亲委派模型</h4><p> [page 386] 线程上下文类加载器 （Thread Context ClassLoader）</p>
<p> [page 386] 父类加载器去请求子类加载器完成类加载的行为</p>
<h4 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h4><p> [page 399] 物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层 面上的</p>
<p> [page 399] 解释执行（通过解释器执行）</p>
<p> [page 399] 编译执行（通过即时编译器产生本地代码执行）</p>
<h4 id="8-2-运行时栈帧结构"><a href="#8-2-运行时栈帧结构" class="headerlink" title="8.2 运行时栈帧结构"></a>8.2 运行时栈帧结构</h4><p> [page 400] Java虚拟机以方法作为最基本的执行单元</p>
<p> [page 400] “栈帧”（Stack Frame）</p>
<p> [page 400] 栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息</p>
<p> [page 400] “当前栈帧”（Current Stack Frame）</p>
<h4 id="8-2-1-局部变量表"><a href="#8-2-1-局部变量表" class="headerlink" title="8.2.1 局部变量表"></a>8.2.1 局部变量表</h4><p> [page 401] 局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义 的局部变量</p>
<p> [page 401] 变量槽（Variable Slot）</p>
<p> [page 403] reference类型表示对一个对象实例的引用</p>
<p> [page 403] 根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索 引</p>
<p> [page 403] 根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息</p>
<p> [page 403] Java虚拟机通过索引定位的方式使用局部变量表</p>
<p> [page 403] 使用局部变量表来完成参数值到参数变量列表的传递过程</p>
<p> [page 403] 执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索 引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐 含的参数</p>
<p> [page 403] 局部变量表中的变量槽是可以重用的</p>
<p> [page 405] 局部变量不像前面介绍的类变量那 样存在“准备阶段”</p>
<p> [page 405] 类的字段变量有两次赋初始值的过程，一次在准 备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值</p>
<h4 id="8-2-2-操作数栈"><a href="#8-2-2-操作数栈" class="headerlink" title="8.2.2 操作数栈"></a>8.2.2 操作数栈</h4><p> [page 407] 在调用其他方法的时候是通过操作 数栈来进行方法参数的传递</p>
<p> [page 407] 基于栈的执行引擎</p>
<p> [page 407] 基于寄存器的执行引擎</p>
<h4 id="8-2-3-动态连接"><a href="#8-2-3-动态连接" class="headerlink" title="8.2.3 动态连接"></a>8.2.3 动态连接</h4><p> [page 409] 一个指向运行时常量池 [1] 中该栈帧所属方法的引用</p>
<p> [page 409] 符号 引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析</p>
<p> [page 409] 一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接</p>
<h4 id="8-2-4-方法返回地址"><a href="#8-2-4-方法返回地址" class="headerlink" title="8.2.4 方法返回地址"></a>8.2.4 方法返回地址</h4><p> [page 410] “正常调用完成”（Normal Method Invocation Completion）</p>
<p> [page 410] “异常调用 完成（Abrupt Method Invocation Completion）</p>
<p> [page 410] 恢复上层方法的 局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值 以指向方法调用指令后面的一条指令等</p>
<p> [page 410] 方法退出的过程实际上等同于把当前栈帧出栈</p>
<h4 id="8-3-方法调用"><a href="#8-3-方法调用" class="headerlink" title="8.3 方法调用"></a>8.3 方法调用</h4><p> [page 412] 方法调用阶段唯一的任务就是确定被调用方法的版本 （即调用哪一个方法）</p>
<h4 id="8-3-1-解析"><a href="#8-3-1-解析" class="headerlink" title="8.3.1 解析"></a>8.3.1 解析</h4><p> [page 413] 在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，</p>
<p> [page 413] 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不 可改变的</p>
<p> [page 413] 静态方法、私有方法、实例构造器、父类方法4种，再加上被final 修饰的方法（尽管它使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引 用解析为该方法的直接引用。这些方法统称为“非虚方法”（Non-Virtual Method）</p>
<h4 id="8-3-2-分派"><a href="#8-3-2-分派" class="headerlink" title="8.3.2 分派"></a>8.3.2 分派</h4><p> [page 416] “静态类型”（Static Type）</p>
<p> [page 416] “运行时类 型”（Runtime Type）</p>
<p> [page 416] 在编译阶段，Javac编译器就根据参数的静态类型决定 了会使用哪个重载版本</p>
<h4 id="8-4-1-动态类型语言"><a href="#8-4-1-动态类型语言" class="headerlink" title="8.4.1 动态类型语言"></a>8.4.1 动态类型语言</h4><p> [page 427] 动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编 译期进行的</p>
<p> [page 427] 在编译期就 进行类型检查过程的语言，譬如C++和Java等就是最常用的静态类型语言</p>
<p> [page 428] 静态类型语言能够在编译期确定变量类型，最显著的好处是编译器可以提供全面严谨的 类型检查，这样与数据类型相关的潜在问题就能在编码时被及时发现，利于稳定性及让项目容易达到 更大的规模。</p>
<p> [page 428] 动态类型语言在运行期才确定类型，这可以为开发人员提供极大的灵活性，某些在静 态类型语言中要花大量臃肿代码来实现的功能，由动态类型语言去做可能会很清晰简洁，清晰简洁通 常也就意味着开发效率的提升。</p>
<h4 id="8-5-基于栈的字节码解释执行引擎"><a href="#8-5-基于栈的字节码解释执行引擎" class="headerlink" title="8.5 基于栈的字节码解释执行引擎"></a>8.5 基于栈的字节码解释执行引擎</h4><p> [page 438] 编译执行（通过即时编译器产生本地代码执 行）两</p>
<p> [page 438] 解释执行（通过解释器执行）</p>
<h4 id="8-5-1-解释执行"><a href="#8-5-1-解释执行" class="headerlink" title="8.5.1 解释执行"></a>8.5.1 解释执行</h4><p> [page 440] Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法 树生成线性的字节码指令流的过程</p>
<h4 id="8-5-2-基于栈的指令集与基于寄存器的指令集"><a href="#8-5-2-基于栈的指令集与基于寄存器的指令集" class="headerlink" title="8.5.2 基于栈的指令集与基于寄存器的指令集"></a>8.5.2 基于栈的指令集与基于寄存器的指令集</h4><p> [page 441] 基于栈的指令集</p>
<p> [page 441] 基于寄存器的指令集</p>
<p> [page 441] 基于栈的指令集主要优点是可移植</p>
<p> [page 441] 编 译器实现更加简单</p>
<p> [page 441] 代码相对更加紧凑</p>
<p> [page 442] 栈架构指令集的主要缺点是理论上执行速度相对来说会稍慢一些</p>
<p> [page 442] 在解释执行的状态下</p>
<p> [page 442] 指令数量一般会比寄存 器架构来得更多</p>
<p> [page 442] 频繁的内存访问</p>
<h4 id="8-5-3-基于栈的解释器执行过程"><a href="#8-5-3-基于栈的解释器执行过程" class="headerlink" title="8.5.3 基于栈的解释器执行过程"></a>8.5.3 基于栈的解释器执行过程</h4><p> [page 450] ireturn指令是方法返回指令之一，它将结束方法执行并将操作数栈顶 的整型值返回给该方法的调用者</p>
<h4 id="9-2-3-字节码生成技术与动态代理的实现"><a href="#9-2-3-字节码生成技术与动态代理的实现" class="headerlink" title="9.2.3 字节码生成技术与动态代理的实现"></a>9.2.3 字节码生成技术与动态代理的实现</h4><p> [page 463] 动态代理技术</p>
<h4 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h4><p> [page 481] 即时编译器（常称JIT编译器，Just In Time Compiler）</p>
<p> [page 481] 静态的提前编译器（常称AOT编译器，Ahead Of Time Compiler）</p>
<p> [page 481] 相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现，而不 是依赖字节码或者Java虚拟机的底层改进来支持</p>
<p> [page 481] Java中即时编译器在运行期的优 化过程，支撑了程序执行效率的不断提升；而前端编译器在编译期的优化过程，则是支撑着程序员的 编码效率和语言使用者的幸福感的提高</p>
<h4 id="10-2-2-解析与填充符号表"><a href="#10-2-2-解析与填充符号表" class="headerlink" title="10.2.2 解析与填充符号表"></a>10.2.2 解析与填充符号表</h4><p> [page 489] 词法分析是将源代码的字符流转变为标记（Token）集合的过程</p>
<p> [page 489] 标记才是编译时的最小元素</p>
<p> [page 489] 关键字、变量名、字面量、运算符都可以作为标记</p>
<p> [page 489] 抽象语法树（Abstract Syntax Tree，AST）是一 种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个 语法结构（Syntax Construct），例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等</p>
<p> [page 489] 语法分析是根据标记序列构造抽象语法树的过程</p>
<h4 id="10-2-3-注解处理器"><a href="#10-2-3-注解处理器" class="headerlink" title="10.2.3 注解处理器"></a>10.2.3 注解处理器</h4><p> [page 492] 注解（Annotations）</p>
<p> [page 492] 插入式注解处理器</p>
<p> [page 492] 编译期对代码中的特定注解进行处理</p>
<p> [page 492] 把插入式注解处理器看作是一组编译器的插件，当这些 插件工作时，允许读取、修改、添加抽象语法树中的任意元素</p>
<h4 id="10-2-4-语义分析与字节码生成"><a href="#10-2-4-语义分析与字节码生成" class="headerlink" title="10.2.4 语义分析与字节码生成"></a>10.2.4 语义分析与字节码生成</h4><p> [page 493] 抽象语法树能够表示一个结构正 确的源程序，但无法保证源程序的语义是符合逻辑的</p>
<p> [page 493] 语义分析的主要任务则是对结构上正确的源 程序进行上下文相关性质的检查，譬如进行类型检查、控制流检查、数据流检查</p>
<p> [page 493] 语义分析过程可分为标注检查和数据及控制流分析两个步骤</p>
<p> [page 493] 标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否 能够匹配，等等</p>
<p> [page 495] 数据流分析和控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量 在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问 题</p>
<p> [page 495] 出把局部变量声明为final，对运行期是完全没有影响的，变量的不变性仅仅由Javac编 译器在编译期间来保障，这就是一个只能在编译期而不能在运行期中检查的例子</p>
<p> [page 495] 语法糖（Syntactic Sugar）</p>
<p> [page 495] 指的是在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响， 但是却能更方便程序员使用该语言</p>
<p> [page 495] 使用语法糖能够减少代码量、增加程序的可读性</p>
<p> [page 496] Java中最常见的语法糖</p>
<p> [page 496] 泛型</p>
<p> [page 496] Java虚拟机运行时并不直接支 持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程就称为解语法糖</p>
<p> [page 496] 、变长参数、自动装箱拆箱，等等</p>
<p> [page 496] 实例构造器<init>()方法</p>
<p> [page 496] 类构造器<clinit>()方法</p>
<p> [page 496] 实例构造器并不等同于默认构造函数</p>
<h4 id="10-3-1-泛型"><a href="#10-3-1-泛型" class="headerlink" title="10.3.1 泛型"></a>10.3.1 泛型</h4><p> [page 498] 泛型的本质是参数化类型（Parameterized Type）或者参数化多态（Parametric Polymorphism）的 应用</p>
<p> [page 498] 泛型让程序员能够针对泛化的数据类型编 写相同的算法，这极大地增强了编程语言的类型系统及抽象能力</p>
<p> [page 498] “类型擦除式泛型”（Type Erasure Generics）</p>
<p> [page 498] 只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换 为原来的裸类型（Raw Type</p>
<p> [page 500] “裸类型”（Raw Type）</p>
<p> [page 500] 裸类型应被视为所有该类型泛型化实例的共同父类型（Super Type）</p>
<p> [page 501] 简单粗暴地直接在编译时把ArrayList<Integer>还原 回ArrayList，只在元素访问、修改时自动插入一些强制类型转换和检查指令</p>
<p> [page 501] 不 支持int、long与Object之间的强制转型</p>
<p> [page 501] 别支持原生类型的泛型</p>
<p> [page 502] 运行期无法取到泛型类型信息</p>
<p> [page 502] 参数List<Integer>和List<String>编译之后都被擦除了，变成了同一种的裸类型List， 类型擦除导致这两个方法的特征签名变得一模一样</p>
<p> [page 503] 方法重载要求方法具备不同的特征签名，返回值并不包含 在方法的特征签名中，所以返回值不参与重载选择</p>
<p> [page 503] 在Class文件格式之中，只要描述符不是完全 一致的两个方法就可以共存</p>
<p> [page 503] 两个方法如果有相同的名称和特征签名，但返回值不同，那它 们也是可以合法地共存于一个Class文件中</p>
<h4 id="10-3-2-自动装箱、拆箱与遍历循环"><a href="#10-3-2-自动装箱、拆箱与遍历循环" class="headerlink" title="10.3.2 自动装箱、拆箱与遍历循环"></a>10.3.2 自动装箱、拆箱与遍历循环</h4><p> [page 506] 泛型、自动装箱、自动拆箱、遍历循环与变长参数5种语法糖</p>
<p> [page 506] 自动装箱、拆箱在编译之后被转化 成了对应的包装和还原方法，如本例中的Integer.valueOf()与Integer.intValue()方法</p>
<p> [page 506] 遍历循环则是把代 码还原成了迭代器的实现</p>
<p> [page 506] 变长参数，它在调用的时候变成了一个数组类型的参数</p>
<h4 id="10-3-3-条件编译"><a href="#10-3-3-条件编译" class="headerlink" title="10.3.3 条件编译"></a>10.3.3 条件编译</h4><p> [page 508] 条件编译</p>
<p> [page 509] 泛型、自动装箱、自动拆箱、遍历循环、变长参数和条件编译</p>
<p> [page 509] 部类、枚举类、断言语句、数值字面量、对枚举和字符串的switch支 持、try语句中定义和关闭资源（这3个从JDK 7开始支持）</p>
<h4 id="10-4-1-实战目标"><a href="#10-4-1-实战目标" class="headerlink" title="10.4.1 实战目标"></a>10.4.1 实战目标</h4><p> [page 511] 驼式命名法（Camel Case Name）</p>
<h4 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h4><p> [page 521] 中间表示形式（Intermediate Representation，IR）</p>
<p> [page 521] 即时编译（Just In Time， JIT）</p>
<h4 id="11-2-即时编译器"><a href="#11-2-即时编译器" class="headerlink" title="11.2 即时编译器"></a>11.2 即时编译器</h4><p> [page 522] Java程序最初都是通过解释器 （Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认 定为“热点代码”（Hot Spot Code），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代 码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称 为即时编译器</p>
<h4 id="11-2-1-解释器与编译器"><a href="#11-2-1-解释器与编译器" class="headerlink" title="11.2.1 解释器与编译器"></a>11.2.1 解释器与编译器</h4><p> [page 523] “客户端编译器”（Client Compiler）和“服务端编译器”（Server Compiler），或者简称为C1编译器和 C2编译器</p>
<p> [page 524] “混合模式”（Mixed Mode）</p>
<p> [page 524] 分层编译</p>
<p> [page 525] 用客户端编译器获取更高的编译速度，用服务端编译器来获取更好的编译质量</p>
<h4 id="11-2-2-编译对象与触发条件"><a href="#11-2-2-编译对象与触发条件" class="headerlink" title="11.2.2 编译对象与触发条件"></a>11.2.2 编译对象与触发条件</h4><p> [page 526] 热点代码</p>
<p> [page 526] 被多次调用的方法</p>
<p> [page 526] 被多次执行的循环体</p>
<p> [page 526] 编译的目标对象都是整个方法体，而不会是单独的循环体</p>
<p> [page 526] “热点探测”（Hot Spot Code Detection）</p>
<p> [page 526] 基于采样的热点探测（Sample Based Hot Spot Code Detection）</p>
<p> [page 526] 基于计数器的热点探测（Counter Based Hot Spot Code Detection）</p>
<p> [page 527] 回边计数器（Back Edge Counter，“回边”的意思 就是指在循环边界往回跳转）</p>
<p> [page 527] 方法调用计数器（Invocation Counter）</p>
<h4 id="11-3-1-提前编译的优劣得失"><a href="#11-3-1-提前编译的优劣得失" class="headerlink" title="11.3.1 提前编译的优劣得失"></a>11.3.1 提前编译的优劣得失</h4><p> [page 548] 提前编译</p>
<p> [page 548] 把原本即时编译器在 运行时要做的编译工作提前做好并保存下来，下次运行到这些代码（譬如公共库代码在被同一台机器 其他Java进程使用）时直接把它加载进来使用</p>
<p> [page 548] 在程序运行之前把程序代码编译成机器码的静态翻译工作</p>
<h4 id="11-4-2-方法内联"><a href="#11-4-2-方法内联" class="headerlink" title="11.4.2 方法内联"></a>11.4.2 方法内联</h4><p> [page 561] 方法内联</p>
<h4 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h4><p> [page 596] 每秒事务处理数（Transactions Per Second， TPS）</p>
<p> [page 596] 代表着一秒内服务端平均能响应的请求总数</p>
<h4 id="12-2-硬件的效率与一致性"><a href="#12-2-硬件的效率与一致性" class="headerlink" title="12.2 硬件的效率与一致性"></a>12.2 硬件的效率与一致性</h4><p> [page 597] 缓存一致性（Cache Coherence）</p>
<p> [page 598] 乱序执行（Out-Of-Order Execution）优化</p>
<p> [page 598] 指令重排序 （Instruction Reorder）优化</p>
<h4 id="12-3-1-主内存与工作内存"><a href="#12-3-1-主内存与工作内存" class="headerlink" title="12.3.1 主内存与工作内存"></a>12.3.1 主内存与工作内存</h4><p> [page 600] Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到 内存和从内存中取出变量值这样的底层细节。</p>
<h4 id="12-3-3-对于volatile型变量的特殊规则"><a href="#12-3-3-对于volatile型变量的特殊规则" class="headerlink" title="12.3.3 对于volatile型变量的特殊规则"></a>12.3.3 对于volatile型变量的特殊规则</h4><p> [page 604] volatile</p>
<p> [page 604] 当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知 的</p>
<p> [page 604] 不能得出“基于volatile变量的运算在并发下是线程安全的”这样 的结论</p>
<p> [page 606] 普通的变量仅会保证在该方法的执行过程 中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的 执行顺序一致</p>
<p> [page 606] 禁止指令重排序优化</p>
<h4 id="12-3-5-原子性、可见性与有序性"><a href="#12-3-5-原子性、可见性与有序性" class="headerlink" title="12.3.5 原子性、可见性与有序性"></a>12.3.5 原子性、可见性与有序性</h4><p> [page 611] 原子性、可见性和有序性</p>
<p> [page 611] 基本数据类型的访问、读写都是具备原子性的</p>
<p> [page 611] 这两个字节码指令反映到Java 代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性</p>
<p> [page 611] 字节码指令monitorenter和monitorexit</p>
<p> [page 611] 可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改</p>
<p> [page 611] Java内存模型是通过在变量修改后将新值同步回主内 存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的</p>
<p> [page 611] volatile的特殊规则保证了新值 能立即同步到主内存，以及每次使用前立即从主内存刷新</p>
<p> [page 611] 同步块的可见 性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操 作）”这条规则获得的</p>
<p> [page 611] synchronized和final</p>
<p> [page 611] 被final修饰的字段在构造器中一旦被初始化完 成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通 过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值</p>
<p> [page 612] volatile关键字本 身就包含了禁止指令重排序的语义</p>
<p> [page 612] volatile和synchronized两个关键字来保证线程之间操作的有序性</p>
<p> [page 612] synchronized则是由“一个变量在同一个时刻只允许一条线程对 其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</p>
<h4 id="12-3-6-先行发生原则"><a href="#12-3-6-先行发生原则" class="headerlink" title="12.3.6 先行发生原则"></a>12.3.6 先行发生原则</h4><p> [page 613] “先行发生”（Happens-Before）</p>
<p> [page 613] 先行发生是Java内存模型中定义的两项操作之间的偏 序关系，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B 观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等</p>
<h4 id="12-4-1-线程的实现"><a href="#12-4-1-线程的实现" class="headerlink" title="12.4.1 线程的实现"></a>12.4.1 线程的实现</h4><p> [page 617] 内核线程实现</p>
<p> [page 617] 用户线程实现</p>
<p> [page 617] 直接由 操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调 度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上</p>
<p> [page 617] 内核线程（Kernel-Level Thread，KLT）</p>
<p> [page 617] 内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP）</p>
<p> [page 617] 每个轻量级进程都由一个 内核线程支持</p>
<p> [page 618] 用户线程（User Thread，UT）</p>
<p> [page 619] 系统内核不能感知到用户线程的存 在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助</p>
<p> [page 620] 以HotSpot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的</p>
<p> [page 620] HotSpot自己是不会去干涉线程调度</p>
<h4 id="12-4-2-Java线程调度"><a href="#12-4-2-Java线程调度" class="headerlink" title="12.4.2 Java线程调度"></a>12.4.2 Java线程调度</h4><p> [page 622] 协同式 （Cooperative Threads-Scheduling）线程调度</p>
<p> [page 622] 线程调度是指系统为线程分配处理器使用权的过程</p>
<p> [page 622] 抢占式（Preemptive Threads-Scheduling）线程调度</p>
<p> [page 622] 线程的执行时间由线程本身来控制，线程把自己的工作执行 完了之后，要主动通知系统切换到另外一个线程上去</p>
<p> [page 622] 协同式调度</p>
<p> [page 622] 最大好处是实现简单</p>
<p> [page 622] 线程执行时间不可控 制</p>
<p> [page 622] Java使用的线程调度方式就是抢占式 调度</p>
<p> [page 622] “建议”操作系统给某些线程多分配一 点执行时间</p>
<p> [page 622] Java线程调度是系统自动完成的</p>
<p> [page 622] 通过设置线程优先级</p>
<p> [page 622] Java线程是被映射到 系统的原生线程上来实现的</p>
<p> [page 622] 线程调度最终还是由操作系统说了算</p>
<h4 id="12-4-3-状态转换"><a href="#12-4-3-状态转换" class="headerlink" title="12.4.3 状态转换"></a>12.4.3 状态转换</h4><p> [page 624] Java语言定义了6种线程状态</p>
<p> [page 624] 新建（New）</p>
<p> [page 624] 创建后尚未启动的线程</p>
<p> [page 624] 包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可 能正在执行，也有可能正在等待着操作系统为它分配执行时间</p>
<p> [page 624] 运行（Runnable）</p>
<p> [page 624] 等待被其他线 程显式唤醒</p>
<p> [page 624] 无限期等待（Waiting）</p>
<p> [page 624] 不会被分配处理器执行时间</p>
<p> [page 624] 没有设置Timeout参数的Object::wait()方法</p>
<p> [page 624] 没有设置Timeout参数的Thread::join()方法</p>
<p> [page 624] 限期等待（Timed Waiting）</p>
<p> [page 624] 不会被分配处理器执行时间</p>
<p> [page 624] 在一定时间之后它们会由系统自动唤醒</p>
<p> [page 624] Thread::sleep()方法</p>
<p> [page 624] 设置了Timeout参数的Object::wait()方法</p>
<p> [page 624] 设置了Timeout参数的Thread::join()方法</p>
<p> [page 624] “阻塞状态”在等待着获取到 一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生</p>
<p> [page 624] 阻塞（Blocked）</p>
<p> [page 624] “等待状态”则是在等待一段时 间，或者唤醒动作的发生</p>
<p> [page 624] 结束（Terminated）</p>
<h4 id="12-5-1-内核线程的局限"><a href="#12-5-1-内核线程的局限" class="headerlink" title="12.5.1 内核线程的局限"></a>12.5.1 内核线程的局限</h4><p> [page 627] 映射到操作系统上的线程天然的缺陷是切换、调度成本高昂，系统 能容纳的线程数量也很有限</p>
<h4 id="12-5-2-协程的复苏"><a href="#12-5-2-协程的复苏" class="headerlink" title="12.5.2 协程的复苏"></a>12.5.2 协程的复苏</h4><p> [page 628] 开销主要 来自于响应中断、保护和恢复执行现场的成本</p>
<p> [page 628] 内核线程的调度成本主要来自于用户态与核心态之间的状态转换</p>
<p> [page 628] “上下文”，以程序员的角度来看，是 方法调用过程中的各种局部的变量与资源；以线程的角度来看，是方法的调用栈中存储的各类信息； 而以操作系统和硬件的角度来看，则是存储在内存、缓存和寄存器中的一个个具体数值</p>
<p> [page 628] 协同式调度 （Cooperative Scheduling）</p>
<p> [page 628] 协程会 完整地做调用栈的保护、恢复工作</p>
<p> [page 628] “协程”（Coroutine）</p>
<p> [page 628] 被称为“有栈协程”（Stackfull Coroutine）</p>
<p> [page 628] 协程的主要优势是轻量</p>
<h4 id="12-5-3-Java的解决方案"><a href="#12-5-3-Java的解决方案" class="headerlink" title="12.5.3 Java的解决方案"></a>12.5.3 Java的解决方案</h4><p> [page 630] 纤程（Fiber）</p>
<p> [page 632] 一段使用纤程并发的代码会被分为两部分——执行过程（Continuation）和调度 器（Scheduler）。执行过程主要用于维护执行现场，保护、恢复上下文状态，而调度器则负责编排所 有要执行的代码的顺序</p>
<h4 id="13-2-线程安全"><a href="#13-2-线程安全" class="headerlink" title="13.2 线程安全"></a>13.2 线程安全</h4><p> [page 636] 当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下 的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对 象的行为都可以获得正确的结果，那就称这个对象是线程安全的。</p>
<h4 id="13-2-1-Java语言中的线程安全"><a href="#13-2-1-Java语言中的线程安全" class="headerlink" title="13.2.1 Java语言中的线程安全"></a>13.2.1 Java语言中的线程安全</h4><p> [page 637] 不可变 （Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行 任何线程安全保障措施</p>
<p> [page 637] 在定义时使用final关键字修饰 它就可以保证它是不可变的</p>
<p> [page 637] 需要对象自行保证其行为不会对其状态产生任何影响</p>
<p> [page 639] 对这个对象单次的操作是线程安 全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需 要在调用端使用额外的同步手段来保证调用的正确性</p>
<h4 id="13-2-2-线程安全的实现方法"><a href="#13-2-2-线程安全的实现方法" class="headerlink" title="13.2.2 线程安全的实现方法"></a>13.2.2 线程安全的实现方法</h4><p> [page 641] 互斥同步（Mutual Exclusion &amp; Synchronization）</p>
<p> [page 641] 同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些， 当使用信号量的时候）线程使用</p>
<p> [page 641] 这是一种块结构（Block Structured）的同步语法。synchronized关键字经过Javac编译之后，会在同步块的前后分别形成 monitorenter和monitorexit这两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明 要锁定和解锁的对象。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作 为reference；如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来 决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁</p>
<p> [page 641] 最基本的互斥同步手段就是synchronized关键字</p>
<p> [page 641] 在执行monitorenter指令时，首先要去尝试获取对象的锁。如果 这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行 monitorexit指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。如果获取对象 锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。</p>
<p> [page 641] 被synchronized修饰的同步块对同一条线程来说是可重入的</p>
<p> [page 641] 被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他 线程的进入</p>
<p> [page 641] 无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制 正在等待锁的线程中断等待或超时退出</p>
<p> [page 641] 持有锁是一个重量级（Heavy-Weight）的操作</p>
<p> [page 641] Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条 线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转 换需要耗费很多的处理器时间</p>
<p> [page 642] java.util.concurrent.locks.Lock接口便成了Java的另一种全新的互斥同步手段</p>
<p> [page 642] 重入锁（ReentrantLock）</p>
<p> [page 642] 等待可中断</p>
<p> [page 642] 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待</p>
<p> [page 642] 公平锁</p>
<p> [page 642] 多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</p>
<p> [page 642] synchronized中的锁是非 公平的</p>
<p> [page 642] 在锁被释放时，任何一个等待锁的线程都有机会获得锁</p>
<p> [page 642] 锁绑定多个条件</p>
<p> [page 642] 一个ReentrantLock对象可以同时绑定多个Condition对象</p>
<p> [page 644] 在synchronized与ReentrantLock都可满足需要时优先使用synchronized</p>
<p> [page 644] ·synchronized是在Java语法层面的同步，足够清晰，也足够简单</p>
<p> [page 644] Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不 会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确 保即使出现异常，锁也能被自动释放</p>
<p> [page 644] 互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为阻塞 同步（Blocking Synchronization）</p>
<p> [page 644] 互斥同步属于一种悲观的并发策略</p>
<p> [page 644] 导致用户态到核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开 销</p>
<p> [page 644] 基于冲突检测的乐观并发策略</p>
<p> [page 644] 不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数 据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现 没有竞争的共享数据为止</p>
<p> [page 644] 无锁（Lock-Free） 编程</p>
<p> [page 644] 非阻塞同步（Non-Blocking Synchronization）</p>
<p> [page 644] 要求操作和冲突检测这 两个步骤具备原子性</p>
<p> [page 645] 比较并交换（Compare-and-Swap，下文称CAS）</p>
<p> [page 645] CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V 表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合 A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的 旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断</p>
<p> [page 647] 同步与线程安全两者没有必然的联系。 同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自 然就不需要任何同步措施去保证其正确性</p>
<p> [page 647] 指可以在代码执行的任何 时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不 会出现任何错误，也不会对结果有所影响</p>
<p> [page 647] 可重入代码（Reentrant Code）</p>
<p> [page 647] 不依赖全局变量、存储在堆上的数据和公用的系统资源， 用到的状态量都由参数中传入，不调用非可重入的方法</p>
<p> [page 647] 线程本地存储（Thread Local Storage）</p>
<p> [page 647] 把共享数据的可 见范围限制在同一个线程之内</p>
<p> [page 647] “生产者-消费者”模式</p>
<p> [page 647] “一个请求对应一个服务器线程”（Thread-per-Request）</p>
<p> [page 648] 可重入性是指一条线程能够反复进入被它自己持有锁的同步块的特性，即锁关联的计数器，如果持 有锁的线程再次获得它，则将计数器的值加一，每次释放锁时计数器的值减一，当计数器的值为零 时，才能真正释放锁</p>
<h4 id="13-3-1-自旋锁与自适应自旋"><a href="#13-3-1-自旋锁与自适应自旋" class="headerlink" title="13.3.1 自旋锁与自适应自旋"></a>13.3.1 自旋锁与自适应自旋</h4><p> [page 650] 让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很 快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋）</p>
<p> [page 650] 自 旋锁</p>
<p> [page 650] 如果锁被占用的时间很 短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理 器资源</p>
<p> [page 650] 避免了线程切换的开销</p>
<p> [page 650] 但它是要占用处理器时间</p>
<p> [page 650] 因此自旋等待的时间必须有一定的限 度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程</p>
<p> [page 650] 自旋的时间不再是固定的了，而是由 前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的</p>
<p> [page 650] 自适应的自旋</p>
<h4 id="13-3-2-锁消除"><a href="#13-3-2-锁消除" class="headerlink" title="13.3.2 锁消除"></a>13.3.2 锁消除</h4><p> [page 651] 锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享 数据竞争的锁进行消除</p>
<p> [page 651] String是一个不可变的类，对字符串的连接操作总是通过生成新的String对象来 进行的</p>
<p> [page 651] 在JDK 5之前，字符串加法会转化为StringBuffer 对象的连续append()操作，在JDK 5及以后的版本中，会转化为StringBuilder对象的连续append()操作</p>
<h4 id="13-3-3-锁粗化"><a href="#13-3-3-锁粗化" class="headerlink" title="13.3.3 锁粗化"></a>13.3.3 锁粗化</h4><p> [page 652] 推荐将同步块的作用范围限制得尽量小——只在共享数据 的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等 待锁的线程也能尽可能快地拿到锁</p>
<p> [page 652] 如果一系列的连续操作都对同一个对象反复加锁和 解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导 致不必要的性能损耗</p>
<p> [page 652] 如果虚拟机探测到有这样一串零碎的操作 都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部</p>
<h4 id="13-3-4-轻量级锁"><a href="#13-3-4-轻量级锁" class="headerlink" title="13.3.4 轻量级锁"></a>13.3.4 轻量级锁</h4><p> [page 653] 轻量级锁是</p>
<p> [page 653] 减少传统的重量级锁使用操作系 统互斥量产生的性能消耗</p>
<p> [page 653] HotSpot虚拟机的对象头（Object Header）分为两部分，第一 部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age） 等</p>
<p> [page 653] “Mark Word”</p>
<p> [page 653] 另外一部分用于存储指向方法区对象类型数据的指 针，如果是数组对象，还会有一个额外的部分用于存储数组长度</p>
<p> [page 653] 它会 根据对象的状态复用自己的存储空间</p>
<p> [page 653] Mark Word被设计成一个非固定的动态数据结构</p>
<p> [page 653] 在代码即将进入 同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈 帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝</p>
<p> [page 654] 然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个 更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的 最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态</p>
<p> [page 654] 如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟 机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对 象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果 出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志 的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线 程也必须进入阻塞状态。</p>
<p> [page 655] 如果对象的 Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有 其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</p>
<p> [page 655] 对于绝大部分的锁，在整个同步周期内都是不存在竞争 的</p>
<p> [page 655] 如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确 实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下， 轻量级锁反而会比传统的重量级锁更慢。</p>
<h4 id="13-3-5-偏向锁"><a href="#13-3-5-偏向锁" class="headerlink" title="13.3.5 偏向锁"></a>13.3.5 偏向锁</h4><p> [page 656] 偏向锁</p>
<p> [page 656] 说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互 斥量</p>
<p> [page 656] 偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了</p>
<p> [page 656] 这个锁会偏向于第一个获得它的线 程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需 要再进行同步</p>
<p> [page 656] 么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志 位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程 的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关 的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作 等）。</p>
<p> [page 656] 一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是 否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位 为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照上面介绍的轻量级锁那样去 执行</p>
<p> [page 657] 作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希 码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一 次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变</p>
<p> [page 657] 当一个对象已经计算过一 致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正处于偏向锁状态，又收到需要 计算其一致性哈希码请求 [1] 时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。</p>
<p> [page 657] 偏向锁可以提高带有同步但无竞争的程序性能</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/" data-id="ckmn1ijin000sn8a87nzh4v41" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/python%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.500Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>制作Python程序Windows安装包</p>
<ul>
<li>Pyinstaller：将python文件打包为单个exe文件或者是一个文件夹。</li>
<li>文件夹压缩器NSIS：生成具有NSIS经典界面的自解压文件。</li>
<li>VNISEdit编译器：生成正式的软件安装包。</li>
</ul>
</li>
<li><p>字符串拼接不采用+，而是采用join函数。</p>
</li>
<li><p>使用元组语法同时赋值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c, d = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用序列自动解包。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a, b, c = ls</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>... if ... else ...</code>三目运算符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = x <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> -x</span><br></pre></td></tr></table></figure></li>
<li><p>使用链式比较，即使用<code>if 80 &lt; x &lt; 90</code>而不是<code>if x &lt; 90 and x &gt; 80</code>。</p>
</li>
<li><p>使用<code>any</code>函数判断诸多条件是否至少有一个成立，使用<code>all</code>函数判断是否所有条件都成立。</p>
</li>
<li><p><code>print</code>函数使用参数<code>end=&#39;\r&#39;</code>可以不换行但回车到行数，实现在一行内刷新显示值，可用于显示进度。</p>
</li>
<li><p>使用<code>in</code>判断是否为多个取值之一</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> level <span class="keyword">in</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span><span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>使用隐含类型转换直接判断列表字典字符串等是否为空，因为空字典等等价于None等价于False。</p>
</li>
<li><p>使用列表推导式<code>... for ... in ... if ...</code>实现简单的循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ i <span class="keyword">for</span> i <span class="keyword">in</span> _<span class="built_in">list</span> <span class="keyword">if</span> x &gt; <span class="number">10</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>通过enumerate类使用迭代对象，该类可以返回迭代值和序号，即下标和元素对。</p>
</li>
<li><p>通过argparse解析命令行参数。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument()</span><br><span class="line">......</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure>
<ul>
<li>用单词做参数默认为必须参数，用单短线(-)指定短参数，双短线(–)指定冲长参数，默认为可选参数。</li>
<li>用<code>type</code>指定参数类型。</li>
<li>使用如下语句添加互斥参数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">group = parser.add_mutually_exclusive_group()</span><br><span class="line">group.add_argument(<span class="string">&quot;-m&quot;</span>, <span class="string">&quot;--male&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>)</span><br><span class="line">group.add_argument(<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;--female&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>使用<code>choices</code>选项限制参数值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;--gender&quot;</span>, default=<span class="string">&#x27;male&#x27;</span>, choices=[<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;female&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
<li>使用如下语句指定文件参数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;--file&#x27;</span>, <span class="string">&#x27;-f&#x27;</span>, action=<span class="string">&#x27;append&#x27;</span>,</span><br><span class="line">                dest=<span class="string">&#x27;files&#x27;</span>,</span><br><span class="line">                <span class="built_in">help</span>=(<span class="string">&#x27;additional yaml configuration files to use&#x27;</span>),</span><br><span class="line">                <span class="built_in">type</span>=argparse.FileType(<span class="string">&#x27;rb&#x27;</span>))</span><br></pre></td></tr></table></figure>
<code>dest=files</code>: 将命令行中的–file参数值赋值给变量files，程序中使用args.files访问。<br><code>action=append</code>: 指定多个文件，即指定多次<code>--file</code> ，argparse会将其放在一个list里，程序中使用<code>args.files[0].read()</code>访问<br><code>type=argparse.FileType(&#39;rb&#39;)</code>指定打开模式为<code>rb</code>。</li>
</ul>
</li>
<li><p>使用tqdm模块实现进度条。</p>
</li>
<li><p>在map和sort等函数中使用lambda定义函数。</p>
</li>
<li><p>使用上下文管理，即with语句。</p>
</li>
<li><p>使用装饰器，装饰器将下一行的函数作为装饰器函数的参数，可以在多个不同函数调用之前或者之后完成相关的统一操作，比如插入日志，性能测试等非核心功能，实现一次定义，到处装饰。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">tag</span>):</span>  </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;带参数的装饰器函数&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[%s]  %s() is called, Tag is %s.&#x27;</span> % (ctime(), func.__name__, tag))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco1</span>(<span class="params">func</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;不带参数的装饰器函数&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator1</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[%s]  %s() is called&#x27;</span> % (ctime(), func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorator1</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco(<span class="params"><span class="string">&#x27;Python&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello, Python&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco(<span class="params"><span class="string">&#x27;Java&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello, Python&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>python-dotenv</code>将配置信息排除在代码之外，例如数据库密码、邮件配置等，避免敏感信息硬编码。将配置信息写入.env文件中，在Python程序中使用dotenv模块的<code>load_dotenv()</code>函数将env文件加载入环境变量，之后通过<code>os.getenv()</code>函数来获取配置信息。或直接使用configparser模块读取配置文件(.conf, .ini)。</p>
<br>
  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Mysql-Database]</span></span><br><span class="line"><span class="attr">host</span> = localhost</span><br><span class="line"><span class="attr">user</span> = root</span><br><span class="line"><span class="attr">password</span> = <span class="number">12345</span></span><br><span class="line"><span class="attr">db</span> = test</span><br><span class="line"><span class="attr">charset</span> = utf-<span class="number">8</span></span><br><span class="line"><span class="section">[Email]</span></span><br><span class="line"><span class="attr">host</span> = mail.qq.com</span><br><span class="line"><span class="attr">address</span> = xx@qq.com</span><br><span class="line"><span class="attr">password</span> = xxxxx</span><br></pre></td></tr></table></figure>

  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line">cf = configparser.ConfigParser()</span><br><span class="line">cf.read(<span class="string">&quot;config.ini&quot;</span>)  <span class="comment"># 读取配置文件，如果写文件的绝对路径，就可以不用os模块</span></span><br><span class="line"></span><br><span class="line">secs = cf.sections()  <span class="comment"># 获取文件中所有的section(一个配置文件中可以有多个配置，如数据库相关的配置，邮箱相关的配置，每个section由[]包裹，即[section])，并以列表的形式返回。</span></span><br><span class="line"><span class="built_in">print</span>(secs)</span><br><span class="line"><span class="comment"># [&#x27;Mysql-Database&#x27;, &#x27;Email&#x27;]</span></span><br><span class="line"></span><br><span class="line">options = cf.options(<span class="string">&quot;Mysql-Database&quot;</span>)  <span class="comment"># 获取某个section名为Mysql-Database所对应的键</span></span><br><span class="line"><span class="built_in">print</span>(options)</span><br><span class="line"><span class="comment"># [&#x27;host&#x27;, &#x27;user&#x27;, &#x27;password&#x27;, &#x27;db&#x27;, &#x27;charset&#x27;]</span></span><br><span class="line"></span><br><span class="line">items = cf.items(<span class="string">&quot;Mysql-Database&quot;</span>)  <span class="comment"># 获取section名为Mysql-Database所对应的全部键值对</span></span><br><span class="line"><span class="built_in">print</span>(items)</span><br><span class="line"><span class="comment"># [(&#x27;host&#x27;, &#x27;localhost&#x27;), (&#x27;user&#x27;, &#x27;root&#x27;), (&#x27;password&#x27; = &#x27;12345&#x27;), (&#x27;db&#x27;, &#x27;test&#x27;), (&#x27;charset&#x27;, &#x27;utf-8&#x27;)]</span></span><br><span class="line"></span><br><span class="line">host = cf.get(<span class="string">&quot;Mysql-Database&quot;</span>, <span class="string">&quot;host&quot;</span>)  <span class="comment"># 获取[Mysql-Database]中host对应的值</span></span><br><span class="line"><span class="built_in">print</span>(host)</span><br><span class="line"><span class="comment"># localhost</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li></li>
<li><p>如果列表元素可以按照某种算法推算出来，则不必创建完整的list，而是在循环的过程中不断推算出后续元素，，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。</p>
<ul>
<li><strong>生成器表达式</strong>：如下所示，将列表的方括号[]改为圆括号()就变成了生成器表达式，通过调用<code>g.next()</code>访问元素，或通过for循环迭代访问。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></li>
<li><strong>生成器函数</strong>：在函数中如果出现了yield关键字，那么该函数就不再是普通函数，而是生成器函数。当一个生成器函数调用yield，生成器函数的“状态”会被冻结，所有的变量的值会被保留下来，下一行要执行的代码的位置也会被记录，直到再次调用next()。一旦next()再次被调用，生成器函数会从它上次离开的地方开始。即在每次调用next()时执行，遇到yield语句时返回，再次执行时从上次返回的yield语句处继续执行。  <br></li>
</ul>
</li>
<li><p>函数参数分为四类：</p>
<ul>
<li><strong>普通参数</strong>，即在调用函数时必须按照准确的顺序来进行参数传递。</li>
<li><strong>默认参数</strong>，即参数含有默认值，在调用函数时可以进行参数传递，若没有进行参数传递则使用默认值，要注意，默认参数必须在普通参数的右侧（否则解释器无法解析）。</li>
<li><strong>元组参数</strong>，即 *args，参数格式化存储在一个元组中，长度没有限制，必须位于普通参数和默认参数之后。</li>
<li><strong>字典参数</strong>，即 **kwargs，参数格式化存储在一个字典中，必须位于参数列表（包括元组参数）的最后面。</li>
</ul>
</li>
<li><p>程序开始定义编码方式与解释器。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br></pre></td></tr></table></figure>
<p>###Python 3.x特性</p>
</li>
<li><p>格式化字符串 f-string (python 3.6)</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user = <span class="string">&quot;Jane Doe&quot;</span></span><br><span class="line">action = <span class="string">&quot;buy&quot;</span></span><br><span class="line">log_message = <span class="string">f&#x27;User <span class="subst">&#123;user&#125;</span> has logged in and did an action <span class="subst">&#123;action&#125;</span>.&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(log_message)</span><br><span class="line"><span class="comment"># User Jane Doe has logged in and did an action buy.</span></span><br></pre></td></tr></table></figure></li>
<li><p>路径管理库 Pathlib (python 3.4)：处理文件路径的高级抽象</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">root = Path(<span class="string">&#x27;post_sub_folder&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(root)</span><br><span class="line"><span class="comment"># post_sub_folder</span></span><br><span class="line">path = root / <span class="string">&#x27;happy_user&#x27;</span></span><br><span class="line"><span class="comment"># Make the path absolute</span></span><br><span class="line"><span class="built_in">print</span>(path.resolve())</span><br><span class="line"><span class="comment"># /home/weenkus/Workspace/Projects/DataWhatNow-Codes/how_your_python3_should_look_like/post_sub_folder/happy_user</span></span><br></pre></td></tr></table></figure></li>
<li><p>类型提示 (python 3.5)：指定变量类型</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sentence_has_animal</span>(<span class="params">sentence: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;animal&quot;</span> <span class="keyword">in</span> sentence</span><br><span class="line">sentence_has_animal(<span class="string">&quot;Donald had a farm without animals&quot;</span>)</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure></li>
<li><p>枚举 (python 3.4)：封装常量列表</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, auto</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span>(<span class="params">Enum</span>):</span></span><br><span class="line">    ZOMBIE = auto()</span><br><span class="line">    WARRIOR = auto()</span><br><span class="line">    BEAR = auto()</span><br><span class="line"><span class="built_in">print</span>(Monster.ZOMBIE)</span><br><span class="line"><span class="comment"># Monster.ZOMBIE</span></span><br><span class="line"><span class="keyword">for</span> monster <span class="keyword">in</span> Monster:</span><br><span class="line">    <span class="built_in">print</span>(monster)</span><br></pre></td></tr></table></figure></li>
<li><p>LRU缓存 (python 3.2)：Python将LRU（最近最少算法）封装为一个名为<code>lru_cache</code>的装饰器，优化函数运行。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">512</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_memoization</span>(<span class="params">number: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib_memoization(number-<span class="number">1</span>) + fib_memoization(number-<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 采用LRU缓存后，计算第40个的斐波拉契数用时从30s降低到70us。</span></span><br></pre></td></tr></table></figure></li>
<li><p>扩展的可迭代对象解包 (python 3.0)</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">head, *body, tail = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(head, body, tail)</span><br><span class="line"><span class="comment"># 0 [1, 2, 3] 4</span></span><br><span class="line"></span><br><span class="line">py, filename, *cmds = <span class="string">&quot;python3.7 script.py -n 5 -l 15&quot;</span>.split()</span><br><span class="line"><span class="built_in">print</span>(py)</span><br><span class="line"><span class="built_in">print</span>(filename)</span><br><span class="line"><span class="built_in">print</span>(cmds)</span><br><span class="line"><span class="comment"># python3.7</span></span><br><span class="line"><span class="comment"># script.py</span></span><br><span class="line"><span class="comment"># [&#x27;-n&#x27;, &#x27;5&#x27;, &#x27;-l&#x27;, &#x27;15&#x27;]</span></span><br><span class="line"></span><br><span class="line">first, _, third, *_ = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(first, third)</span><br><span class="line"><span class="comment"># 0 2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/python%E6%8A%80%E5%B7%A7/" data-id="ckmn1ijg00009n8a8385x1ntb" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-My-First-Blog" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/hello-My-First-Blog/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T05:43:37.000Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/24/hello-My-First-Blog/">Hello My First Blog</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>test for blog deploy</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/hello-My-First-Blog/" data-id="ckmn1ijfy0006n8a8fth204ux" data-title="Hello My First Blog" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T05:39:54.286Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/24/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/hello-world/" data-id="ckmn1ijfy0005n8a8023s3goc" data-title="Hello World" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; zurück</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/24/Python%20Cheatsheet/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/24/Python%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/24/tofino-command/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/24/%E5%AE%89%E8%A3%85mininet%E5%92%8Ctofino-model/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/24/TNA%20model/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 xbo<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>