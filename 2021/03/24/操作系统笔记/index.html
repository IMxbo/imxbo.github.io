<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>xbo&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="中断： 程序中断：算术溢出、除数为0、非法访问等。 时钟中断：定时器中断等。 I&#x2F;O中断：I&#x2F;O控制器发送信号通知CPU操作完成或失败等。 硬件失效中断：掉电、存储器奇偶校验错等。 中断时需要把程序状态字PSW和程序计数器PC压入控制栈，然后转向中断服务程序。中断处理完成后再恢复先前的PSW和PC。 处理多个中断：1. 进入中断时禁止再处理中断，其间发生的中断被挂起，未考虑相对优先级和时间限制。">
<meta property="og:type" content="article">
<meta property="og:title" content="xbo&#39;s Blog">
<meta property="og:url" content="http://example.com/2021/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="xbo&#39;s Blog">
<meta property="og:description" content="中断： 程序中断：算术溢出、除数为0、非法访问等。 时钟中断：定时器中断等。 I&#x2F;O中断：I&#x2F;O控制器发送信号通知CPU操作完成或失败等。 硬件失效中断：掉电、存储器奇偶校验错等。 中断时需要把程序状态字PSW和程序计数器PC压入控制栈，然后转向中断服务程序。中断处理完成后再恢复先前的PSW和PC。 处理多个中断：1. 进入中断时禁止再处理中断，其间发生的中断被挂起，未考虑相对优先级和时间限制。">
<meta property="og:locale">
<meta property="article:published_time" content="2021-03-24T06:02:27.554Z">
<meta property="article:modified_time" content="2021-03-16T06:00:27.113Z">
<meta property="article:author" content="xbo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="xbo's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xbo&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-操作系统笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T06:02:27.554Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>中断：</p>
<p>程序中断：算术溢出、除数为0、非法访问等。</p>
<p>时钟中断：定时器中断等。</p>
<p>I/O中断：I/O控制器发送信号通知CPU操作完成或失败等。</p>
<p>硬件失效中断：掉电、存储器奇偶校验错等。</p>
<p>中断时需要把程序状态字PSW和程序计数器PC压入控制栈，然后转向中断服务程序。中断处理完成后再恢复先前的PSW和PC。</p>
<p>处理多个中断：1. 进入中断时禁止再处理中断，其间发生的中断被挂起，未考虑相对优先级和时间限制。 2. 定义中断优先级，高优先级中断可打断低优先级中断。</p>
<p>存储器层次结构：寄存器、高速缓存、内存、硬盘、光盘、磁带。</p>
<p>处理器访问存储器的频率按层次结构递减：局部性原理，执行程序期间，处理器的指令和数据访存呈簇状，即程序会重复访问一个小范围内的指令和数据集合。</p>
<p>高速缓存一致性</p>
<p>直接内存访问DMA</p>
<p>串行处理：用户必须顺序访问计算机。</p>
<p>简单批处理：由监控程序负责执行作业。依赖于处理器可以跳转执行指令，交替地获取或释放控制权。具备==内存保护、定时器、特权指令、中断==等硬件功能。用户程序以==用户模式==执行，不允许访问某些受保护内存区域、不允许执行某些特权指令，监控程序一系统态或==内核模式==运行，可以访问受保护的内存区域，执行特权指令。</p>
<p>多道程序设计或多任务处理：内存中保持操作系统和多个用户程序，依赖==I/O中断==、==直接内存访问==、==内存管理==和==调度算法==。</p>
<p>分时系统：处理器同时处理多个交互作业，多个用户共享处理器时间。</p>
<p>进程：</p>
<p>  一个正在执行的程序、计算机中正在运行的程序的一个实例。</p>
<p>  进程出现错误的主要原因：1. 不正确的同步， 2. 失败的互斥， 3. 不确定的程序调度操作， 4. 死锁。</p>
<p>  进程组成：1. 一段可执行的程序， 2. 程序所需要的相关数据（变量，工作空间，缓冲区等）， 3. 程序的执行上下文，又称进程状态，包括操作系统管理进程及处理器正确执行进程所需的所有信息。</p>
<p>内存管理：</p>
<p>  操作系统的存储器管理职责：进程隔离、自动分配与管理、支持模块化程序设计、保护和访问控制、持久化存储。</p>
<p>  虚拟内存机制允许程序以逻辑方式访问存储器，程序通过虚拟地址访问字，分页系统（内存管理单元）将虚拟地址动态映射为内存中的实际地址或物理地址。</p>
<p>信息保护和安全：</p>
<p>  与操作系统相关的安全和保护问题：可用性、保密性、数据完整性、认证。</p>
<p>调度和资源管理：</p>
<p>  管理各种可用资源（内存空间、I/O设备、处理器），并调度各种活动进程来使用这些资源。</p>
<p>  资源分配和调度策略需要考虑：公平性、有差别的响应性、有效性。</p>
<p>现代操作系统的特征：</p>
<p>  微内核体系结构：相比于将调度、文件系统、网络、设备驱动、存储管理等操作系统功能由一个内核提供，微内核只给内核分配一些最基本的功能，包括地址空间、进程间通信和基本的调度，其他系统服务由运行在用户模式且与其他应用程序类似的进程提供。</p>
<p>  分布式操作系统、多线程、面向对象设计、对称多处理。</p>
<p>容错性：</p>
<p>  可靠性、平均失效时间、平均修复时间、可用性、宕机时间</p>
<p>  通过增加冗余度来实现容错性：</p>
<p>​    空间（物理）冗余：使用多个组件执行相同的功能。</p>
<p>​    时间冗余：检测到错误时重复某一操作。</p>
<p>​    信息冗余：通过复制或编码数据的方式来检测和修复数据。</p>
<p>LINUX主要内核组件：</p>
<p>  信号：内核使用信号来向进程提供信息。</p>
<p>  系统调用：进程通过系统调用来请求系统服务，主要有文件系统、进程、调度、进程间通信、套接字（网络）和其他。</p>
<p>  进程和调度器：创建、管理、调度进程。</p>
<p>  虚拟内存：为进程分配和管理虚拟内存。</p>
<p>  文件系统：为文件、目录和其他文件相关对象提供一个全局的分层命名空间，并提供文件系统函数。</p>
<p>  网络协议：为用户的TCP/IP协议套件提供套接字接口。</p>
<p>  字符设备驱动：管理以单个字节为单位向内核发送、接收数据的设备，例如终端、打印机等。</p>
<p>  块设备驱动：管理以块为单位向内核发送、接受数据的设备，例如各种存储设备。</p>
<p>  网络设备驱动：管理网卡和通信端口。</p>
<p>  陷阱和错误：处理CPU产生的陷阱和错误，如内存错误。</p>
<p>  物理内存：管理实际内存中的内存页池，并为虚拟内存分配内存页。</p>
<p>  中断：处理来自外设的中断。</p>
<p>进程控制块：标识符、状态、优先级、程序计数器、内存指针、上下文数据、I/O状态信息、记账信息。</p>
<p>进程五种状态：</p>
<p>  ==新建态==：刚被创建，还未加入可执行进程组。即该进程的信息已保存在内存中的进程表内，但由于操作系统性能不够而限制了系统中的进程数量或其他原因，进程执行的程序代码还在外存中，内存中也没有分配数据空间。</p>
<p>  新建态-==就绪态==：操作系统准备好再接纳一个进程，进程已在内存中并可以执行。</p>
<p>  就绪态-==运行态==：操作系统的调度器选择一个处于就绪态的进程运行。</p>
<p>  运行态-就绪态：1. 达到时间限制， 2. 被处于就绪态的高优先级进程抢占， 3. 进程自愿释放</p>
<p>  运行态-==退出态==：当前进程表示自身已完成或取消，被操作系统终止。</p>
<p>  ==阻塞态==：进程请求其必须等待的某些事件。</p>
<p>  运行态-阻塞态：1. 操作系统无法立即响应进程的系统服务调用， 2. 进程请求无法立即获得的资源， 3. 等待I/O设备初始化工作完成， 4. 等待其他进程提供输入或信息。</p>
<p>  阻塞态-就绪态：等待的时间发生。</p>
<p>  退出态：进程不再执行，但相关信息会被临时保留。</p>
<p>为每个阻塞事件定义一个队列，等待同一个事件的处于阻塞状态的进程进入同一个队列。为每个优先级定义一个就绪队列，从而容易确定具有最高优先级而等待时间最长的就绪进程。</p>
<p>交换：由于处理器远快于I/O，即使在多道程序中，处理器多数时间仍可能处于空闲状态，因此需要容纳更多进程，方法：1. 扩充内存，但内存价格高，且更大的内存往往导致更大而非更多的进程。 2. 交换，将内存中某些进程的一部分或全部转移到外存中。</p>
<p>==挂起态==：操作系统将处于阻塞状态的进程换出到硬盘中的挂起队列，以释放内存空间供可被调入的其他进程使用，或因父进程请求、长期空闲的定时任务、交互式用户请求等。</p>
<p>阻塞/挂起态：进程在外存中并等待一个事件。</p>
<p>就绪/挂起态：进程在外存中，只要载入内存就可以执行。</p>
<p>阻塞-阻塞/挂起：系统需要更多内存空间，操作系统换出处于阻塞态的进程。</p>
<p>阻塞/挂起-就绪/挂起：等待的事件发生。</p>
<p>就绪/挂起-就绪：内存中没有就绪态进程，或处于就绪/挂起态的进程比处于就绪态的任何进程的优先级更高，操作系统调入处于就绪/挂起态的进程。</p>
<p>就绪-就绪/挂起：操作系统需要更多内存空间，或认为具有更高优先级的阻塞态进程很快将会就绪。</p>
<p>新建-就绪/挂起：新建进程时，操作系统需要创建管理进程的表并分配地址空间，可能出现无足够内存空间的情况，因此转换为挂起态。</p>
<p>阻塞/挂起-阻塞：阻塞/挂起态进程的优先级比任何就绪/挂起态进程的优先级都高，且操作系统认为阻塞进程的时间很快就会发生。</p>
<p>操作系统需要维护内存表、I/O表、文件表、进程表。</p>
<p>进程映像：用户数据、用户程序、栈、进程控制块（任务控制块、进程描述符、任务描述符）。</p>
<p>进程控制块：</p>
<p>  进程标识信息：进程标识符（每个进程都分配有唯一的数字标识符）、父进程标识符、用户标识符。</p>
<p>  处理器状态信息：用户可见寄存器、控制和状态寄存器（程序计数器、条件码、状态信息即程序状态字）、栈指针（用于保存参数和过程调用或系统调用的地址、栈指针指向栈顶）。</p>
<p>  进程控制信息：调度和状态信息（进程状态、优先级、调度相关信息、事件）、数据结构（进程以队列、环或其他结构连接到其他进程，例如同一优先级的就绪态进程可处于同一队列等）、进程间通信（各种标记、信号和信息）、进程特权、存储管理（指向描述分配给该进程的虚存的段表和/或页表的指针）、资源所有权和使用情况（进程控制的资源，例如打开的文件、处理器或其他资源的使用历史等）。</p>
<p>用户模式（非特权模式、用户态）：</p>
<p>内核模式（特权模式、内核态、系统模式）：</p>
<p>操作系统内核典型功能：</p>
<p>  进程管理：进程的创建、调度、切换和终止，进程间同步和通信，管理进程控制块。</p>
<p>  内存管理：内存分配、交换、页和段管理、地址映射、内存保护和共享、虚拟内存。</p>
<p>  I/O管理：缓冲管理、I/O通道和设备分配、完成I/O请求。</p>
<p>  文件管理：文件存储空间管理、目录管理、文件读写管理和保护。</p>
<p>  支持功能：中断处理、监视。</p>
<p>​    进程创建：1. 分配唯一的进程标识符， 2. 分配内存空间（包括程序和数据的进程私有空间、用户栈、进程控制块）， 3. 初始化进程控制块， 4. 设置正确的链接（例如将新进程放在就绪或就绪/挂起链表中）， 5. 创建或扩充其他数据结构。</p>
<p>​    进程切换：可发生在操作系统从当前正在运行的进程中获得控制权的任何时刻，例如处理异步外部事件（例如完成一次I/O操作）的中断、处理错误或异常条件（例如非法文件访问）的陷阱、调用操作系统系统函数（例如请求I/O操作，如打开文件）的系统调用。</p>
<p>操作系统执行：</p>
<p>  无进程内核：在所有进程外部执行操作系统内核。</p>
<p>  在用户进程内运行：在用户进程的上下文中执行所有操作系统软件，进程映像中除了进程自身的数据，还包括内核程序的程序、数据和栈区域。需要额外的进程切换函数。</p>
<p>  作为分离的进程执行：将操作系统的内核功能作为一组独立的系统进程来实现。需要额外的进程切换函数。</p>
<p>进程具有对资源的控制权或所有权，资源包括内存、I/O通道和设备、文件等，操作系统确保进程之间不会发生资源冲突。</p>
<p>线程是可被操作系统调度和分派的实体，又称为轻量级进程。同一个进程的所有线程都驻留在同一块地址空间中，共享该进程的状态和资源。</p>
<p>进程定义为资源分配单元和一个保护单元，与其相关联的有：1. 容纳进程映像的虚拟地址空间， 2. 对处理器、其他进程（用户进程间通信）、文件和I/O资源（设备和通道）的受保护访问。</p>
<p>线程具有：1. 一个线程执行状态， 2. 线程上下文，线程可视为在进程内运行的一个独立程序计数器， 3. 一个执行栈， 4. 每个线程用于局部变量的一些静态存储空间， 5. 与进程内其他线程共享的内存和资源的访问。</p>
<p>相比于进程，创建、切换、终止线程，以及线程间通信的效率更高（独立进程间通信需要内核介入，以提供保护和通信所需要的机制）。</p>
<p>多线程在单用户多处理系统中的应用：1. 前台和后台工作， 2. 异步处理， 3. 加快执行速度， 4. 模块化程序结构。</p>
<p>一个进程中的所有线程共享同一个地址空间和诸如打开的文件之类的其他资源，一个线程对资源的任何修改都会影响同一进程中其他线程的环境，因此需要同步各个线程的活动，以便它们互不干扰且不破环数据结构。</p>
<p>Linux中的进程或任务由一个task_struct数据结构表示，包含如下信息：</p>
<p>  状态：进程的执行状态（执行态、就绪态、挂起态、停止态、僵死态）。</p>
<p>  调度信息：Linux调度进程所需要的信息，进程可能是普通的或实时的，并具有优先级。</p>
<p>  标识符：每个进程都有唯一的一个进程标识符，以及用户标识符和组标识符，组标识符用于给一组进程指定资源访问特权。</p>
<p>  进程间通信：IPC机制。</p>
<p>  链接：每个进程都有一个到其父进程、兄弟进程、子进程的链接。</p>
<p>  时间和计时器：包括进程创建的时刻和进程所消耗的处理器时间总量、一个或多个间隔计时器。</p>
<p>  文件系统：指向被该进程打开的任何文件的指针和指向该进程当前目录与根目录的指针。</p>
<p>  地址空间：定义分配给该进程的虚拟地址空间。</p>
<p>  处理器专用上下文：构成该进程上下文的寄存器和栈信息。</p>
<p>Linux进程的状态：</p>
<p>  运行：就绪态或执行态。</p>
<p>  可中断：阻塞态，该进程正在等待一个事件、一个可用的资源或另一个进程的信号。</p>
<p>  不可中断：阻塞态，该进程正在等待一个硬件条件，不会接收任何信号。</p>
<p>  停止：进程被终止，并且只能由来自另一个进程的主动动作恢复。</p>
<p>  僵死：进程已被终止，但进程表中仍然有其任务结构。</p>
<p>Linux提供了一种不区分进程和线程的解决方案（Linux没有给线程单独定义数据结构），将用户级线程映射到内核级进程，组成一个用户级进程的多个用户级线程则映射到共享同一个组ID的多个Linux内核级进程上，这些进程可以共享文件和内存等资源，使得同一个组中的进程调度切换时不需要切换上下文。</p>
<p>Linux通过复制当前进程的属性可创建一个新进程，新进程可以共享资源，如文件、信号处理程序和虚存。共享相同虚存的两个进程可以视为同一个进程中的线程。Linux使用clone()命令代替通常的fork()命令来创建进程。Linux内核在切换进程时，会检查两个进程的页目录地址是否相同，若相同，则他们共享同一个地址空间，此时的上下文切换仅是切换执行的代码。</p>
<p>属于同一个进程组的克隆进程共享同一个内存空间，但不能共享同一个用户栈，所以clone()调用会为每个进程创建独立的栈空间。</p>
<p>Linux的命名空间可使一个进程或同一命名空间下的多个进程拥有与其他命名空间下的其他进程不同的系统视图，从而实现控制组（cgroups，也称容器），使得进程或进程组像是系统上的唯一进程。</p>
<p>Linux具有6个命名空间，命名空间由系统调用clone()创建，或由unshare()系统调用创建一个依附于所调用进程的新命名空间。</p>
<p>  Mount命名空间：为进程提供文件系统层次结构的特定视图，不同mount命名空间内的进程具有不同的文件系统层次结构，一个进程使用的所有文件操作仅适用于该进程可见的文件系统。</p>
<p>  UTS命名空间：</p>
<p>  IPC命名空间：隔离某些进程间通信IPC资源，如信号量。因此并发机制由可在进程中启动IPC的程序员使用，这些进程享有相同的IPC命名空间。</p>
<p>  PID命名空间：隔离进程ID空间，可使不同PID命名空间中的进程拥有相同的PID。</p>
<p>  网络命名空间：隔离与网络相关的系统资源，每个网络命名空间都拥有自己的网络设备、IP地址、IP路由表、端口号等，这些命名空间虚拟化所有对网络资源的访问，允许每个cgroup访问其需要的网络。一个网络设备或一个套接字在任何给定时间只能属于一个命名空间。</p>
<p>  用户命名空间：</p>
<p>并发包括的设计问题有：进程间通信、资源共享与竞争（如内存、文件、I/O访问）、进程间同步、进程调度等。</p>
<p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<p>原子操作：一个函数或动作的指令序列要么全部成功执行，要么都不执行。</p>
<p>临界资源：多个进程/线程都需要访问的不可共享的资源。</p>
<p>临界区：访问临界资源的一段代码。</p>
<p>死锁：两个进程/线程因互相等待对方释放资源而无法继续执行的情况。</p>
<p>互斥：一个进程/线程进入临界区后，其他进程/线程不能再进入。</p>
<p>竞争条件：多个进程/线程在读写一个共享数据时，结果依赖于他们执行的相对顺序。</p>
<p>并发机制：信号量、互斥量、条件变量、管程、事件标志、消息、自旋锁。</p>
<p>信号量：wait操作使信号量值减一，如果信号量值变成负数，则阻塞当前进程，否则继续。signal操作使信号量值加一，如果信号量值依旧小于等于零，则将某个被wait操作阻塞的进程解除阻塞（唤醒）。当信号量值大于等于0时，信号量值是执行wait操作而不被阻塞的进程数，信号量值小于0时，信号量值是执行wait操作而阻塞的进程数。</p>
<p>互斥锁被设置为锁定（一般为0）时用于阻塞其他进程使用数据，当数据不再需要时解锁（设定值为1），锁定/解锁互斥锁的的进程必须是同一个，信号量可以是不同进程加锁/解锁。</p>
<p>生产者/消费者问题：生产者产生数据，并放置在缓冲区中，消费者从缓冲区中每次取出一个数据。每次只有一个生产者或消费者可以访问缓冲区，同时当缓冲区已满时，生产者不能继续向其中添加数据（阻塞），当缓冲区为空时，消费者不能继续取出数据（阻塞）。</p>
<p>管程：由一个或多个过程、一个初始化序列和局部数据组成的软件模块，局部数据只能被管程的过程访问，一个进程只能通过调用管程的一个过程进入管程，任何时候都只能有一个进程在过程中执行，其他调用管程的进程被阻塞。管程的所有同步机制都在管程内部实现。</p>
<p>管程使用条件变量来同步，wait(c)表示调用进程在条件c上阻塞，管程现在可以被另一个进程使用，signal(c)表示恢复执行某个在条件c上阻塞的进程，如果有多个则选择其中一个，如果没有，则什么也不做。</p>
<p>相比于信号量，管程的所有同步机制都被限制在管程内部，易于验证同步的正确性，易于检测出错误，若一个管程被正确编写，则所有进程对受保护资源的访问都是正确的。</p>
<p>notify(x)改进：执行notify(x)会使得在x条件上等待的队列得到通知，但发信号的进程继续执行，在将来合适且处理器可用时恢复执行位于x条件上等待的队列头的进程，并且这个等待的进程恢复执行时重新检查条件。每个等待的进程都有一个监视计时器，等待超时未收到通知时，该进程被设置为就绪态，防止产生饥饿现象。notifyAll(x)用于发送广播，使所有在x条件上等待的进程都置于就绪态。</p>
<p>进程间的合作需要通过消息传递机制交换信息，发送或接收消息可以是阻塞或非阻塞的，寻址可以是直接通过进程标识符的直接寻址，或通过消息队列的间接寻址。</p>
<p>消息格式包括了消息源和目的的标识符、消息长度与类型、额外的控制信息和消息内容。</p>
<p>排队原则可以是先进先出或指定消息的优先级。</p>
<p>读/写问题：存在一个被多个进程共享的数据区，有些进程只能读数据，有些进程只能写数据，且任意数量的读进程可同时读，一次只有一个写进程可以写文件，若有写进程在写文件，则禁止任何其他杜进程读文件。</p>
<p>死锁：一组线程相互等待对方占有的资源而陷入永久性阻塞的现象。</p>
<p>死锁的三个必要条件：</p>
<ol>
<li>互斥，一个资源一次只能被一个线程占有。</li>
<li>占有且等待，一个线程在等待其他线程释放资源时，会继续占有已分配的资源。</li>
<li>不可抢占， 不能强行抢占进程已占有的资源。</li>
</ol>
<p>当程序出现： 4. 循环等待，存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源。 会产生死锁。</p>
<p>上述4个条件构成了死锁的充分必要条件。 第4个条件是前3个条件的潜在结果，如果前3个条件满足，则可能会因为进程请求和释放资源的顺序，导致出现不可解的循环等待，此即死锁。</p>
<p>处理死锁的三种方法： 1. 采用某种策略消除4个条件中的某个条件的出现，来预防死锁， 2. 基于资源分配的当前状态做动态选择来避免死锁， 3. 试图检测死锁（满足4个条件）的存在并从死锁中恢复。</p>
<p>死锁预防：</p>
<ol>
<li>互斥不可能避免。</li>
<li>占有且等待的一个解决办法是：要求进程一次性请求所有需要的资源，并阻塞该进程直到所有请求都满足，但：进程可能阻塞很长时间，实际上只要有一部分资源它就可以继续执行，其次，进程占有的资源可能长时间不会使用，此时其他进程也不能使用，再者，进程可能事先并不知道它所需要的全部资源。</li>
<li>不可抢占的解决办法是：1. 占有某个资源的进程进一步申请资源时若被拒绝，则必须释放最初占有的资源，必要时再次申请。 2. 进程请求当前被另一个进程占有的资源时，操作系统可以抢占另一个进程，要求它释放资源。这要求资源的状态很容保存或恢复（像处理器一样）。</li>
<li>循环等待的一个解决办法是：定义资源的线性顺序，进程只能按序申请资源。</li>
</ol>
<p>死锁避免：与预防的差别在于，死锁预防是通过破坏三个必要条件间接完成，或破环循环等待直接完成，死锁避免是允许三个必要条件存在，但通过正确的资源调度，确保不会到达死锁点。</p>
<ol>
<li>进程启动拒绝：若一个进程的请求会导致死锁，则不启动该进程。</li>
</ol>
<p>定义向量（Resource）$\bold{R}={R_1,R_2,…,R_m}$表示系统中每种资源的总量，向量（Available）$\bold{V}={V_1,V_2,…,V_m}$表示未分配给进程的每种资源的总量(可用资源)，矩阵（Claim）$\bold{C}={C_{ij}}，C_{ij}$表示进程i对资源j的需求总量，矩阵（Allocation）$\bold{A}={A_{ij}}，A_{ij}$表示当前分配给进程i的资源j的数量。</p>
<p>只有满足所有当前进程的最大请求及新进程的请求时，才会启动该新进程。</p>
<ol>
<li>资源分配拒绝：若一个进程增加的资源请求会导致死锁，则不允许这一资源分配。</li>
</ol>
<p>银行家算法：</p>
<p>  系统的状态是当前给进程分配的资源状态，包括上述定义的两个向量和两个矩阵，系统安全状态是指至少有一个资源分配序列（即将资源按照该进程序列进行分配，进程获得资源运行至退出后释放资源）不会导致死锁（即所有进程都能运行直到结束），不安全状态是指非安全的一个状态。</p>
<p>  进程请求一组资源时，如果同意该请求后系统的状态仍处于安全状态，则同意该请求，否则阻塞该请求直到同意该请求后系统状态仍是安全的。</p>
<p>死锁检测：</p>
<p>  不限制资源访问或约束进程行为，尽可能给进程分配所请求的资源，操作系统通过周期性的执行一个算法来检测是否出现循环等待现象。</p>
<ol>
<li>最初所有进程都是未标记的，矩阵（Allocation）$\bold{A}={A_{ij}}，A_{ij}$表示当前分配给进程i的资源j的数量，矩阵（Request）$\bold{Q}={Q_{ij}}，Q_{ij}$表示进程i请求的资源j的数量，向量（Available）$\bold{V}={V_1,V_2,…,V_m}$表示未分配给进程的每种资源的总量(可用资源)。</li>
<li>标记矩阵A中一行全为0的进程。</li>
<li>查找进程i，使进程i未标记且对应的资源需求（即矩阵Q中对应的行）都小于等于向量V（此时运行该进程不会导致死锁），如果找不到则终止算法。</li>
<li>若找到这样的行，则标记进程i，并把矩阵A中对应行加到向量V中（运行完该进程后的可用资源数量），返回步骤3。</li>
<li>当且仅当这个算法的最终结果有未标记的进程时，才存在死锁。</li>
</ol>
<p>死锁恢复：</p>
<ol>
<li>直接取消所有死锁进程。</li>
<li>回滚死锁进程，并重新启动。</li>
<li>连续取消死锁进程直到不再存在死锁。所选取消进程的顺序应基于某种最小代价原则（例如已消耗的处理器时间最少、已分配的资源总量最少、优先级最低等），取消后需要重新调用检测算法以测试是否仍存在死锁。</li>
<li>连续抢占资源直到不存在死锁。与3一样需要使用一种基于代价的选择方法来抢占进程的资源，每次抢占后也需要重新检测是否存在死锁，资源被抢占的进程必须回滚到获得这个资源之前的某一状态。</li>
</ol>
<p>哲学家就餐问题：。。。</p>
<p>Unix并发机制：</p>
<ol>
<li>管道，管道是一个环形缓冲区（FIFO队列，一个进程写，另一个进程读），允许两个进程以生产者/消费者的模型进行通信。一次只能有一个进程可以访问管道。具有父子关系的进程可以共享匿名管道，不相关进程只能共享命名管道。</li>
<li>消息，每个进程都有一个与之相关联的信息队列，其功能类似于信箱。</li>
<li>共享内存，虚存中由多个进程共享的一个公共内存块。</li>
<li>信号量，可进行增量signal或减量wait操作。</li>
<li>信号，用于向一个进程通知发生异步事件的机制，一次只能给进程一个信号，且没有优先级。进程只有在被唤醒继续运行或从系统调用中返回时才处理信号，进程可以通过执行某些默认行为、执行一个信号处理函数或忽略该信号来对信号做出响应（由进程本身处理信号，而不是操作系统）。</li>
</ol>
<p>Linux并发机制：</p>
<ol>
<li>包含UNIX中的所有并发机制，并支持实时信号，相比于UNIX中的信号，实时信号可以1. 支持按优先级顺序排列的信号进行传递， 2. 多个信号能排队， 3. 可以将数值（一个整数或指针）随信号一起发送至目标进程。</li>
<li>原子操作， 原子操作在执行时不会被打断或干扰，Linux定义了两种原子操作：针对整数变量的操作和针对位图bitmap中某一位的位图操作。</li>
<li>自旋锁， 基本自旋锁：在同一时刻只有一个线程能获得自旋锁，其他任何试图获得自旋锁的线程将一直进行尝试（即自旋），直到获得了该锁。读写自旋锁：允许多个线程同时以只读的方式访问同一数据结构，只有当有一个线程想要更新数据结构时，才会互斥地访问该自旋锁。</li>
<li>屏障：禁止编译器或处理器进行代码重排序。</li>
</ol>
<p>页框：内存中固定长度的块。</p>
<p>页：固定长度的数据块，存储在二级存储器中，数据页可以临时复制到内存的页框中。</p>
<p>段：变长数据块，存储在二级存储器中，整个段可以临时复制到内存的一个可用区域中（分段），或将一个段分为许多页，然后将每页复制到内存中（分段与分页相结合）。</p>
<p>内存管理需求：</p>
<ol>
<li>重定位， 程序经过换入换出后，在内存中的位置会发生变化，处理器硬件和操作系统必须能以某种方式把程序代码中的内存访问转换为实际的物理内存地址。</li>
<li>保护， 进程不能未经授权地访问（读操作或写操作）其他进程的内存单元。</li>
<li>共享， 在满足基本保护的前提下，允许多个进程对内存共享区域进行受控访问。</li>
<li>逻辑组织， 内存总是被组织成线性或一维的地址空间，且地址空间由一系列字节或字组成，外部存储器在物理层上也是按类似方式组织，但大多数程序被组织成模块，操作系统需要能够有效地处理以某种模块形式组织的用户程序与数据。</li>
<li>物理组织， 在多级存储结构中，操作系统需要处理内存与外存之间信息流的组织。</li>
</ol>
<p>固定分区：系统生成阶段，内存被划分为许多静态分区，进程可装入大于等于自身大小的分区中。</p>
<p>动态分区：系统根据进程大小动态创建分区。</p>
<p>简单分页：内存被划分为许多大小相等的页框，每个进程被划分成许多大小与页框相等的页，装入进程时，把进程包含的所有页装入内存中不一定连续的某些页框中。与固定分区一样，会产生内部碎片。</p>
<p>简单分段：每个进程的程序和数据被划分成许多段，装入进程时，把进程包含的所有段装入内存中不一定连续的某些动态分区中。与动态分区一样，会产生外部碎片。</p>
<p>虚存分页：与简单分页类似，不需要装入进程的所有页，非驻留页在以后需要时自动调入内存。</p>
<p>虚存分段：与简单分段类似，不需要装入进程的所有段，非驻留段在以后需要时自动调入内存。</p>
<p>压缩：操作系统不时地移动进程，使得进程占用的空间连续，并使所有空闲空间连成一片。</p>
<p>进程经过换入换出或内存压缩后，其在内存中的绝对地址会发生移动，进程访问（指令和数据单元）的位置不是固定的。</p>
<p>逻辑地址：与当前数据在内存中的物理分配无关的访问地址，在执行对内存的访问前需要转换成物理地址。</p>
<p>相对地址：是数据相对于某个已知点（通常是程序的开始处，又称基址）的偏移量。</p>
<p>物理地址或绝对地址：数据在内存中的实际位置。</p>
<p>分页：</p>
<p>操作系统为每个进程维护一个页表，页表中给出进程的每页所对应的页框在内存中的位置，同时操作系统维护一个空闲页框列表。</p>
<p>程序中的相对地址由程序的起点和逻辑地址定义，逻辑地址包括一个页号和在该页中的偏移量。处理器根据页表由页号和偏移量产生物理地址。</p>
<p>分段：</p>
<p>分页对程序来说是透明的，而分段通常是可见的，程序员或编译器可把程序和数据指定到不同段。</p>
<p>操作系统为每个进程维护一个段表，段表中给出进程的每个段在内存中的起始位置和长度，同时操作系统维护一个空闲页框列表。</p>
<p>应用程序有许多已编译过或汇编过的模块组成，这些模块以目标代码的形式存在，并被链接起来以解析模块间的任何访问和对库文件的访问，库文件可以合并到程序中，或作为操作系统在运行时提供的共享访问代码。</p>
<p>绝对加载：加载的模块中的所有地址访问是确定的，即是绝对的内存地址。可以在程序设计时由程序员完成，或者在编译或汇编时将程序中包含的符号地址访问转换为实际的绝对内存地址。</p>
<p>可重定位加载：汇编器或编译器不产生实际的绝对内存地址，而是使用相对于某些已知点（例如程序开始）的相对地址。在程序加载时由加载器将相对地址换位为绝对地址。</p>
<p>动态运行时加载：程序加载到内存时所有的内存访问都以相对地址表示，只有在指令真正执行时才计算其绝对地址。</p>
<p>进程中的所有内存访问都是逻辑地址，这些逻辑地址会在运行时动态地转换为物理地址，意味着进程可以被换入或换出内存，可以在执行过程中的不同时刻占据内存中的不同区域。一个进程可以被划分为许多块（页和段），在执行过程中，这些块不需要连续地位于内存中，也不需要全部加载进入内存。</p>
<p>长程调度：决定将哪些进程加入待执行进程池，（新建-就绪，新建-就绪挂起）</p>
<p>中程调度：决定将哪些进程的部分或全部加载入内存，即交换（就绪挂起-就绪，阻塞挂起-阻塞）</p>
<p>短程调度：决定处理器执行哪个可运行进程，（就绪-运行），导致当前进程阻塞或抢占当前运行进程的事件（时钟中断、I/O中断、系统调用、信号）发生时调用短程调度程序。</p>
<p>IO调度：决定可用IO设备处理哪个进程挂起的IO请求</p>
<p>调度本质上属于队列管理（排队论）问题，用于在排队环境中减少延迟并优化性能。</p>
<p>短程调度规则：周转时间（驻留时间）、响应时间、吞吐量、处理器利用率、公平性、优先级等。</p>
<p>面向块的IO设备：块的大小是固定的，传送过程中一次传送一块。</p>
<p>面向流的IO设备：以字节流的方式输入/输出数据。</p>
<p>磁盘IO：等待设备、等待通道、寻道、旋转延迟、数据传输。</p>
<p>寻道时间：磁头臂移到指定磁道所需要的时间，在读写一个磁盘块所需时间中占比最长，磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<p>旋转延迟：磁盘的待访问地址区域旋转到磁头可访问位置所需要的时间。</p>
<p>传输时间：磁盘完成数据读取/写入所需要的时间。</p>
<p>存取时间：寻道时间+旋转延迟</p>
<p>磁盘调度策略：</p>
<p>操作系统为每个IO设备维护一个请求队列，队列中包含来自多个进程的许多IO请求，</p>
<ul>
<li><p>随机调度：随机从IO请求队列中选择项目，此时磁道是随机被访问的，寻道时间过长，性能最差。</p>
</li>
<li><p>FIFO/先到先服务FCFS：按磁盘请求的顺序进行调度，如果请求是访问簇聚的文件扇区，则性能较好，如果是大量进程竞争，则性能接近随即调度。</p>
</li>
<li><p>优先级：不会优化磁盘利用率，但满足操作系统的响应时间。</p>
</li>
<li><p>最短寻道时间优先（shortest seek time first，SSTF）：选择使磁头臂从当前位置开始寻道时间最短的磁盘IO请求。容易出现饥饿现象。</p>
</li>
<li><p>电梯算法/SCAN算法：磁头臂沿一个方向移动，按磁道顺序完成请求，直到到达最后一个磁道，或这个方向没有其他请求为止（对所有请求按块号进行排序），然后反转方向，沿相反方向扫描，同样按磁道顺序完成所有请求。</p>
</li>
<li><p>C-SCAN：循环扫描算法，按一个方向扫描，当磁头臂访问到某个方向的最后一个磁道后，返回到相反方向末端的磁道，并再次开始扫描。</p>
</li>
<li><p>N步SCAN：为避免一个或多个进程对一个磁道有较高的访问频次，不断重复请求这个磁道造成垄断（即磁头粘性），磁盘请求队列被分为多个长度为N的子队列，每次用SCAN处理一个子队列，新请求必须添加到其他未在处理的队列中。</p>
</li>
</ul>
<p>RAID 独立磁盘冗余阵列Redundant Array of Independent Disks</p>
<ul>
<li>raid是一组物理磁盘驱动器，操作系统把它视为单个逻辑驱动器。</li>
<li>数据分布在多个物理驱动器阵列中（条带化）。</li>
<li>使用冗余磁盘保存奇偶校验信息，保证一个磁盘失效时，数据具有可恢复性。</li>
</ul>
<p>磁盘高速缓存是内存中为磁盘扇区设置的一个缓冲区，包含磁盘中某些扇区的副本。</p>
<p>缓存置换策略：</p>
<ul>
<li>最近最少使用算法（Least Recently Used，LRU）：置换缓存中最长时间未被访问的块。</li>
<li>最不常使用算法（Least Frequently Used, LFU）：置换缓存中访问次数最少的块。</li>
</ul>
<p>UNIX中每个单独的io设备都与一个特殊文件相关联，它们由文件系统管理，并按照与用户数据相同的方式读写，即要从设备读或向设备写，可给该设备相关联的特殊文件发送读请求或写请求。</p>
<p>Linux磁盘调度算法：</p>
<ul>
<li>电梯调度：新请求可与队列中访问同一扇区或直接相邻扇区的请求合并；如果队列中存在等待时间过长的请求，则新请求插入队列尾部；否则将新请求按块号顺序插入队列中。</li>
<li>最后期限调度：存在三个队列：包含所有请求的顺序队列、读FIFO队列和写FIFO队列，新请求加入顺序队列，再加入读或写FIFO队列，读写队列中每个请求具有最后期限，调度器默认调度顺序队列，当读写FIFO队列中有超期限请求时，则优先调度超期限的请求。</li>
<li>预期调度：调度一个读请求时，调度系统延迟执行一段时间。</li>
</ul>
<p>Linux页面缓存：缓存磁盘和内存交互的数据，优势在于：1. 将脏数据（修改过的数据）写回磁盘时可进行排序，使写入磁盘更高效。 2. 局部性原理，缓存的页面很可能被再次引用，减少不必要的磁盘IO。 </p>
<p>脏数据在如下情况下写回磁盘：1. 空闲内存低于某个阈值， 2. 脏页面驻留时间超过某个阈值。</p>
<p>虚拟机管理程序Hypervisor对其支持的虚拟机抽象物理硬件，作为代理为虚拟机请求要使用的物理主机资源。</p>
<p>虚拟机优势：易于备份与迁移、快速部署、</p>
<p>两类虚拟机管理程序：</p>
<ul>
<li>作为一个软件层直接运行在物理服务器上，如VMware ESXi、Hyper-V。直接控制主机的物理资源，具有更好的性能、更高的安全性</li>
<li>作为一个应用程序运行在主机操作系统上，VMware Workstation、Oracle Virtual Box。</li>
</ul>
<p>CPU虚拟：</p>
<ul>
<li>以软件的方式模拟芯片并提供访问接口，平台无关、易于移植、性能不高。</li>
<li>向虚拟机提高主机物理CPU的时间片，通过拦截虚拟机操作系统向CPU发送的指令，然后调度主机的物理处理器时间，发送执行请求并将结果返回给虚拟机操作系统。</li>
</ul>
<p>高速缓存一致性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" data-id="ckmn1nj9w000n9wa86jvabd6c" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/24/%E7%AE%80%E5%8E%86-%E5%BE%90%E5%8D%9A/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2021/03/24/java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java并发学习笔记</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/24/Python%20Cheatsheet/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/24/Python%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/24/tofino-command/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/24/%E5%AE%89%E8%A3%85mininet%E5%92%8Ctofino-model/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/24/TNA%20model/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 xbo<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>