<!DOCTYPE html>

<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>ORM框架 [ xbo&#39;s Blog ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
  
  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
    <script id="leancloud">
      AV.init({
          appId: "6E5zTbTljdUbVW2WkXPsXGJk-gzGzoHsz",
          appKey: "0vsyDKfNpeSECAI70J794ugv"
      });
    </script>

<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">Home</a>
        
          
          
          
          
          
          
          <a href="/archives">Archives</a>
        
          
          
          
          
          
          
          <a href="/about">About</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">ORM框架</h1>
<article class="post markdown-style">
  <h2 id="ORM-框架-三层开发架构-中间件"><a href="#ORM-框架-三层开发架构-中间件" class="headerlink" title="ORM 框架\三层开发架构\中间件"></a>ORM 框架\三层开发架构\中间件</h2><p>[toc]</p>
<p>对象-关系映射（Object/Relation Mapping，简称ORM），是随着面向对象的软件开发方法发展而产生的。面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p>
<p>ORM方法论基于三个核心原则：</p>
<ul>
<li>  简单性：以最基本的形式建模数据。</li>
<li>  传达性：数据库结构被任何人都能理解的语言文档化。</li>
<li>  精确性：基于数据模型创建正确标准化了的结构。</li>
</ul>
<p>面向对象是从软件工程基本原则(如耦合、聚合、封装)的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象,对象关系映射技术应运而生。O/R中字母O起源于”对象”(Object),而R则来自于”关系”(Relational)。几乎所有的程序里面，都存在对象和关系数据库。在业务逻辑层和用户界面层中，我们是面向对象的。当对象信息发生变化的时候，我们需要把对象的信息保存在关系数据库中。</p>
<p>当开发一个应用程序的时候(不使用O/R Mapping),可能会写不少数据访问层的代码，用来从数据库保存，删除，读取对象信息，等等。在DAL中写了很多的方法来读取对象数据，改变状态对象等等任务。而这些代码写起来总是重复的。</p>
<p>如果开你最近的程序，看看DAL代码，肯定会看到很多近似的通用的模式。我们以保存对象的方法为例，传入一个对象，为SqlCommand对象添加SqlParameter，把所有属性和对象对应，设置SqlCommand的CommandText属性为存储过程，然后运行SqlCommand。对于每个对象都要重复的写这些代码。　　除此之外，还有更好的办法吗？有，引入一个O/R Mapping。实质上，一个O/R Mapping会为你生成DAL。与其自己写DAL代码，不如用O/R Mapping。用O/R Mapping保存，删除，读取对象，O/R Mapping负责生成SQL，你只需要关心对象就好。对象关系映射成功运用在不同的面向对象持久层产品中，</p>
<p> 一般的ORM包括以下四部分：　　</p>
<ul>
<li>  一个对持久类对象进行CRUD操作的API；　　</li>
<li>  一个语言或API用来规定与类和类属性相关的查询；　　</li>
<li>  一个规定mapping metadata的工具；　　</li>
<li>  一种技术可以让ORM的实现同事务对象一起进行dirty checking, lazy association fetching以及其他的优化操作。</li>
</ul>
<p>目前流行的 ORM 产品<br> Java系列：　</p>
<ul>
<li>   Apache OJB 　</li>
<li>   Cayenne 　　</li>
<li>   Jaxor 　　</li>
<li>   Hibernate　　</li>
<li>   iBatis　　</li>
<li>   jRelationalFramework 　</li>
<li>   mirage 　　</li>
<li>   SMYLE 　　</li>
<li>   TopLink</li>
</ul>
<p> 其中 TopLink 是 Oracle 的商业产品，其他均为开源项目。　　其中 Hibernate 的轻量级 ORM 模型逐步确立了在 Java ORM 架构中领导地位，甚至取代复杂而又繁琐的 EJB 模型而成为事实上的 Java ORM 工业标准。而且其中的许多设计均被 J2EE 标准组织吸纳而成为最新 EJB 3.0 规范的标准，</p>
<p>.Net系列：　</p>
<ul>
<li> NHibernate</li>
<li> NBear</li>
<li> Castle ActiveRecord</li>
<li> iBATIS.NET</li>
<li> DAAB　</li>
<li> EntitysCodeGenerate</li>
<li> EntityFormerWork</li>
<li> Linq to sql</li>
<li> PetaPoco</li>
</ul>
<p>一．NHibernate<br>   提起NHibernate，相信大家都不陌生，NHibernate来源于非常优秀的基于Java的Hibernate关系型持久化工具，它从数据库底层来持久化.Net对象到关系型数据库,NHibernate为我们完成这一切，而不用自己写SQL语句去操作数据库对象，所写的代码仅仅和对象关联，NHibernat自动产生SQL语句，并确保对象提交到正确的表和字段中去.大量减少开发时人工使用SQL和ADO.NET处理数据的时间. NHibernate可以帮助消除或者包装那些针对特定数据库的SQL代码，并且把结果集从表格的表示形式转换到一系列的对象去。NHibernate采用XML文件配置的方式，每一个实体类都会对应一个映射文件</p>
<p>二、EntitysCodeGenerate</p>
<p>EntitysCodeGenerate　 ：是（VB/C#.Net实体代码生成工具）的简称，EntitysCodeGenerate(ECG)是一款专门为.Net数据库程序开发量身定做的(ORM框架)代码生成工具，所生成的程序代码基于面向对象、分层架构、ORM及反射+工厂模式等。</p>
<p>三、 PetaPoco</p>
<p>PetaPoco是一款适用于.Net 和Mono的微小、快速、单文件的微型ORM。</p>
<p>PetaPoco有以下特色：</p>
<ul>
<li>微小，没有依赖项……单个的C#文件可以方便的添加到任何项目中。</li>
<li>工作于严格的没有装饰的Poco类，和几乎全部加了特性的Poco类</li>
<li>Insert/Delete/Update/Save and IsNew 等帮助方法。</li>
<li>分页支持：自动得到总行数和数据</li>
<li>支持简单的事务</li>
<li>更好的支持参数替换，包括从对象属性中抓取命名的参数。</li>
<li>很好的性能，剔除了Linq，并通过Dynamic方法快速的为属性赋值</li>
<li>T4模板自动生成Poco类</li>
<li>查询语言是Sql……不支持别扭的fluent或Linq语法（仁者见仁，智者见智）</li>
<li>包含一个低耦合的Sql Builder类，让内联的Sql更容易书写</li>
<li>为异常信息记录、值转换器安装和数据映射提供钩子。（Hooks for logging exceptions, installing value converters and mapping columns to properties without attributes.）</li>
<li>兼容SQL Server, SQL Server CE, MySQL, PostgreSQL and Oracle。</li>
<li>可以在.NET 3.5 或Mono 2.6或更高版本上运行</li>
<li>在.NET 4.0 和Mono 2.8下支持dynamic</li>
<li>NUnit单元测试</li>
<li>开源（Apache License）</li>
<li>所有功能大约用了1500行代码</li>
</ul>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p> CRUD是指在做计算处理时的增加(Create)、读取(Read)、更新(Update)和删除(Delete)几个单词的首字母简写。crud主要被用在描述软件系统中数据库或者<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%81%E4%B9%85%E5%B1%82/3584971">持久层</a>的基本操作功能。 </p>
<p>DAL是数据访问层的英文缩写，即为数据访问层（Data Access Layer）。其功能主要是负责数据库的访问。简单地说就是实现对数据表的Select（查询）、Insert（插入）、Update（更新）、Delete（删除）等操作。 </p>
<h2 id="三层开发架构"><a href="#三层开发架构" class="headerlink" title="三层开发架构"></a>三层开发架构</h2><p>三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或称为领域层）、表示层。</p>
<h3 id="1-表示层（USL）"><a href="#1-表示层（USL）" class="headerlink" title="1.表示层（USL）"></a>1.表示层（USL）</h3><p>主要表示WEB方式，也可以表示成WINFORM方式。如果逻辑层相当强大和完善，无论表现层如何定义和更改，逻辑层都能完善地提供服务。</p>
<p>表示层又称表现层UI，位于三层构架的最上层，与用户直接接触，主要是B/S信息系统中的Web浏览页面。作为Web浏览页面，表示层的主要功能是实现系统数据的传入与输出，在此过程中不需要借助逻辑判断操作就可以将数据传送到BLL系统中进行数据处理，处理后会将处理结果反馈到表示层中。换句话说，表示层就是实现用户界面功能，将用户的需求传达和反馈，并用BLL或者是Models进行调试，保证用户体验。 </p>
<h3 id="2-业务逻辑层（BLL）："><a href="#2-业务逻辑层（BLL）：" class="headerlink" title="2.业务逻辑层（BLL）："></a>2.业务逻辑层（BLL）：</h3><p>主要是针对具体的问题的操作，也可以理解成对数据层的操作，对数据业务逻辑处理。如果说数据层是积木，那逻辑层就是对这些积木的搭建。</p>
<p>业务逻辑层（Business Logic Layer）无疑是系统架构中体现核心价值的部分。它的关注点主要集中在业务规则的制定、业务流程的实现等与业务需求有关的系统设计，也即是说它是与系统所应对的领域（Domain）逻辑有关，很多时候，也将业务逻辑层称为领域层。 </p>
<p>业务逻辑层负责系统领域业务的处理，负责逻辑性数据的生成、处理及转换。对所输入的逻辑性数据的正确性及有效性负责，但对输出的逻辑性数据及用户性数据的正确性不负责，对数据的呈现样式不负责。 </p>
<p>业务逻辑层BLL的功能是对具体问题进行逻辑判断与执行操作，接收到表现层UI的用户指令后，会连接数据访问层DAL，访问层在三层构架中位于表示层与数据层中间位置，同时也是表示层与数据层的桥梁，实现三层之间的数据连接和指令传达，可以对接收数据进行逻辑处理，实现数据的修改、获取、删除等功能，并将处理结果反馈到表示层UI中，实现软件功能。 </p>
<p>例如Martin Fowler在《Patterns of Enterprise Application Architecture》一书中，将整个架构分为三个主要的层：表示层、领域层和数据源层。作为领域驱动设计的先驱Eric Evans，对业务逻辑层作了更细致地划分，细分为应用层与领域层，通过分层进一步将领域逻辑与领域逻辑的解决方案分离。</p>
<p>业务逻辑层在体系架构中的位置很关键，它处于数据访问层与表示层中间，起到了数据交换中承上启下的作用。由于层是一种弱耦合结构，层与层之间的依赖是向下的，底层对于上层而言是“无知”的，改变上层的设计对于其调用的底层而言没有任何影响。如果在分层设计时，遵循了面向接口设计的思想，那么这种向下的依赖也应该是一种弱依赖关系。因而在不改变接口定义的前提下，理想的分层式架构，应该是一个支持可抽取、可替换的“抽屉”式架构。正因为如此，业务逻辑层的设计对于一个支持可扩展的架构尤为关键，因为它扮演了两个不同的角色。对于数据访问层而言，它是调用者；对于表示层而言，它却是被调用者。依赖与被依赖的关系都纠结在业务逻辑层上，如何实现依赖关系的解耦，则是除了实现业务逻辑之外留给设计师的任务。</p>
<h3 id="3-数据访问层（DAL）-数据访"><a href="#3-数据访问层（DAL）-数据访" class="headerlink" title="3.数据访问层（DAL） 数据访"></a>3.数据访问层（DAL） 数据访</h3><p>问层DAL是数据库的主要操控系统，实现数据的增加、删除、修改、查询等操作，并将操作结果反馈到业务逻辑层BLL。在实际运行的过程中，数据访问层没有逻辑判断能力，为了实现代码编写的严谨性，提高代码阅读程度，一般软件开发人员会在该层中编写DataAccessCommon，保证数据访问层DAL数据处理功能。</p>
<p>主要是对原始数据(数据库或者文本文件等存放数据的形式)的操作层，而不是指原始数据，也就是说，是对数据的操作，而不是数据库，具体为业务逻辑层或表示层提供数据服务。</p>
<p>数据库访问层：又称为DAL层，有时候也称为是持久层，其功能主要是负责数据库的访问。简单地说就是实现对数据表的Select（查询）、Insert（插入）、Update（更新）、Delete（删除）等操作。如果要加入ORM的思想，就会包括对象和数据表之间的映射，以及对象实体的持久化操作。</p>
<p>在项目实际开发过程，有的直接采用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/JDBC">JDBC</a>技术进行数据库持久化操作，有的采用目前很好用的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ORM%E6%A1%86%E6%9E%B6">ORM框架</a>来进行数据库持久化操作。</p>
<p>抽取数据库访问层的主要作用是进行隔离，把与数据库打交道的事情都放在数据访问层解决，在服务层则只要调用数据访问层就可以了，不必和具体的ORM层实现相耦合。</p>
<p>讲到数据库访问层，不得不提下三层架构，通常会把应用系统划分为：表现层、业务逻辑层和数据库访问层。这样的设计目的是为了实现“高内聚，低耦合”的设计思想。数据库访问层在三层架构中只负责数据存储与读取。业务逻辑层作为数据库访问层的上层，内部调用数据库访问层提供的方法，来完成数据的存储与读取。数据库访问层与底层数据库应该是独立的，好的数据库访问层方案是能够在不修改程序代码功能的基础之上实现不同类型数据库的动态切换。我们比较熟悉的做法就是通过XML配置文件来完成底层数据库的切换。目前很多流行的数据库访问层框架都是采用这种方式来实现数据库的动态切换。数据访问层能够将应用程序中的数据持久化到存储介质中，通常我们使用的数据库都是关系型的数据库，采用的数据模型都是对象模型，这就需要数据库访问层实现对象模型与关系模型直接的、互相的转换。</p>
<p>DAO(Data Access Object)是一个数据访问接口，数据访问：顾名思义就是与数据库打交道。夹在业务逻辑与数据库资源中间。</p>
<p>在核心J2EE模式中是这样介绍DAO模式的：为了建立一个健壮的J2EE应用，应该将所有对数据源的访问操作抽象封装在一个公共API中。用程序设计的语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口在逻辑上对应这个特定的数据存储。</p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p> 中间件是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。目前，它并没有很严格的定义，但是普遍接受IDC的定义：中间件是一种独立的系统软件服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。从这个意义上可以用一个等式来表示中间件：中间件=平台+通信，这也就限定了只有用于分布式系统中才能叫中间件，同时也把它与支撑软件和实用软件区分开来。 </p>
<p>中间件是一类连接软件组件和应用的计算机软件，它包括一组服务。以便于运行在一台或多台机器上的多个软件通过网络进行交互。该技术所提供的互操作性，推动了一致分布式体系架构的演进，该架构通常用于支持并简化那些复杂的分布式应用程序，它包括web服务器、事务监控器和消息队列软件。 </p>
<p>中间件(middleware)是基础软件的一大类，属于可复用软件的范畴。顾名思义，中间件处于操作系统软件与用户的应用软件的中间。 </p>
<p>中间件在操作系统、网络和数据库之上，应用软件的下层，总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件。在众多关于中间件的定义中，比较普遍被接受的是IDC表述的：中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。 </p>
<p>近年来，人类生活中越来越多的领域已经变得离不开计算机、网络技术以及通信技术。并且随着计算机技术的快速发展，更多的应用软件被要求在许多不同的网络协议、不同的硬件生产厂商以及不一样的网络平台和环境上运营。这导致了软件开发者需要面临数据离散、操作困难、系统匹配程度低，以及需要开发多种应用程序来达到运营的目的。所以，中间件技术的产生，在极大程度上减轻了开发者的负担，使得网络的运行更有效率。</p>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>中间件是独立的系统级软件，连接操作系统层和应用程序层，将不同操作系统提供应用的接口标准化，协议统一化，屏蔽具体操作的细节，中间件一般提供如下功能： </p>
<p>####（1）通信支持</p>
<p>中间件为其所支持的应用软件提供平台化的运行环境，该环境屏蔽底层通信之间的接口差异，实现互操作，</p>
<p>所以通信支持是中间件一个最基本的功能。早期应用与分布式的中间件交互主要的通信方式为远程调用和消息两种方式。通信模块中，远程调用通过网络进行通信，通过支持数据的转换和通信服务，从而屏蔽不同的操作系统和网络协议。远程调用是提供给予过程的服务访问，为上层系统只提供非常简单的编程接口或过程调用模型。消息提供异步交互的机制。 [3]</p>
<p>####（2）应用支持</p>
<p>中间件的目的就是服务上层应用，提供应用层不同服务之间的互操作机制。它为上层应用开发提供统一的平台和运行环境，并封装不同操作系统提供API接口，向应用提供统一的标准接口，使应用的开发和运行与操作系统无关，实现其独立性。中间件松耦合的结构，标准的封装服务和接口，有效的互操作机制，从而给应用结构化和开发方法提供有力的支持。 </p>
<p>####（3）公共服务</p>
<p>公共服务是对应用软件中共性功能或约束的提取。将这些共性的功能或者约束分类实现，并支持复用，作为公共服务，提供给应用程序使用。通过提供标准、统一的公共服务，可减少上层应用的开发工作量，缩短应用的开发时间，并有助于提供应用软件的质量。  </p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>####（1）事务式中间件</p>
<p>事务式中间件又称事务处理管理程序，是当前用的最广泛的中间件之一，其主要功能是提供联机事务处理所需要的通信、并发访问控制、事务控制、资源管理、安全管理、负载平衡、故障恢复和其他必要的服务。事务式中间件支持大量客户进程的并发访问，具有极强的扩展性。由于事务式中间件具有可靠性高、极强的扩展性等特点，主要应用于电信、金融、飞机订票系统、证券等拥有大量客户的领域。 [3] </p>
<p>####（2）过程式中间件</p>
<p>过程式中间件又称远程过程调用中间件。过程中间件一般从逻辑上分为两部分：客户和服务器。客户和服务器是一个逻辑概念，既可以运行在同一计算机上，也可以运行在不同的计算机上，甚至客户和服务器底层的操作系统也可以不同。客户机和服务器之间的通信可以使用同步通信，也可以采用线程式异步调用。所以过程式中间件有较好的异构支持能力，简单易用，但由于客户和服务器之间采用访问连接，所以在易剪裁性和容错方面有一定的局限性。 [3] </p>
<p>####（3）面向消息的中间件</p>
<p>面向消息的中间件，简称为消息中间件，是一类以消息为载体进行通信的中间件，利用高效可靠的消息机制来实现不同应用间大量的数据交换。按其通信模型的不同，消息中间件的通信模型有两类：消息队列和消息传递。通过这两种消息模型，不同应用之间的通信和网络的复杂性脱离，摆脱对不同通信协议的依赖，可以在复杂的网络环境中高可靠、高效率的实现安全的异步通信。消息中间件的非直接连接，支持多种通信规程，达到多个系统之间的数据的共享和同步。面向消息中间件是一类常用的中间件。 </p>
<p>####（4）面向对象中间件</p>
<p>面向对象中间件又称分布对象中间件，是分布式计算技术和面向对象技术发展的结合，简称对象中间件。分布对象模型是面向对象模型在分布异构环境下的自然拓广。面向对象中间件给应用层提供过重不同形式的通信服务，通过这些服务，上层应用对事务处理、分布式数据访问，对象管理等处理更简单易行。OMG组织是分布对象技术标准化方面的国际组织，它制定出了CORBA等标准。 </p>
<p>####（5）Web应用服务器</p>
<p>Web应用服务器是Web服务器和应用服务器相结合的产物。应用服务器中间件可以说是软件的基础设施，利用构件化技术将应用软件整合到一个确定的协同工作环境中，并提供多种通信机制，事务处理能力，及应用的开发管理功能。由于直接支持三层或多层应用系统的开发，应用服务器受到了广大用户的欢迎，是目前中间件市场上竞争的热点，J2EE架构是目前应用服务器方面的主流标准。 </p>
<p>####（6）其他</p>
<p>新的应用需求、新的技术创新、新的应用领域促成了新的中间件产品的出现。如，ASAAC在研究标准航空电子体系结构时提出的通用系统管理GSM，属于典型的嵌入式航电系统的中间件，互联网云技术的发展云计算中间件、物流网的中间件等随着应用市场的需求应运而生。 </p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="/2021/03/24/pktgen%E5%8A%9F%E8%83%BD/">prev</a>
    

    
    <p>last update time 2021-03-24</p>
    
    
        <a class="extend next post-next" href="/2021/03/24/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/">next</a>
    
    </div>

    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:1178752402@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/CaiChenghan" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://www.jianshu.com/u/565c8e790605" title="jianshu" target="_self">
					<i class="fa fa-jianshu"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © xbo 2017 - 2021
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>
    </div>
</body>
</html>
